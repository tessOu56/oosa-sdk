/* tslint:disable */
/* eslint-disable */
/**
 * OOSA
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AchievementEvent
 */
export interface AchievementEvent {
    /**
     * 
     * @type {string}
     * @memberof AchievementEvent
     */
    'achievement_released_id': string;
    /**
     * 
     * @type {string}
     * @memberof AchievementEvent
     */
    'achievement_released_name': string;
    /**
     * 
     * @type {number}
     * @memberof AchievementEvent
     */
    'achievement_released_lat': number;
    /**
     * 
     * @type {number}
     * @memberof AchievementEvent
     */
    'achievement_released_lng': number;
    /**
     * 
     * @type {number}
     * @memberof AchievementEvent
     */
    'achievement_released_count': number;
}
/**
 * 
 * @export
 * @interface AchievementStatistics
 */
export interface AchievementStatistics {
    /**
     * 
     * @type {Array<EventStatistics>}
     * @memberof AchievementStatistics
     */
    'oosa_star_current_user': Array<EventStatistics>;
    /**
     * 
     * @type {Array<UserStarStatistics>}
     * @memberof AchievementStatistics
     */
    'oosa_star_per_user': Array<UserStarStatistics>;
    /**
     * 
     * @type {number}
     * @memberof AchievementStatistics
     */
    'stars_months_last_achieved': number;
    /**
     * 
     * @type {string}
     * @memberof AchievementStatistics
     */
    'stars_last_achieved_month': string;
    /**
     * 
     * @type {string}
     * @memberof AchievementStatistics
     */
    'statistics_last_rewilding': string;
    /**
     * 
     * @type {Array<EventStatistics>}
     * @memberof AchievementStatistics
     */
    'statistics_rewilding_by_month': Array<EventStatistics>;
    /**
     * 
     * @type {Array<EventTypeGroupStatistics>}
     * @memberof AchievementStatistics
     */
    'user_star_by_type': Array<EventTypeGroupStatistics>;
    /**
     * 
     * @type {number}
     * @memberof AchievementStatistics
     */
    'user_star_per_year': number;
}
/**
 * 
 * @export
 * @interface AuthByEmail404Response
 */
export interface AuthByEmail404Response {
    /**
     * message
     * @type {string}
     * @memberof AuthByEmail404Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ChangeEventInvitationStat200Response
 */
export interface ChangeEventInvitationStat200Response {
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_id': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_event': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_user': string;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_status': number;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_status_label': string;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_is_paid': number;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_paid_amount': number;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_paid_at': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_payment_request': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_payment_response': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_experience': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_request_message': string;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_random_count': number;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_polaroid_count': number;
    /**
     * 
     * @type {number}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_star_type': number;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participants_created_at': string;
    /**
     * 
     * @type {ChangeEventInvitationStat200ResponseEventParticipantInvitation}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participant_invitation': ChangeEventInvitationStat200ResponseEventParticipantInvitation;
    /**
     * 
     * @type {Null}
     * @memberof ChangeEventInvitationStat200Response
     */
    'event_participant_badges': Null;
}
/**
 * 
 * @export
 * @interface ChangeEventInvitationStat200ResponseEventParticipantInvitation
 */
export interface ChangeEventInvitationStat200ResponseEventParticipantInvitation {
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200ResponseEventParticipantInvitation
     */
    'invitation_message': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeEventInvitationStat200ResponseEventParticipantInvitation
     */
    'invitation_template': string;
}
/**
 * 
 * @export
 * @interface CollaborativeLog
 */
export interface CollaborativeLog {
    /**
     * 
     * @type {string}
     * @memberof CollaborativeLog
     */
    'collaborative_log_album_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollaborativeLog
     */
    'collaborative_log_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollaborativeLog
     */
    'collaborative_log_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollaborativeLog
     */
    'collaborative_log_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof CollaborativeLog
     */
    'collaborative_log_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CollaborativeLog
     */
    'collaborative_log_visibility'?: number;
}
/**
 * 
 * @export
 * @interface CollaborativeLogRandomCount
 */
export interface CollaborativeLogRandomCount {
    /**
     * 
     * @type {number}
     * @memberof CollaborativeLogRandomCount
     */
    'random_count'?: number;
}
/**
 * 
 * @export
 * @interface ContactUs
 */
export interface ContactUs {
    /**
     * 序列 id
     * @type {string}
     * @memberof ContactUs
     */
    'contact_us_id': string;
    /**
     * 資料建立時間
     * @type {string}
     * @memberof ContactUs
     */
    'contact_us_created_at': string;
    /**
     * 聯絡信箱
     * @type {string}
     * @memberof ContactUs
     */
    'contact_us_email': string;
    /**
     * 聯繫內容
     * @type {string}
     * @memberof ContactUs
     */
    'contact_us_message': string;
}
/**
 * @type ContinueWith
 * @export
 */
export type ContinueWith = { action: 'redirect_browser_to' } & ContinueWithRedirectBrowserTo | { action: 'set_ory_session_token' } & ContinueWithSetOrySessionToken | { action: 'show_recovery_ui' } & ContinueWithRecoveryUi | { action: 'show_settings_ui' } & ContinueWithSettingsUi | { action: 'show_verification_ui' } & ContinueWithVerificationUi;

/**
 * Indicates, that the UI flow could be continued by showing a recovery ui
 * @export
 * @interface ContinueWithRecoveryUi
 */
export interface ContinueWithRecoveryUi {
    /**
     * Action will always be `show_recovery_ui` show_recovery_ui ContinueWithActionShowRecoveryUIString
     * @type {string}
     * @memberof ContinueWithRecoveryUi
     */
    'action': ContinueWithRecoveryUiActionEnum;
    /**
     * 
     * @type {ContinueWithRecoveryUiFlow}
     * @memberof ContinueWithRecoveryUi
     */
    'flow': ContinueWithRecoveryUiFlow;
}

export const ContinueWithRecoveryUiActionEnum = {
    ShowRecoveryUi: 'show_recovery_ui'
} as const;

export type ContinueWithRecoveryUiActionEnum = typeof ContinueWithRecoveryUiActionEnum[keyof typeof ContinueWithRecoveryUiActionEnum];

/**
 * 
 * @export
 * @interface ContinueWithRecoveryUiFlow
 */
export interface ContinueWithRecoveryUiFlow {
    /**
     * The ID of the recovery flow
     * @type {string}
     * @memberof ContinueWithRecoveryUiFlow
     */
    'id': string;
    /**
     * The URL of the recovery flow  If this value is set, redirect the user\'s browser to this URL. This value is typically unset for native clients / API flows.
     * @type {string}
     * @memberof ContinueWithRecoveryUiFlow
     */
    'url'?: string;
}
/**
 * Indicates, that the UI flow could be continued by showing a recovery ui
 * @export
 * @interface ContinueWithRedirectBrowserTo
 */
export interface ContinueWithRedirectBrowserTo {
    /**
     * Action will always be `redirect_browser_to` redirect_browser_to ContinueWithActionRedirectBrowserToString
     * @type {string}
     * @memberof ContinueWithRedirectBrowserTo
     */
    'action': ContinueWithRedirectBrowserToActionEnum;
    /**
     * The URL to redirect the browser to
     * @type {string}
     * @memberof ContinueWithRedirectBrowserTo
     */
    'redirect_browser_to': string;
}

export const ContinueWithRedirectBrowserToActionEnum = {
    RedirectBrowserTo: 'redirect_browser_to'
} as const;

export type ContinueWithRedirectBrowserToActionEnum = typeof ContinueWithRedirectBrowserToActionEnum[keyof typeof ContinueWithRedirectBrowserToActionEnum];

/**
 * Indicates that a session was issued, and the application should use this token for authenticated requests
 * @export
 * @interface ContinueWithSetOrySessionToken
 */
export interface ContinueWithSetOrySessionToken {
    /**
     * Action will always be `set_ory_session_token` set_ory_session_token ContinueWithActionSetOrySessionTokenString
     * @type {string}
     * @memberof ContinueWithSetOrySessionToken
     */
    'action': ContinueWithSetOrySessionTokenActionEnum;
    /**
     * Token is the token of the session
     * @type {string}
     * @memberof ContinueWithSetOrySessionToken
     */
    'ory_session_token': string;
}

export const ContinueWithSetOrySessionTokenActionEnum = {
    SetOrySessionToken: 'set_ory_session_token'
} as const;

export type ContinueWithSetOrySessionTokenActionEnum = typeof ContinueWithSetOrySessionTokenActionEnum[keyof typeof ContinueWithSetOrySessionTokenActionEnum];

/**
 * Indicates, that the UI flow could be continued by showing a settings ui
 * @export
 * @interface ContinueWithSettingsUi
 */
export interface ContinueWithSettingsUi {
    /**
     * Action will always be `show_settings_ui` show_settings_ui ContinueWithActionShowSettingsUIString
     * @type {string}
     * @memberof ContinueWithSettingsUi
     */
    'action': ContinueWithSettingsUiActionEnum;
    /**
     * 
     * @type {ContinueWithSettingsUiFlow}
     * @memberof ContinueWithSettingsUi
     */
    'flow': ContinueWithSettingsUiFlow;
}

export const ContinueWithSettingsUiActionEnum = {
    ShowSettingsUi: 'show_settings_ui'
} as const;

export type ContinueWithSettingsUiActionEnum = typeof ContinueWithSettingsUiActionEnum[keyof typeof ContinueWithSettingsUiActionEnum];

/**
 * 
 * @export
 * @interface ContinueWithSettingsUiFlow
 */
export interface ContinueWithSettingsUiFlow {
    /**
     * The ID of the settings flow
     * @type {string}
     * @memberof ContinueWithSettingsUiFlow
     */
    'id': string;
    /**
     * The URL of the settings flow  If this value is set, redirect the user\'s browser to this URL. This value is typically unset for native clients / API flows.
     * @type {string}
     * @memberof ContinueWithSettingsUiFlow
     */
    'url'?: string;
}
/**
 * Indicates, that the UI flow could be continued by showing a verification ui
 * @export
 * @interface ContinueWithVerificationUi
 */
export interface ContinueWithVerificationUi {
    /**
     * Action will always be `show_verification_ui` show_verification_ui ContinueWithActionShowVerificationUIString
     * @type {string}
     * @memberof ContinueWithVerificationUi
     */
    'action': ContinueWithVerificationUiActionEnum;
    /**
     * 
     * @type {ContinueWithVerificationUiFlow}
     * @memberof ContinueWithVerificationUi
     */
    'flow': ContinueWithVerificationUiFlow;
}

export const ContinueWithVerificationUiActionEnum = {
    ShowVerificationUi: 'show_verification_ui'
} as const;

export type ContinueWithVerificationUiActionEnum = typeof ContinueWithVerificationUiActionEnum[keyof typeof ContinueWithVerificationUiActionEnum];

/**
 * 
 * @export
 * @interface ContinueWithVerificationUiFlow
 */
export interface ContinueWithVerificationUiFlow {
    /**
     * The ID of the verification flow
     * @type {string}
     * @memberof ContinueWithVerificationUiFlow
     */
    'id': string;
    /**
     * The URL of the verification flow  If this value is set, redirect the user\'s browser to this URL. This value is typically unset for native clients / API flows.
     * @type {string}
     * @memberof ContinueWithVerificationUiFlow
     */
    'url'?: string;
    /**
     * The address that should be verified in this flow
     * @type {string}
     * @memberof ContinueWithVerificationUiFlow
     */
    'verifiable_address': string;
}
/**
 * 
 * @export
 * @interface CreateEventParticipant200ResponseInner
 */
export interface CreateEventParticipant200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_user'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_status_label'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_is_paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_paid_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_payment_request'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_payment_response'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_experience'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_request_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_random_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_polaroid_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_star_type'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participants_created_at'?: string;
    /**
     * 
     * @type {ChangeEventInvitationStat200ResponseEventParticipantInvitation}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participant_invitation'?: ChangeEventInvitationStat200ResponseEventParticipantInvitation;
    /**
     * 
     * @type {Null}
     * @memberof CreateEventParticipant200ResponseInner
     */
    'event_participant_badges'?: Null;
}
/**
 * 
 * @export
 * @interface CreateEventScheduleRequest
 */
export interface CreateEventScheduleRequest {
    /**
     * 
     * @type {Array<Array<EventScheduleBulkItemTime>>}
     * @memberof CreateEventScheduleRequest
     */
    'schedules': Array<Array<EventScheduleBulkItemTime>>;
}
/**
 * 
 * @export
 * @interface CreateNews200Response
 */
export interface CreateNews200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNews200Response
     */
    'news_created_by': string;
}
/**
 * 
 * @export
 * @interface CreateNotification206ResponseInner
 */
export interface CreateNotification206ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof CreateNotification206ResponseInner
     */
    'error': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotification206ResponseInner
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CreateNotification500Response
 */
export interface CreateNotification500Response {
    /**
     * message
     * @type {string}
     * @memberof CreateNotification500Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateNotificationRequest
 */
export interface CreateNotificationRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateNotificationRequest
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof CreateNotificationRequest
     */
    'event': string;
    /**
     * 
     * @type {object}
     * @memberof CreateNotificationRequest
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface CreateRewild200Response
 */
export interface CreateRewild200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRewild200Response
     */
    'rewilding_location': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_country_code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_achievement_type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_achievement_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateRewild200Response
     */
    'rewilding_rating': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRewild200Response
     */
    'rewilding_lat': number;
    /**
     * 
     * @type {number}
     * @memberof CreateRewild200Response
     */
    'rewilding_lng': number;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_place_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateRewild200Response
     */
    'rewilding_elevation': number;
    /**
     * 
     * @type {Array<GetRewild200ResponseRewildingPhotosInner>}
     * @memberof CreateRewild200Response
     */
    'rewilding_photos': Array<GetRewild200ResponseRewildingPhotosInner>;
    /**
     * 
     * @type {Array<GetRewild200ResponseRewildingReferenceLinksInner>}
     * @memberof CreateRewild200Response
     */
    'rewilding_reference_links': Array<GetRewild200ResponseRewildingReferenceLinksInner>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRewild200Response
     */
    'rewilding_apply_official': boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRewild200Response
     */
    'rewilding_created_at': string;
}
/**
 * 
 * @export
 * @interface CreateUserFriendById200Response
 */
export interface CreateUserFriendById200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_status': number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_user_1': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_user_2': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_created_at': string;
    /**
     * 
     * @type {Null}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_is_official': Null;
    /**
     * 
     * @type {number}
     * @memberof CreateUserFriendById200Response
     */
    'rewilding_activity_status': number;
    /**
     * 
     * @type {GetOtherUserFriends200ResponseInnerUserFriendsDetail}
     * @memberof CreateUserFriendById200Response
     */
    'user_friends_detail': GetOtherUserFriends200ResponseInnerUserFriendsDetail;
}
/**
 * 
 * @export
 * @interface DeletePocketListItemRequest
 */
export interface DeletePocketListItemRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeletePocketListItemRequest
     */
    'pocket_list_items_id': Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorBrowserLocationChangeRequired
 */
export interface ErrorBrowserLocationChangeRequired {
    /**
     * 
     * @type {ErrorGeneric}
     * @memberof ErrorBrowserLocationChangeRequired
     */
    'error'?: ErrorGeneric;
    /**
     * Points to where to redirect the user to next.
     * @type {string}
     * @memberof ErrorBrowserLocationChangeRequired
     */
    'redirect_browser_to'?: string;
}
/**
 * The standard Ory JSON API error format.
 * @export
 * @interface ErrorGeneric
 */
export interface ErrorGeneric {
    /**
     * 
     * @type {GenericError}
     * @memberof ErrorGeneric
     */
    'error': GenericError;
}
/**
 * 
 * @export
 * @interface EventAccounting
 */
export interface EventAccounting {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventAccounting
     */
    'event_accounting_created_by_user'?: UserAgg;
    /**
     * 
     * @type {number}
     * @memberof EventAccounting
     */
    'event_accounting_amount': number;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_event': string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_message': string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccounting
     */
    'event_accounting_updated_by'?: string;
}
/**
 * 
 * @export
 * @interface EventAccountingSingle
 */
export interface EventAccountingSingle {
    /**
     * 
     * @type {number}
     * @memberof EventAccountingSingle
     */
    'event_accounting_amount': number;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAccountingSingle
     */
    'event_accounting_updated_by'?: string;
}
/**
 * 
 * @export
 * @interface EventAlbumLink
 */
export interface EventAlbumLink {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventAlbumLink
     */
    'event_album_link_created_by_user'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLink
     */
    'event_album_link_album_url': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLink
     */
    'event_album_link_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLink
     */
    'event_album_link_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLink
     */
    'event_album_link_event': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLink
     */
    'event_album_link_id': string;
    /**
     * 
     * @type {number}
     * @memberof EventAlbumLink
     */
    'event_album_link_visibility': number;
}
/**
 * 
 * @export
 * @interface EventAlbumLinkSimple
 */
export interface EventAlbumLinkSimple {
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_album_url': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_event': string;
    /**
     * 
     * @type {string}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_id': string;
    /**
     * 
     * @type {number}
     * @memberof EventAlbumLinkSimple
     */
    'event_album_link_visibility': number;
}
/**
 * 
 * @export
 * @interface EventAnnouncement
 */
export interface EventAnnouncement {
    /**
     * 
     * @type {Array<EventAnnouncementEventAnnouncementInner>}
     * @memberof EventAnnouncement
     */
    'event_announcement': Array<EventAnnouncementEventAnnouncementInner>;
    /**
     * 
     * @type {string}
     * @memberof EventAnnouncement
     */
    'event_announcement_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventAnnouncement
     */
    'event_announcement_event_id': string;
}
/**
 * 
 * @export
 * @interface EventAnnouncementEventAnnouncementInner
 */
export interface EventAnnouncementEventAnnouncementInner {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventAnnouncementEventAnnouncementInner
     */
    'event_announcement_message': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EventAnnouncementEventAnnouncementInner
     */
    'event_announcement_category': string;
}
/**
 * 
 * @export
 * @interface EventMessageBoard
 */
export interface EventMessageBoard {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventMessageBoard
     */
    'event_message_board_created_by_user'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_base_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoard
     */
    'event_message_board_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventMessageBoard
     */
    'event_message_board_is_pinned'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventMessageBoard
     */
    'event_message_board_status'?: number;
}
/**
 * 
 * @export
 * @interface EventMessageBoardSimple
 */
export interface EventMessageBoardSimple {
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_announcement'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_base_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_category'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_is_pinned'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventMessageBoardSimple
     */
    'event_message_board_status'?: number;
}
/**
 * 
 * @export
 * @interface EventParticipants
 */
export interface EventParticipants {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventParticipants
     */
    'event_participants_user_detail'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventParticipants
     */
    'event_participants_is_paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventParticipants
     */
    'event_participants_paid_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_payment_request'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_payment_response'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventParticipants
     */
    'event_participants_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_status_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipants
     */
    'event_participants_user'?: string;
}
/**
 * 
 * @export
 * @interface EventParticipantsInvitation
 */
export interface EventParticipantsInvitation {
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_user'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_user_detail'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_is_paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_paid_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_paid_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_payment_request'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_payment_response'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_experience'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_request_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitation
     */
    'event_participants_created_by'?: string;
    /**
     * 
     * @type {EventParticipantsInvitationEventParticipantInvitation}
     * @memberof EventParticipantsInvitation
     */
    'event_participant_invitation'?: EventParticipantsInvitationEventParticipantInvitation;
}
/**
 * 
 * @export
 * @interface EventParticipantsInvitationEventParticipantInvitation
 */
export interface EventParticipantsInvitationEventParticipantInvitation {
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitationEventParticipantInvitation
     */
    'invitation_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventParticipantsInvitationEventParticipantInvitation
     */
    'invitation_template'?: string;
}
/**
 * 
 * @export
 * @interface EventPolaroids
 */
export interface EventPolaroids {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventPolaroids
     */
    'event_polaroids_created_by_user'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroids
     */
    'event_polaroids_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroids
     */
    'event_polaroids_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroids
     */
    'event_polaroids_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroids
     */
    'event_polaroids_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventPolaroids
     */
    'event_polaroids_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventPolaroids
     */
    'event_polaroids_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroids
     */
    'event_polaroids_url'?: string;
}
/**
 * 
 * @export
 * @interface EventPolaroidsSimple
 */
export interface EventPolaroidsSimple {
    /**
     * 
     * @type {string}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_event': string;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_id': string;
    /**
     * 
     * @type {number}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_lat': number;
    /**
     * 
     * @type {number}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_lng': number;
    /**
     * 
     * @type {string}
     * @memberof EventPolaroidsSimple
     */
    'event_polaroids_url': string;
}
/**
 * 
 * @export
 * @interface EventReferenceLinks
 */
export interface EventReferenceLinks {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_created_by_user'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinks
     */
    'event_reference_links_title'?: string;
}
/**
 * 
 * @export
 * @interface EventReferenceLinksSimple
 */
export interface EventReferenceLinksSimple {
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_event': string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_id': string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_link': string;
    /**
     * 
     * @type {string}
     * @memberof EventReferenceLinksSimple
     */
    'event_reference_links_title': string;
}
/**
 * 
 * @export
 * @interface EventScheduleBulkItemTime
 */
export interface EventScheduleBulkItemTime {
    /**
     * 
     * @type {string}
     * @memberof EventScheduleBulkItemTime
     */
    'time': string;
    /**
     * 
     * @type {string}
     * @memberof EventScheduleBulkItemTime
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface EventSchedules
 */
export interface EventSchedules {
    /**
     * 
     * @type {UserAgg}
     * @memberof EventSchedules
     */
    'event_schedules_created_by_user'?: UserAgg;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_datetime'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSchedules
     */
    'event_schedules_id'?: string;
}
/**
 * 
 * @export
 * @interface EventStatistics
 */
export interface EventStatistics {
    /**
     * 
     * @type {EventStatisticsId}
     * @memberof EventStatistics
     */
    'event_period': EventStatisticsId;
    /**
     * 
     * @type {number}
     * @memberof EventStatistics
     */
    'event_count': number;
}
/**
 * 
 * @export
 * @interface EventStatisticsId
 */
export interface EventStatisticsId {
    /**
     * 
     * @type {number}
     * @memberof EventStatisticsId
     */
    'month': number;
    /**
     * 
     * @type {number}
     * @memberof EventStatisticsId
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface EventTypeGroupStatistics
 */
export interface EventTypeGroupStatistics {
    /**
     * 
     * @type {string}
     * @memberof EventTypeGroupStatistics
     */
    'event_type': string;
    /**
     * 
     * @type {string}
     * @memberof EventTypeGroupStatistics
     */
    'event_type_name': string;
    /**
     * 
     * @type {number}
     * @memberof EventTypeGroupStatistics
     */
    'event_count': number;
}
/**
 * 
 * @export
 * @interface EventTypeStatistics
 */
export interface EventTypeStatistics {
    /**
     * 
     * @type {string}
     * @memberof EventTypeStatistics
     */
    'event_type': string;
    /**
     * 
     * @type {number}
     * @memberof EventTypeStatistics
     */
    'event_count': number;
}
/**
 * 
 * @export
 * @interface Events
 */
export interface Events {
    /**
     * 
     * @type {UserAgg}
     * @memberof Events
     */
    'events_created_by_user'?: UserAgg;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_city_id': number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_date': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_date_end': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_deadline': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_id': string;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_lat': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_lng': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_meeting_point_lat': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_meeting_point_lng': number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_meeting_point_name': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_name': string;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_participant_limit': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_payment_fee': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_payment_required': number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_photo': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_place': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_questionnaire_link': string;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_requires_approval': number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_rewilding': string;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_statistic_distance': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_statistic_member_count': number;
    /**
     * 
     * @type {number}
     * @memberof Events
     */
    'events_statistic_time': number;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_updated_by'?: string;
    /**
     * 
     * @type {EventsEventsParticipants}
     * @memberof Events
     */
    'events_participants'?: EventsEventsParticipants;
    /**
     * 
     * @type {RewildingDetail}
     * @memberof Events
     */
    'events_rewilding_detail'?: RewildingDetail;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_type': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_invitation_template': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_invitation_message': string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'events_invitation_no': string;
}
/**
 * 
 * @export
 * @interface EventsDeleted
 */
export interface EventsDeleted {
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_city_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_date_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_deadline'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_deleted'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_deleted_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_invitation_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_lng'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_meeting_point_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_meeting_point_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_participant_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_payment_fee'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_payment_required'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_place'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_questionnaire_link'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_requires_approval'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_rewilding'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_statistic_distance'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_statistic_member_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsDeleted
     */
    'events_statistic_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsDeleted
     */
    'events_updated_by'?: string;
}
/**
 * 
 * @export
 * @interface EventsEventsParticipants
 */
export interface EventsEventsParticipants {
    /**
     * 最近參加的三個人
     * @type {Array<UserAgg>}
     * @memberof EventsEventsParticipants
     */
    'latest_tree_user': Array<UserAgg> | null;
    /**
     * 總人數-3
     * @type {number}
     * @memberof EventsEventsParticipants
     */
    'remain_number': number;
}
/**
 * 
 * @export
 * @interface EventsSimple
 */
export interface EventsSimple {
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_city_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_date_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_deadline'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_invitation_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_lng'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_meeting_point_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_meeting_point_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_participant_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_payment_fee'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_payment_required'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_place'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_questionnaire_link'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_requires_approval'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_rewilding'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_statistic_distance'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_statistic_member_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventsSimple
     */
    'events_statistic_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsSimple
     */
    'events_updated_by'?: string;
}
/**
 * 
 * @export
 * @interface FlowError
 */
export interface FlowError {
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof FlowError
     */
    'created_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof FlowError
     */
    'error'?: object;
    /**
     * ID of the error container.
     * @type {string}
     * @memberof FlowError
     */
    'id': string;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof FlowError
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * The status code
     * @type {number}
     * @memberof GenericError
     */
    'code'?: number;
    /**
     * Debug information  This field is often not exposed to protect against leaking sensitive information.
     * @type {string}
     * @memberof GenericError
     */
    'debug'?: string;
    /**
     * Further error details
     * @type {object}
     * @memberof GenericError
     */
    'details'?: object;
    /**
     * The error ID  Useful when trying to identify various errors in application logic.
     * @type {string}
     * @memberof GenericError
     */
    'id'?: string;
    /**
     * Error message  The error\'s message.
     * @type {string}
     * @memberof GenericError
     */
    'message': string;
    /**
     * A human-readable reason for the error
     * @type {string}
     * @memberof GenericError
     */
    'reason'?: string;
    /**
     * The request ID  The request ID is often exposed internally in order to trace errors across service architectures. This is often a UUID.
     * @type {string}
     * @memberof GenericError
     */
    'request'?: string;
    /**
     * The status description
     * @type {string}
     * @memberof GenericError
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetAllEventsInvitations200ResponseInner
 */
export interface GetAllEventsInvitations200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_event': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_user': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_status': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_status_label': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_is_paid': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_paid_amount': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_paid_at': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_payment_request': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_payment_response': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_experience': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_request_message': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_random_count': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_polaroid_count': number;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_star_type': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_created_at': string;
    /**
     * 
     * @type {ChangeEventInvitationStat200ResponseEventParticipantInvitation}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participant_invitation': ChangeEventInvitationStat200ResponseEventParticipantInvitation;
    /**
     * 
     * @type {GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participants_invited_by': GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy;
    /**
     * 
     * @type {Null}
     * @memberof GetAllEventsInvitations200ResponseInner
     */
    'event_participant_badges': Null;
}
/**
 * 
 * @export
 * @interface GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
 */
export interface GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy {
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
     */
    'user_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
     */
    'user_avatar': string;
    /**
     * 
     * @type {number}
     * @memberof GetAllEventsInvitations200ResponseInnerEventParticipantsInvitedBy
     */
    'user_event_scheduled': number;
}
/**
 * 
 * @export
 * @interface GetBadgeById200Response
 */
export interface GetBadgeById200Response {
    /**
     * 
     * @type {UserBadgesDetail}
     * @memberof GetBadgeById200Response
     */
    'user_badges_detail'?: UserBadgesDetail;
    /**
     * 
     * @type {string}
     * @memberof GetBadgeById200Response
     */
    'user_badges_badge'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBadgeById200Response
     */
    'user_badges_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBadgeById200Response
     */
    'user_badges_user'?: string;
}
/**
 * 
 * @export
 * @interface GetOtherUserFriends200ResponseInner
 */
export interface GetOtherUserFriends200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_user_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_user_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_created_at'?: string;
    /**
     * 
     * @type {Null}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_is_official'?: Null;
    /**
     * 
     * @type {number}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'rewilding_activity_status'?: number;
    /**
     * 
     * @type {GetOtherUserFriends200ResponseInnerUserFriendsDetail}
     * @memberof GetOtherUserFriends200ResponseInner
     */
    'user_friends_detail'?: GetOtherUserFriends200ResponseInnerUserFriendsDetail;
}
/**
 * 
 * @export
 * @interface GetOtherUserFriends200ResponseInnerUserFriendsDetail
 */
export interface GetOtherUserFriends200ResponseInnerUserFriendsDetail {
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_username': string;
    /**
     * 
     * @type {string}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_avatar': string;
    /**
     * 
     * @type {number}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_breathing_status': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetOtherUserFriends200ResponseInnerUserFriendsDetail
     */
    'user_take_me_status': boolean;
}
/**
 * 
 * @export
 * @interface GetPocketListItem200Response
 */
export interface GetPocketListItem200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItem200Response
     */
    'pocket_list_items_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItem200Response
     */
    'pocket_list_items_mst': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItem200Response
     */
    'pocket_list_items_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItem200Response
     */
    'pocket_list_items_event': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItem200Response
     */
    'pocket_list_items_rewilding': string;
}
/**
 * 
 * @export
 * @interface GetPocketListItems200ResponseInner
 */
export interface GetPocketListItems200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_mst'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_rewilding'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_created_at'?: string;
    /**
     * 
     * @type {GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail}
     * @memberof GetPocketListItems200ResponseInner
     */
    'pocket_list_items_rewilding_detail'?: GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail;
}
/**
 * 
 * @export
 * @interface GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
 */
export interface GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail {
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_location': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_country_code': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_achievement_type': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_achievement_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_name': string;
    /**
     * 
     * @type {number}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_rating': number;
    /**
     * 
     * @type {number}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_lat': number;
    /**
     * 
     * @type {number}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_lng': number;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_place_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_elevation': number;
    /**
     * 
     * @type {Array<GetRewilds200ResponseInnerRewildingPhotosInner>}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_photos': Array<GetRewilds200ResponseInnerRewildingPhotosInner>;
    /**
     * 
     * @type {Null}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_reference_links': Null;
    /**
     * 
     * @type {boolean}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_apply_official': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail
     */
    'rewilding_created_at': string;
}
/**
 * 
 * @export
 * @interface GetPolaroids200ResponseInner
 */
export interface GetPolaroids200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_event': string;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_url': string;
    /**
     * 
     * @type {number}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_lat': number;
    /**
     * 
     * @type {number}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_lng': number;
    /**
     * 
     * @type {number}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_radius_from_event': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_achievement_eligible': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_message': string;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_tag': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_is_event_period': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_star_type': number;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_created_at': string;
    /**
     * 
     * @type {GetRewilds200ResponseInnerRewildingCreatedByUser}
     * @memberof GetPolaroids200ResponseInner
     */
    'event_polaroids_created_by_user': GetRewilds200ResponseInnerRewildingCreatedByUser;
}
/**
 * 
 * @export
 * @interface GetRecommendedFriendsForUser200ResponseInner
 */
export interface GetRecommendedFriendsForUser200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_user_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_user_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_is_official'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'rewilding_activity_status'?: number;
    /**
     * 
     * @type {GetOtherUserFriends200ResponseInnerUserFriendsDetail}
     * @memberof GetRecommendedFriendsForUser200ResponseInner
     */
    'user_friends_detail'?: GetOtherUserFriends200ResponseInnerUserFriendsDetail;
}
/**
 * 
 * @export
 * @interface GetRewild200Response
 */
export interface GetRewild200Response {
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRewild200Response
     */
    'rewilding_location': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_country_code': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_achievement_type': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_achievement_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_name': string;
    /**
     * 
     * @type {number}
     * @memberof GetRewild200Response
     */
    'rewilding_rating': number;
    /**
     * 
     * @type {number}
     * @memberof GetRewild200Response
     */
    'rewilding_lat': number;
    /**
     * 
     * @type {number}
     * @memberof GetRewild200Response
     */
    'rewilding_lng': number;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_place_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetRewild200Response
     */
    'rewilding_elevation': number;
    /**
     * 
     * @type {Array<GetRewild200ResponseRewildingPhotosInner>}
     * @memberof GetRewild200Response
     */
    'rewilding_photos': Array<GetRewild200ResponseRewildingPhotosInner>;
    /**
     * 
     * @type {Array<GetRewild200ResponseRewildingReferenceLinksInner>}
     * @memberof GetRewild200Response
     */
    'rewilding_reference_links': Array<GetRewild200ResponseRewildingReferenceLinksInner>;
    /**
     * 
     * @type {boolean}
     * @memberof GetRewild200Response
     */
    'rewilding_apply_official': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200Response
     */
    'rewilding_created_at': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetRewild200Response
     */
    'rewilding_isbookmarked': boolean;
}
/**
 * 
 * @export
 * @interface GetRewild200ResponseRewildingPhotosInner
 */
export interface GetRewild200ResponseRewildingPhotosInner {
    /**
     * 
     * @type {string}
     * @memberof GetRewild200ResponseRewildingPhotosInner
     */
    'rewilding_photos_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200ResponseRewildingPhotosInner
     */
    'rewilding_photos_path'?: string;
}
/**
 * 
 * @export
 * @interface GetRewild200ResponseRewildingReferenceLinksInner
 */
export interface GetRewild200ResponseRewildingReferenceLinksInner {
    /**
     * 
     * @type {string}
     * @memberof GetRewild200ResponseRewildingReferenceLinksInner
     */
    'rewilding_reference_links_link': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewild200ResponseRewildingReferenceLinksInner
     */
    'rewilding_reference_links_title': string;
}
/**
 * 
 * @export
 * @interface GetRewilds200ResponseInner
 */
export interface GetRewilds200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_area': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_location': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_country_code': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_achievement_type': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_achievement_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_name': string;
    /**
     * 
     * @type {number}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_rating': number;
    /**
     * 
     * @type {number}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_lat': number;
    /**
     * 
     * @type {number}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_lng': number;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_place_id': string;
    /**
     * 
     * @type {number}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_elevation': number;
    /**
     * 
     * @type {Array<GetRewilds200ResponseInnerRewildingPhotosInner>}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_photos': Array<GetRewilds200ResponseInnerRewildingPhotosInner>;
    /**
     * 
     * @type {Array<GetRewilds200ResponseInnerRewildingReferenceLinksInner>}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_reference_links': Array<GetRewilds200ResponseInnerRewildingReferenceLinksInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_apply_official': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_created_by': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_created_at': string;
    /**
     * 
     * @type {GetRewilds200ResponseInnerRewildingCreatedByUser}
     * @memberof GetRewilds200ResponseInner
     */
    'rewilding_created_by_user': GetRewilds200ResponseInnerRewildingCreatedByUser;
}
/**
 * 
 * @export
 * @interface GetRewilds200ResponseInnerRewildingCreatedByUser
 */
export interface GetRewilds200ResponseInnerRewildingCreatedByUser {
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingCreatedByUser
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingCreatedByUser
     */
    'user_name': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingCreatedByUser
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingCreatedByUser
     */
    'user_avatar': string;
}
/**
 * 
 * @export
 * @interface GetRewilds200ResponseInnerRewildingPhotosInner
 */
export interface GetRewilds200ResponseInnerRewildingPhotosInner {
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingPhotosInner
     */
    'rewilding_photos_id': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingPhotosInner
     */
    'rewilding_photos_path': string;
}
/**
 * 
 * @export
 * @interface GetRewilds200ResponseInnerRewildingReferenceLinksInner
 */
export interface GetRewilds200ResponseInnerRewildingReferenceLinksInner {
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_link': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_title': string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_og_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_og_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_og_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRewilds200ResponseInnerRewildingReferenceLinksInner
     */
    'rewilding_reference_links_og_site_name'?: string;
}
/**
 * 
 * @export
 * @interface GetUserStat200Response
 */
export interface GetUserStat200Response {
    /**
     * 
     * @type {Array<GetUserStat200ResponseOosaStarCurrentUserInner>}
     * @memberof GetUserStat200Response
     */
    'oosa_star_current_user': Array<GetUserStat200ResponseOosaStarCurrentUserInner>;
    /**
     * 
     * @type {Array<GetUserStat200ResponseOosaStarPerUserInner>}
     * @memberof GetUserStat200Response
     */
    'oosa_star_per_user': Array<GetUserStat200ResponseOosaStarPerUserInner>;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200Response
     */
    'stars_last_achieved_month': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200Response
     */
    'stars_months_last_achieved': number;
    /**
     * 
     * @type {Array<GetUserStat200ResponseUserStarByTypeInner>}
     * @memberof GetUserStat200Response
     */
    'user_star_by_type': Array<GetUserStat200ResponseUserStarByTypeInner>;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200Response
     */
    'user_star_per_year': number;
}
/**
 * 
 * @export
 * @interface GetUserStat200ResponseOosaStarCurrentUserInner
 */
export interface GetUserStat200ResponseOosaStarCurrentUserInner {
    /**
     * 
     * @type {GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod}
     * @memberof GetUserStat200ResponseOosaStarCurrentUserInner
     */
    'event_period': GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarCurrentUserInner
     */
    'event_count': number;
}
/**
 * 
 * @export
 * @interface GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod
 */
export interface GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod {
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod
     */
    'month': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod
     */
    'year': number;
}
/**
 * 
 * @export
 * @interface GetUserStat200ResponseOosaStarPerUserInner
 */
export interface GetUserStat200ResponseOosaStarPerUserInner {
    /**
     * 
     * @type {GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod}
     * @memberof GetUserStat200ResponseOosaStarPerUserInner
     */
    'user_period': GetUserStat200ResponseOosaStarCurrentUserInnerEventPeriod;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarPerUserInner
     */
    'user_count': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarPerUserInner
     */
    'total_star': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseOosaStarPerUserInner
     */
    'average_star': number;
}
/**
 * 
 * @export
 * @interface GetUserStat200ResponseUserStarByTypeInner
 */
export interface GetUserStat200ResponseUserStarByTypeInner {
    /**
     * 
     * @type {string}
     * @memberof GetUserStat200ResponseUserStarByTypeInner
     */
    'event_type': string;
    /**
     * 
     * @type {string}
     * @memberof GetUserStat200ResponseUserStarByTypeInner
     */
    'event_type_name': string;
    /**
     * 
     * @type {number}
     * @memberof GetUserStat200ResponseUserStarByTypeInner
     */
    'event_count': number;
}
/**
 * 
 * @export
 * @interface GetUserWorldStat200Response
 */
export interface GetUserWorldStat200Response {
    /**
     * 
     * @type {Array<GetUserWorldStat200ResponseWorldRewildingCountryInner>}
     * @memberof GetUserWorldStat200Response
     */
    'world_rewilding_country': Array<GetUserWorldStat200ResponseWorldRewildingCountryInner>;
    /**
     * 
     * @type {number}
     * @memberof GetUserWorldStat200Response
     */
    'world_rewilding_members': number;
    /**
     * 
     * @type {number}
     * @memberof GetUserWorldStat200Response
     */
    'world_rewilding_polaroid': number;
}
/**
 * 
 * @export
 * @interface GetUserWorldStat200ResponseWorldRewildingCountryInner
 */
export interface GetUserWorldStat200ResponseWorldRewildingCountryInner {
    /**
     * 
     * @type {string}
     * @memberof GetUserWorldStat200ResponseWorldRewildingCountryInner
     */
    'events_country_code': string;
    /**
     * 
     * @type {number}
     * @memberof GetUserWorldStat200ResponseWorldRewildingCountryInner
     */
    'events_country_count': number;
}
/**
 * An [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) represents a (human) user in Ory.
 * @export
 * @interface Identity
 */
export interface Identity {
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof Identity
     */
    'created_at'?: string;
    /**
     * Credentials represents all credentials that can be used for authenticating this identity.
     * @type {{ [key: string]: IdentityCredentials; }}
     * @memberof Identity
     */
    'credentials'?: { [key: string]: IdentityCredentials; };
    /**
     * ID is the identity\'s unique identifier.  The Identity ID can not be changed and can not be chosen. This ensures future compatibility and optimization for distributed stores such as CockroachDB.
     * @type {string}
     * @memberof Identity
     */
    'id': string;
    /**
     * NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-
     * @type {Null}
     * @memberof Identity
     */
    'metadata_admin'?: Null;
    /**
     * NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-
     * @type {Null}
     * @memberof Identity
     */
    'metadata_public'?: Null;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'organization_id'?: string | null;
    /**
     * RecoveryAddresses contains all the addresses that can be used to recover an identity.
     * @type {Array<RecoveryIdentityAddress>}
     * @memberof Identity
     */
    'recovery_addresses'?: Array<RecoveryIdentityAddress>;
    /**
     * SchemaID is the ID of the JSON Schema to be used for validating the identity\'s traits.
     * @type {string}
     * @memberof Identity
     */
    'schema_id': string;
    /**
     * SchemaURL is the URL of the endpoint where the identity\'s traits schema can be fetched from.  format: url
     * @type {string}
     * @memberof Identity
     */
    'schema_url': string;
    /**
     * State is the identity\'s state.  This value has currently no effect. active StateActive inactive StateInactive
     * @type {string}
     * @memberof Identity
     */
    'state'?: IdentityStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'state_changed_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Identity
     */
    'traits': string;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof Identity
     */
    'updated_at'?: string;
    /**
     * VerifiableAddresses contains all the addresses that can be verified by the user.
     * @type {Array<VerifiableIdentityAddress>}
     * @memberof Identity
     */
    'verifiable_addresses'?: Array<VerifiableIdentityAddress>;
}

export const IdentityStateEnum = {
    Active: 'active',
    Inactive: 'inactive'
} as const;

export type IdentityStateEnum = typeof IdentityStateEnum[keyof typeof IdentityStateEnum];

/**
 * Credentials represents a specific credential type
 * @export
 * @interface IdentityCredentials
 */
export interface IdentityCredentials {
    /**
     * 
     * @type {object}
     * @memberof IdentityCredentials
     */
    'config'?: object;
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof IdentityCredentials
     */
    'created_at'?: string;
    /**
     * Identifiers represents a list of unique identifiers this credential type matches.
     * @type {Array<string>}
     * @memberof IdentityCredentials
     */
    'identifiers'?: Array<string>;
    /**
     * Type discriminates between different types of credentials. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode
     * @type {string}
     * @memberof IdentityCredentials
     */
    'type'?: IdentityCredentialsTypeEnum;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof IdentityCredentials
     */
    'updated_at'?: string;
    /**
     * Version refers to the version of the credential. Useful when changing the config schema.
     * @type {number}
     * @memberof IdentityCredentials
     */
    'version'?: number;
}

export const IdentityCredentialsTypeEnum = {
    Password: 'password',
    Oidc: 'oidc',
    Totp: 'totp',
    LookupSecret: 'lookup_secret',
    Webauthn: 'webauthn',
    Code: 'code',
    Passkey: 'passkey',
    Profile: 'profile',
    LinkRecovery: 'link_recovery',
    CodeRecovery: 'code_recovery'
} as const;

export type IdentityCredentialsTypeEnum = typeof IdentityCredentialsTypeEnum[keyof typeof IdentityCredentialsTypeEnum];

/**
 * 
 * @export
 * @interface LinkQuery
 */
export interface LinkQuery {
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'Title': string;
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'Description': string;
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'OGTitle': string;
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'OGDescription': string;
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'OGImage': string;
    /**
     * 
     * @type {string}
     * @memberof LinkQuery
     */
    'OGSiteName': string;
}
/**
 * This object represents a login flow. A login flow is initiated at the \"Initiate Login API / Browser Flow\" endpoint by a client.  Once a login flow is completed successfully, a session cookie or session token will be issued.
 * @export
 * @interface LoginFlow
 */
export interface LoginFlow {
    /**
     * The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode
     * @type {string}
     * @memberof LoginFlow
     */
    'active'?: LoginFlowActiveEnum;
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof LoginFlow
     */
    'created_at'?: string;
    /**
     * ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in, a new flow has to be initiated.
     * @type {string}
     * @memberof LoginFlow
     */
    'expires_at': string;
    /**
     * ID represents the flow\'s unique ID. When performing the login flow, this represents the id in the login UI\'s query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>
     * @type {string}
     * @memberof LoginFlow
     */
    'id': string;
    /**
     * IssuedAt is the time (UTC) when the flow started.
     * @type {string}
     * @memberof LoginFlow
     */
    'issued_at': string;
    /**
     * Ory OAuth 2.0 Login Challenge.  This value is set using the `login_challenge` query parameter of the registration and login endpoints. If set will cooperate with Ory OAuth2 and OpenID to act as an OAuth2 server / OpenID Provider.
     * @type {string}
     * @memberof LoginFlow
     */
    'oauth2_login_challenge'?: string;
    /**
     * 
     * @type {object}
     * @memberof LoginFlow
     */
    'oauth2_login_request'?: object;
    /**
     * 
     * @type {object}
     * @memberof LoginFlow
     */
    'organization_id'?: object;
    /**
     * Refresh stores whether this login flow should enforce re-authentication.
     * @type {boolean}
     * @memberof LoginFlow
     */
    'refresh'?: boolean;
    /**
     * RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL\'s path or query for example.
     * @type {string}
     * @memberof LoginFlow
     */
    'request_url': string;
    /**
     * 
     * @type {object}
     * @memberof LoginFlow
     */
    'requested_aal'?: object;
    /**
     * ReturnTo contains the requested return_to URL.
     * @type {string}
     * @memberof LoginFlow
     */
    'return_to'?: string;
    /**
     * SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed. This is only set if the client has requested a session token exchange code, and if the flow is of type \"api\", and only on creating the login flow.
     * @type {string}
     * @memberof LoginFlow
     */
    'session_token_exchange_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow
     */
    'state': string;
    /**
     * TransientPayload is used to pass data from the login to hooks and email templates
     * @type {object}
     * @memberof LoginFlow
     */
    'transient_payload'?: object;
    /**
     * 
     * @type {object}
     * @memberof LoginFlow
     */
    'type': object;
    /**
     * 
     * @type {object}
     * @memberof LoginFlow
     */
    'ui': object;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof LoginFlow
     */
    'updated_at'?: string;
}

export const LoginFlowActiveEnum = {
    Password: 'password',
    Oidc: 'oidc',
    Totp: 'totp',
    LookupSecret: 'lookup_secret',
    Webauthn: 'webauthn',
    Code: 'code',
    Passkey: 'passkey',
    Profile: 'profile',
    LinkRecovery: 'link_recovery',
    CodeRecovery: 'code_recovery'
} as const;

export type LoginFlowActiveEnum = typeof LoginFlowActiveEnum[keyof typeof LoginFlowActiveEnum];

/**
 * This object represents a login flow. A login flow is initiated at the \"Initiate Login API / Browser Flow\" endpoint by a client.  Once a login flow is completed successfully, a session cookie or session token will be issued.
 * @export
 * @interface LoginFlow1
 */
export interface LoginFlow1 {
    /**
     * ID represents the flow\'s unique ID. When performing the login flow, this represents the id in the login UI\'s query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>
     * @type {string}
     * @memberof LoginFlow1
     */
    'id': string;
    /**
     * 
     * @type {Null}
     * @memberof LoginFlow1
     */
    'organization_id': Null;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1
     */
    'type': string;
    /**
     * ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in, a new flow has to be initiated.
     * @type {string}
     * @memberof LoginFlow1
     */
    'expires_at': string;
    /**
     * IssuedAt is the time (UTC) when the flow started.
     * @type {string}
     * @memberof LoginFlow1
     */
    'issued_at': string;
    /**
     * RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL\'s path or query for example.
     * @type {string}
     * @memberof LoginFlow1
     */
    'request_url': string;
    /**
     * ReturnTo contains the requested return_to URL.
     * @type {string}
     * @memberof LoginFlow1
     */
    'return_to': string;
    /**
     * 
     * @type {LoginFlow1Ui}
     * @memberof LoginFlow1
     */
    'ui': LoginFlow1Ui;
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof LoginFlow1
     */
    'created_at': string;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof LoginFlow1
     */
    'updated_at': string;
    /**
     * Refresh stores whether this login flow should enforce re-authentication.
     * @type {boolean}
     * @memberof LoginFlow1
     */
    'refresh': boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1
     */
    'requested_aal': string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface LoginFlow1Ui
 */
export interface LoginFlow1Ui {
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1Ui
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1Ui
     */
    'method'?: string;
    /**
     * 
     * @type {Array<LoginFlow1UiNodesInner>}
     * @memberof LoginFlow1Ui
     */
    'nodes'?: Array<LoginFlow1UiNodesInner>;
}
/**
 * 
 * @export
 * @interface LoginFlow1UiNodesInner
 */
export interface LoginFlow1UiNodesInner {
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInner
     */
    'group'?: string;
    /**
     * 
     * @type {LoginFlow1UiNodesInnerAttributes}
     * @memberof LoginFlow1UiNodesInner
     */
    'attributes'?: LoginFlow1UiNodesInnerAttributes;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginFlow1UiNodesInner
     */
    'messages'?: Array<string>;
    /**
     * 
     * @type {LoginFlow1UiNodesInnerMeta}
     * @memberof LoginFlow1UiNodesInner
     */
    'meta'?: LoginFlow1UiNodesInnerMeta;
}
/**
 * 
 * @export
 * @interface LoginFlow1UiNodesInnerAttributes
 */
export interface LoginFlow1UiNodesInnerAttributes {
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'node_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerAttributes
     */
    'autocomplete'?: string;
}
/**
 * 
 * @export
 * @interface LoginFlow1UiNodesInnerMeta
 */
export interface LoginFlow1UiNodesInnerMeta {
    /**
     * 
     * @type {LoginFlow1UiNodesInnerMetaLabel}
     * @memberof LoginFlow1UiNodesInnerMeta
     */
    'label'?: LoginFlow1UiNodesInnerMetaLabel;
}
/**
 * 
 * @export
 * @interface LoginFlow1UiNodesInnerMetaLabel
 */
export interface LoginFlow1UiNodesInnerMetaLabel {
    /**
     * 
     * @type {number}
     * @memberof LoginFlow1UiNodesInnerMetaLabel
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerMetaLabel
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerMetaLabel
     */
    'type': string;
    /**
     * 
     * @type {LoginFlow1UiNodesInnerMetaLabelContext}
     * @memberof LoginFlow1UiNodesInnerMetaLabel
     */
    'context'?: LoginFlow1UiNodesInnerMetaLabelContext;
}
/**
 * 
 * @export
 * @interface LoginFlow1UiNodesInnerMetaLabelContext
 */
export interface LoginFlow1UiNodesInnerMetaLabelContext {
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerMetaLabelContext
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof LoginFlow1UiNodesInnerMetaLabelContext
     */
    'provider_id': string;
}
/**
 * Logout Flow
 * @export
 * @interface LogoutFlow
 */
export interface LogoutFlow {
    /**
     * LogoutToken can be used to perform logout using AJAX.
     * @type {string}
     * @memberof LogoutFlow
     */
    'logout_token': string;
    /**
     * LogoutURL can be opened in a browser to sign the user out.  format: uri
     * @type {string}
     * @memberof LogoutFlow
     */
    'logout_url': string;
}
/**
 * 
 * @export
 * @interface News
 */
export interface News {
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_id': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_date': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_title': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_content': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof News
     */
    'news_created_by': string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200Response
 */
export interface Oauth2Login200Response {
    /**
     * 
     * @type {Oauth2Login200ResponseSession}
     * @memberof Oauth2Login200Response
     */
    'session': Oauth2Login200ResponseSession;
    /**
     * 
     * @type {Array<Oauth2Login200ResponseContinueWithInner>}
     * @memberof Oauth2Login200Response
     */
    'continue_with': Array<Oauth2Login200ResponseContinueWithInner>;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseContinueWithInner
 */
export interface Oauth2Login200ResponseContinueWithInner {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseContinueWithInner
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseContinueWithInner
     */
    'redirect_browser_to'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSession
 */
export interface Oauth2Login200ResponseSession {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSession
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Oauth2Login200ResponseSession
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSession
     */
    'expires_at': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSession
     */
    'authenticated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSession
     */
    'authenticator_assurance_level': string;
    /**
     * 
     * @type {Array<Oauth2Login200ResponseSessionAuthenticationMethodsInner>}
     * @memberof Oauth2Login200ResponseSession
     */
    'authentication_methods': Array<Oauth2Login200ResponseSessionAuthenticationMethodsInner>;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSession
     */
    'issued_at': string;
    /**
     * 
     * @type {Oauth2Login200ResponseSessionIdentity}
     * @memberof Oauth2Login200ResponseSession
     */
    'identity': Oauth2Login200ResponseSessionIdentity;
    /**
     * 
     * @type {Array<Oauth2Login200ResponseSessionDevicesInner>}
     * @memberof Oauth2Login200ResponseSession
     */
    'devices': Array<Oauth2Login200ResponseSessionDevicesInner>;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionAuthenticationMethodsInner
 */
export interface Oauth2Login200ResponseSessionAuthenticationMethodsInner {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionAuthenticationMethodsInner
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionAuthenticationMethodsInner
     */
    'aal'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionAuthenticationMethodsInner
     */
    'completed_at'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionDevicesInner
 */
export interface Oauth2Login200ResponseSessionDevicesInner {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionDevicesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionDevicesInner
     */
    'ip_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionDevicesInner
     */
    'user_agent'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionDevicesInner
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionIdentity
 */
export interface Oauth2Login200ResponseSessionIdentity {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'schema_id': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'schema_url': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'state_changed_at': string;
    /**
     * 
     * @type {Oauth2Login200ResponseSessionIdentityTraits}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'traits': Oauth2Login200ResponseSessionIdentityTraits;
    /**
     * 
     * @type {Array<Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner>}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'verifiable_addresses': Array<Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner>;
    /**
     * 
     * @type {Array<Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner>}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'recovery_addresses': Array<Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner>;
    /**
     * 
     * @type {Null}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'metadata_public': Null;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'updated_at': string;
    /**
     * 
     * @type {Null}
     * @memberof Oauth2Login200ResponseSessionIdentity
     */
    'organization_id': Null;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
 */
export interface Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
     */
    'via'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityRecoveryAddressesInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionIdentityTraits
 */
export interface Oauth2Login200ResponseSessionIdentityTraits {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityTraits
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityTraits
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityTraits
     */
    'picture': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityTraits
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityTraits
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
 */
export interface Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'via'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2Login200ResponseSessionIdentityVerifiableAddressesInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login422Response
 */
export interface Oauth2Login422Response {
    /**
     * 
     * @type {Oauth2Login422ResponseError}
     * @memberof Oauth2Login422Response
     */
    'error': Oauth2Login422ResponseError;
    /**
     * Points to where to redirect the user to next.
     * @type {string}
     * @memberof Oauth2Login422Response
     */
    'redirect_browser_to'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2Login422ResponseError
 */
export interface Oauth2Login422ResponseError {
    /**
     * The status code
     * @type {number}
     * @memberof Oauth2Login422ResponseError
     */
    'code'?: number;
    /**
     * Debug information  This field is often not exposed to protect against leaking sensitive information.
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'debug'?: string;
    /**
     * Further error details
     * @type {object}
     * @memberof Oauth2Login422ResponseError
     */
    'details'?: object;
    /**
     * The error ID  Useful when trying to identify various errors in application logic.
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'id'?: string;
    /**
     * Error message  The error\'s message.
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'message': string;
    /**
     * A human-readable reason for the error
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'reason'?: string;
    /**
     * The request ID  The request ID is often exposed internally in order to trace errors across service architectures. This is often a UUID.
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'request'?: string;
    /**
     * The status description
     * @type {string}
     * @memberof Oauth2Login422ResponseError
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface Oauth2LoginRequest
 */
export interface Oauth2LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof Oauth2LoginRequest
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2LoginRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2LoginRequest
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2LoginRequest
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2LoginRequest
     */
    'csrf_token'?: string;
}
/**
 * 
 * @export
 * @interface PocketList
 */
export interface PocketList {
    /**
     * 
     * @type {number}
     * @memberof PocketList
     */
    'pocket_lists_count': number;
    /**
     * 
     * @type {string}
     * @memberof PocketList
     */
    'pocket_lists_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PocketList
     */
    'pocket_lists_id': string;
    /**
     * 
     * @type {string}
     * @memberof PocketList
     */
    'pocket_lists_name': string;
    /**
     * 
     * @type {string}
     * @memberof PocketList
     */
    'pocket_lists_user': string;
}
/**
 * 
 * @export
 * @interface PocketListItems
 */
export interface PocketListItems {
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_event': string;
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_id': string;
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_mst': string;
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_name': string;
    /**
     * 
     * @type {string}
     * @memberof PocketListItems
     */
    'pocket_list_items_rewilding': string;
    /**
     * 
     * @type {Rewilding}
     * @memberof PocketListItems
     */
    'pocket_list_items_rewilding_detail'?: Rewilding;
}
/**
 * 
 * @export
 * @interface RankingRewilding
 */
export interface RankingRewilding {
    /**
     * 
     * @type {string}
     * @memberof RankingRewilding
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof RankingRewilding
     */
    'rewilding_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RankingRewilding
     */
    'rewilding_type_list': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RankingRewilding
     */
    'rewilding_participants_experience_count': number | null;
}
/**
 * This request is used when an identity wants to recover their account.  We recommend reading the [Account Recovery Documentation](../self-service/flows/password-reset-account-recovery)
 * @export
 * @interface RecoveryFlow
 */
export interface RecoveryFlow {
    /**
     * Active, if set, contains the recovery method that is being used. It is initially not set.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'active'?: string;
    /**
     * Contains possible actions that could follow this flow
     * @type {Array<ContinueWith>}
     * @memberof RecoveryFlow
     */
    'continue_with'?: Array<ContinueWith>;
    /**
     * ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting, a new request has to be initiated.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'expires_at': string;
    /**
     * ID represents the request\'s unique ID. When performing the recovery flow, this represents the id in the recovery ui\'s query parameter: http://<selfservice.flows.recovery.ui_url>?request=<id>
     * @type {string}
     * @memberof RecoveryFlow
     */
    'id': string;
    /**
     * IssuedAt is the time (UTC) when the request occurred.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'issued_at': string;
    /**
     * RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL\'s path or query for example.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'request_url': string;
    /**
     * ReturnTo contains the requested return_to URL.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'return_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecoveryFlow
     */
    'state': string;
    /**
     * TransientPayload is used to pass data from the recovery flow to hooks and email templates
     * @type {object}
     * @memberof RecoveryFlow
     */
    'transient_payload'?: object;
    /**
     * The flow type can either be `api` or `browser`.
     * @type {string}
     * @memberof RecoveryFlow
     */
    'type': string;
    /**
     * 
     * @type {UiContainer}
     * @memberof RecoveryFlow
     */
    'ui': UiContainer;
}
/**
 * 
 * @export
 * @interface RecoveryIdentityAddress
 */
export interface RecoveryIdentityAddress {
    /**
     * CreatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof RecoveryIdentityAddress
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecoveryIdentityAddress
     */
    'id': string;
    /**
     * UpdatedAt is a helper struct field for gobuffalo.pop.
     * @type {string}
     * @memberof RecoveryIdentityAddress
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecoveryIdentityAddress
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof RecoveryIdentityAddress
     */
    'via': string;
}
/**
 * 
 * @export
 * @interface RefRewildingTypes
 */
export interface RefRewildingTypes {
    /**
     * 
     * @type {string}
     * @memberof RefRewildingTypes
     */
    'ref_rewilding_types_google': string;
    /**
     * 
     * @type {string}
     * @memberof RefRewildingTypes
     */
    'ref_rewilding_types_id': string;
    /**
     * 
     * @type {string}
     * @memberof RefRewildingTypes
     */
    'ref_rewilding_types_key': string;
    /**
     * 
     * @type {string}
     * @memberof RefRewildingTypes
     */
    'ref_rewilding_types_name': string;
    /**
     * 
     * @type {string}
     * @memberof RefRewildingTypes
     */
    'ref_rewilding_types_name_en': string;
}
/**
 * 
 * @export
 * @interface RegistrationByEmailFlowRequest
 */
export interface RegistrationByEmailFlowRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'csrf_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'traits.name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'traits.language'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'traits.picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'traits.email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationByEmailFlowRequest
     */
    'traits.username'?: string;
}
/**
 * 
 * @export
 * @interface RequestAuthUpdateAvatar
 */
export interface RequestAuthUpdateAvatar {
    /**
     * 
     * @type {string}
     * @memberof RequestAuthUpdateAvatar
     */
    'users_avatar'?: string;
}
/**
 * 
 * @export
 * @interface RequestAuthUpdateSetting
 */
export interface RequestAuthUpdateSetting {
    /**
     * 
     * @type {number}
     * @memberof RequestAuthUpdateSetting
     */
    'users_setting_friend_auto_add'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestAuthUpdateSetting
     */
    'users_setting_is_visible_friends'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestAuthUpdateSetting
     */
    'users_setting_is_visible_statistics'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestAuthUpdateSetting
     */
    'users_setting_visibility_activity_summary'?: number;
}
/**
 * 
 * @export
 * @interface RequestCollaborativeLogExperience
 */
export interface RequestCollaborativeLogExperience {
    /**
     * \"EXPERIENCE_1\" to \"EXPERIENCE_6\"
     * @type {string}
     * @memberof RequestCollaborativeLogExperience
     */
    'events_experience'?: string;
}
/**
 * 
 * @export
 * @interface RequestCollaborativeLogQuestionnaire
 */
export interface RequestCollaborativeLogQuestionnaire {
    /**
     * 
     * @type {string}
     * @memberof RequestCollaborativeLogQuestionnaire
     */
    'events_questionnaire_link'?: string;
}
/**
 * 
 * @export
 * @interface RequestContactUs
 */
export interface RequestContactUs {
    /**
     * 
     * @type {string}
     * @memberof RequestContactUs
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestContactUs
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RequestEvent
 */
export interface RequestEvent {
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_date': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_date_end': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_deadline': string;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_lat': number;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_lng': number;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_meeting_point_lat': number;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_meeting_point_lng': number;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_meeting_point_name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_name': string;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_participant_limit': number;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_payment_fee': number;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_payment_required': number;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_place': string;
    /**
     * 
     * @type {number}
     * @memberof RequestEvent
     */
    'events_requires_approval': number;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_rewilding': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEvent
     */
    'events_type': string;
}
/**
 * 
 * @export
 * @interface RequestEventAccounting
 */
export interface RequestEventAccounting {
    /**
     * 
     * @type {string}
     * @memberof RequestEventAccounting
     */
    'event_accounting_amount': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventAccounting
     */
    'event_accounting_message': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventAccounting
     */
    'event_accounting_paid_by': string;
}
/**
 * 
 * @export
 * @interface RequestEventAlbumLinks
 */
export interface RequestEventAlbumLinks {
    /**
     * 
     * @type {string}
     * @memberof RequestEventAlbumLinks
     */
    'event_album_link_album_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventAlbumLinks
     */
    'event_album_link_visibility'?: string;
}
/**
 * 
 * @export
 * @interface RequestEventFormData
 */
export interface RequestEventFormData {
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_date_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_deadline'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_lng'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_meeting_point_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_meeting_point_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_participant_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_payment_fee'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_payment_required'?: number;
    /**
     * 
     * @type {File}
     * @memberof RequestEventFormData
     */
    'events_photo'?: File;
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_place'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestEventFormData
     */
    'events_requires_approval'?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestEventFormData
     */
    'events_rewilding'?: string;
}
/**
 * 
 * @export
 * @interface RequestEventInvitation
 */
export interface RequestEventInvitation {
    /**
     * 
     * @type {number}
     * @memberof RequestEventInvitation
     */
    'events_invitation_is_accept'?: number;
}
/**
 * 
 * @export
 * @interface RequestEventInvitationMessageUpdate
 */
export interface RequestEventInvitationMessageUpdate {
    /**
     * 
     * @type {string}
     * @memberof RequestEventInvitationMessageUpdate
     */
    'events_invitation_message': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventInvitationMessageUpdate
     */
    'events_invitation_template': string;
}
/**
 * 
 * @export
 * @interface RequestEventInvitationUpdate
 */
export interface RequestEventInvitationUpdate {
    /**
     * 1: Accept, 2: Rejected
     * @type {number}
     * @memberof RequestEventInvitationUpdate
     */
    'event_participants_status'?: number;
}
/**
 * 
 * @export
 * @interface RequestEventJoin
 */
export interface RequestEventJoin {
    /**
     * 
     * @type {string}
     * @memberof RequestEventJoin
     */
    'event_participants_request_message'?: string;
}
/**
 * 
 * @export
 * @interface RequestEventMessageBoard
 */
export interface RequestEventMessageBoard {
    /**
     * 
     * @type {string}
     * @memberof RequestEventMessageBoard
     */
    'event_message_board_base_message': string;
    /**
     * 
     * @type {number}
     * @memberof RequestEventMessageBoard
     */
    'event_message_board_is_pinned'?: number;
}
/**
 * 
 * @export
 * @interface RequestEventMessageBoardPin
 */
export interface RequestEventMessageBoardPin {
    /**
     * 
     * @type {string}
     * @memberof RequestEventMessageBoardPin
     */
    'event_message_board_category'?: string;
}
/**
 * 
 * @export
 * @interface RequestEventParticipant
 */
export interface RequestEventParticipant {
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestEventParticipant
     */
    'event_participants_user'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RequestEventReferenceLinks
 */
export interface RequestEventReferenceLinks {
    /**
     * 
     * @type {string}
     * @memberof RequestEventReferenceLinks
     */
    'event_reference_links_link': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventReferenceLinks
     */
    'event_reference_links_title': string;
}
/**
 * 
 * @export
 * @interface RequestEventSchedules
 */
export interface RequestEventSchedules {
    /**
     * 
     * @type {string}
     * @memberof RequestEventSchedules
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestEventSchedules
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface RequestEventSchedulesBulk
 */
export interface RequestEventSchedulesBulk {
    /**
     * 
     * @type {Array<RequestEventSchedules>}
     * @memberof RequestEventSchedulesBulk
     */
    'schedule'?: Array<RequestEventSchedules>;
}
/**
 * 
 * @export
 * @interface RequestForgetPassword
 */
export interface RequestForgetPassword {
    /**
     * 
     * @type {string}
     * @memberof RequestForgetPassword
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface RequestForgetPasswordReset
 */
export interface RequestForgetPasswordReset {
    /**
     * 
     * @type {string}
     * @memberof RequestForgetPasswordReset
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestForgetPasswordReset
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface RequestGoogleAuth
 */
export interface RequestGoogleAuth {
    /**
     * 
     * @type {string}
     * @memberof RequestGoogleAuth
     */
    'credential'?: string;
}
/**
 * 
 * @export
 * @interface RequestLinkQuery
 */
export interface RequestLinkQuery {
    /**
     * 
     * @type {string}
     * @memberof RequestLinkQuery
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RequestNews
 */
export interface RequestNews {
    /**
     * 
     * @type {string}
     * @memberof RequestNews
     */
    'news_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestNews
     */
    'news_title': string;
    /**
     * 
     * @type {string}
     * @memberof RequestNews
     */
    'news_content': string;
}
/**
 * 
 * @export
 * @interface RequestPocketList
 */
export interface RequestPocketList {
    /**
     * 
     * @type {string}
     * @memberof RequestPocketList
     */
    'pocket_lists_name'?: string;
}
/**
 * 
 * @export
 * @interface RequestPocketListItem
 */
export interface RequestPocketListItem {
    /**
     * PLACE_ID for Google
     * @type {string}
     * @memberof RequestPocketListItem
     */
    'pocket_list_items_place_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestPocketListItem
     */
    'pocket_list_items_place_name'?: string;
    /**
     * Pass RewildingID if this is adding Rewild spot
     * @type {string}
     * @memberof RequestPocketListItem
     */
    'pocket_list_items_rewilding_id'?: string;
}
/**
 * 
 * @export
 * @interface RequestPocketListUpdate
 */
export interface RequestPocketListUpdate {
    /**
     * 
     * @type {string}
     * @memberof RequestPocketListUpdate
     */
    'pocket_list_items_mst'?: string;
}
/**
 * 
 * @export
 * @interface RequestPocketListUpdateBulk
 */
export interface RequestPocketListUpdateBulk {
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestPocketListUpdateBulk
     */
    'pocket_list_items_id': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RequestPocketListUpdateBulk
     */
    'pocket_list_items_mst': string;
}
/**
 * 
 * @export
 * @interface RequestRewildingCreate
 */
export interface RequestRewildingCreate {
    /**
     * 
     * @type {boolean}
     * @memberof RequestRewildingCreate
     */
    'rewilding_apply_official'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RequestRewildingCreate
     */
    'rewilding_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestRewildingCreate
     */
    'rewilding_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof RequestRewildingCreate
     */
    'rewilding_name'?: string;
    /**
     * 
     * @type {File}
     * @memberof RequestRewildingCreate
     */
    'rewilding_photo[]'?: File;
    /**
     * 
     * @type {string}
     * @memberof RequestRewildingCreate
     */
    'rewilding_pocket_list'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRewildingCreate
     */
    'rewilding_reference_information'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRewildingCreate
     */
    'rewilding_type'?: string;
}
/**
 * 
 * @export
 * @interface RequestUserFollowing
 */
export interface RequestUserFollowing {
    /**
     * 
     * @type {string}
     * @memberof RequestUserFollowing
     */
    'user_followings_following'?: string;
}
/**
 * 
 * @export
 * @interface RequestUserFriend
 */
export interface RequestUserFriend {
    /**
     * 對方用戶的 uuid
     * @type {string}
     * @memberof RequestUserFriend
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface RequestUserLoginEmail
 */
export interface RequestUserLoginEmail {
    /**
     * 
     * @type {string}
     * @memberof RequestUserLoginEmail
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUserLoginEmail
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface RequestUserPreference
 */
export interface RequestUserPreference {
    /**
     * 
     * @type {string}
     * @memberof RequestUserPreference
     */
    'users_setting_language'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestUserPreference
     */
    'users_setting_vis_achievement_collab_log'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestUserPreference
     */
    'users_setting_vis_achievement_journal'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestUserPreference
     */
    'users_setting_vis_follow'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestUserPreference
     */
    'users_vis_events'?: number;
}
/**
 * 
 * @export
 * @interface RequestUserRegisterEmail
 */
export interface RequestUserRegisterEmail {
    /**
     * 
     * @type {string}
     * @memberof RequestUserRegisterEmail
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestUserRegisterEmail
     */
    'is_business'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestUserRegisterEmail
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestUserRegisterEmail
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface RequestUsersUpdate
 */
export interface RequestUsersUpdate {
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_avatar': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof RequestUsersUpdate
     */
    'users_is_business': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RequestUsersUpdate
     */
    'users_is_subscribed': boolean;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_name': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_object': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_password'?: string;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_setting_friend_auto_add': number;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_setting_is_visible_friends': number;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_setting_is_visible_statistics': number;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_setting_language': string;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_setting_visibility_activity_summary': number;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_source': number;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_source_id': string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdate
     */
    'users_username': string;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_breathing_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_following_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestUsersUpdate
     */
    'users_follower_count'?: number;
}
/**
 * 
 * @export
 * @interface RequestUsersUpdatePassword
 */
export interface RequestUsersUpdatePassword {
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdatePassword
     */
    'new_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestUsersUpdatePassword
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ResponseGeneralError
 */
export interface ResponseGeneralError {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeneralError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ResponseGeneralSuccess
 */
export interface ResponseGeneralSuccess {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeneralSuccess
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ResponseValidationError
 */
export interface ResponseValidationError {
    /**
     * 
     * @type {string}
     * @memberof ResponseValidationError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RewildAutoComplete200ResponseInner
 */
export interface RewildAutoComplete200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof RewildAutoComplete200ResponseInner
     */
    'place_id': string;
    /**
     * 
     * @type {string}
     * @memberof RewildAutoComplete200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RewildAutoComplete200ResponseInner
     */
    'location': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RewildAutoComplete200ResponseInner
     */
    'type': Array<string>;
}
/**
 * 
 * @export
 * @interface RewildSearchText200ResponseInner
 */
export interface RewildSearchText200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_area'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_location'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_country_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_achievement_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_achievement_type_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_rating'?: number;
    /**
     * 
     * @type {number}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_place_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_elevation'?: number;
    /**
     * 
     * @type {Array<GetRewilds200ResponseInnerRewildingPhotosInner>}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_photos'?: Array<GetRewilds200ResponseInnerRewildingPhotosInner>;
    /**
     * 
     * @type {Null}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_reference_links'?: Null;
    /**
     * 
     * @type {boolean}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_apply_official'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildSearchText200ResponseInner
     */
    'rewilding_created_at'?: string;
}
/**
 * 
 * @export
 * @interface Rewilding
 */
export interface Rewilding {
    /**
     * 
     * @type {boolean}
     * @memberof Rewilding
     */
    'rewilding_apply_official': boolean;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_area': string;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_city': string;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_created_by': string;
    /**
     * 
     * @type {number}
     * @memberof Rewilding
     */
    'rewilding_elevation': number;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_id': string;
    /**
     * 
     * @type {number}
     * @memberof Rewilding
     */
    'rewilding_lat': number;
    /**
     * 
     * @type {number}
     * @memberof Rewilding
     */
    'rewilding_lng': number;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_name': string;
    /**
     * 
     * @type {Array<RewildingPhotos>}
     * @memberof Rewilding
     */
    'rewilding_photos': Array<RewildingPhotos> | null;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_place_id': string;
    /**
     * 
     * @type {number}
     * @memberof Rewilding
     */
    'rewilding_rating': number;
    /**
     * 
     * @type {string}
     * @memberof Rewilding
     */
    'rewilding_country_code'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Rewilding
     */
    'rewilding_location': Array<string>;
    /**
     * 
     * @type {Array<RewildingReferenceLinks>}
     * @memberof Rewilding
     */
    'rewilding_reference_links'?: Array<RewildingReferenceLinks> | null;
}
/**
 * 
 * @export
 * @interface RewildingApply
 */
export interface RewildingApply {
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_area'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_city'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewildingApply
     */
    'rewilding_apply_lat'?: number;
    /**
     * 
     * @type {number}
     * @memberof RewildingApply
     */
    'rewilding_apply_lng'?: number;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RewildingApply
     */
    'rewilding_apply_rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof RewildingApply
     */
    'rewilding_apply_type'?: string;
}
/**
 * 
 * @export
 * @interface RewildingApplyPhotos
 */
export interface RewildingApplyPhotos {
    /**
     * 
     * @type {string}
     * @memberof RewildingApplyPhotos
     */
    'rewilding_apply_photos_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApplyPhotos
     */
    'rewilding_apply_photos_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingApplyPhotos
     */
    'rewilding_apply_photos_rewilding_apply'?: string;
}
/**
 * 
 * @export
 * @interface RewildingDetail
 */
export interface RewildingDetail {
    /**
     * 
     * @type {string}
     * @memberof RewildingDetail
     */
    'rewilding_id': string;
    /**
     * 
     * @type {string}
     * @memberof RewildingDetail
     */
    'rewilding_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RewildingDetail
     */
    'rewilding_location': Array<string>;
}
/**
 * 
 * @export
 * @interface RewildingOptions
 */
export interface RewildingOptions {
    /**
     * 
     * @type {Array<RefRewildingTypes>}
     * @memberof RewildingOptions
     */
    'rewilding_types'?: Array<RefRewildingTypes>;
}
/**
 * 
 * @export
 * @interface RewildingPhotos
 */
export interface RewildingPhotos {
    /**
     * 
     * @type {string}
     * @memberof RewildingPhotos
     */
    'rewilding_photos_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingPhotos
     */
    'rewilding_photos_path'?: string;
}
/**
 * 
 * @export
 * @interface RewildingReferenceLinks
 */
export interface RewildingReferenceLinks {
    /**
     * 
     * @type {string}
     * @memberof RewildingReferenceLinks
     */
    'rewilding_reference_links_link': string;
    /**
     * 
     * @type {string}
     * @memberof RewildingReferenceLinks
     */
    'rewilding_reference_links_title'?: string;
}
/**
 * 
 * @export
 * @interface RewildingSearch
 */
export interface RewildingSearch {
    /**
     * 
     * @type {Array<RewildingSearchOne>}
     * @memberof RewildingSearch
     */
    'places': Array<RewildingSearchOne>;
}
/**
 * 
 * @export
 * @interface RewildingSearchOne
 */
export interface RewildingSearchOne {
    /**
     * 
     * @type {string}
     * @memberof RewildingSearchOne
     */
    'formattedAddress': string;
    /**
     * 
     * @type {string}
     * @memberof RewildingSearchOne
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof RewildingSearchOne
     */
    'rating': number;
    /**
     * 
     * @type {number}
     * @memberof RewildingSearchOne
     */
    'userRatingCount': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RewildingSearchOne
     */
    'types': Array<string>;
    /**
     * 
     * @type {RewildingSearchOneDisplayName}
     * @memberof RewildingSearchOne
     */
    'displayName': RewildingSearchOneDisplayName;
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter}
     * @memberof RewildingSearchOne
     */
    'location': V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter;
}
/**
 * 
 * @export
 * @interface RewildingSearchOneDisplayName
 */
export interface RewildingSearchOneDisplayName {
    /**
     * 
     * @type {string}
     * @memberof RewildingSearchOneDisplayName
     */
    'languageCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingSearchOneDisplayName
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface RewildingWiki
 */
export interface RewildingWiki {
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_feelings'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_rewilding'?: string;
    /**
     * 
     * @type {string}
     * @memberof RewildingWiki
     */
    'rewilding_wiki_type'?: string;
}
/**
 * This flow is used when an identity wants to update settings (e.g. profile data, passwords, ...) in a selfservice manner.  We recommend reading the [User Settings Documentation](../self-service/flows/user-settings)
 * @export
 * @interface SettingsFlow
 */
export interface SettingsFlow {
    /**
     * Active, if set, contains the registration method that is being used. It is initially not set.
     * @type {string}
     * @memberof SettingsFlow
     */
    'active'?: string;
    /**
     * Contains a list of actions, that could follow this flow  It can, for example, contain a reference to the verification flow, created as part of the user\'s registration.
     * @type {Array<ContinueWith>}
     * @memberof SettingsFlow
     */
    'continue_with'?: Array<ContinueWith>;
    /**
     * ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting, a new flow has to be initiated.
     * @type {string}
     * @memberof SettingsFlow
     */
    'expires_at': string;
    /**
     * ID represents the flow\'s unique ID. When performing the settings flow, this represents the id in the settings ui\'s query parameter: http://<selfservice.flows.settings.ui_url>?flow=<id>
     * @type {string}
     * @memberof SettingsFlow
     */
    'id': string;
    /**
     * 
     * @type {Identity}
     * @memberof SettingsFlow
     */
    'identity': Identity;
    /**
     * IssuedAt is the time (UTC) when the flow occurred.
     * @type {string}
     * @memberof SettingsFlow
     */
    'issued_at': string;
    /**
     * RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL\'s path or query for example.
     * @type {string}
     * @memberof SettingsFlow
     */
    'request_url': string;
    /**
     * ReturnTo contains the requested return_to URL.
     * @type {string}
     * @memberof SettingsFlow
     */
    'return_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingsFlow
     */
    'state': string;
    /**
     * TransientPayload is used to pass data from the settings flow to hooks and email templates
     * @type {object}
     * @memberof SettingsFlow
     */
    'transient_payload'?: object;
    /**
     * The flow type can either be `api` or `browser`.
     * @type {string}
     * @memberof SettingsFlow
     */
    'type': string;
    /**
     * 
     * @type {UiContainer}
     * @memberof SettingsFlow
     */
    'ui': UiContainer;
}
/**
 * 
 * @export
 * @interface Sharing
 */
export interface Sharing {
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_event'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_event_album_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sharing
     */
    'sharing_platform'?: string;
}
/**
 * Container represents a HTML Form. The container can work with both HTTP Form and JSON requests
 * @export
 * @interface UiContainer
 */
export interface UiContainer {
    /**
     * Action should be used as the form action URL `<form action=\"{{ .Action }}\" method=\"post\">`.
     * @type {string}
     * @memberof UiContainer
     */
    'action': string;
    /**
     * 
     * @type {Array<UiText>}
     * @memberof UiContainer
     */
    'messages'?: Array<UiText>;
    /**
     * Method is the form method (e.g. POST)
     * @type {string}
     * @memberof UiContainer
     */
    'method': string;
    /**
     * 
     * @type {Array<UiNode>}
     * @memberof UiContainer
     */
    'nodes': Array<UiNode>;
}
/**
 * Nodes are represented as HTML elements or their native UI equivalents. For example, a node can be an `<img>` tag, or an `<input element>` but also `some plain text`.
 * @export
 * @interface UiNode
 */
export interface UiNode {
    /**
     * 
     * @type {UiNodeAttributes}
     * @memberof UiNode
     */
    'attributes': UiNodeAttributes;
    /**
     * Group specifies which group (e.g. password authenticator) this node belongs to. default DefaultGroup password PasswordGroup oidc OpenIDConnectGroup profile ProfileGroup link LinkGroup code CodeGroup totp TOTPGroup lookup_secret LookupGroup webauthn WebAuthnGroup passkey PasskeyGroup identifier_first IdentifierFirstGroup
     * @type {string}
     * @memberof UiNode
     */
    'group': UiNodeGroupEnum;
    /**
     * 
     * @type {Array<UiText>}
     * @memberof UiNode
     */
    'messages': Array<UiText>;
    /**
     * 
     * @type {UiNodeMeta}
     * @memberof UiNode
     */
    'meta': UiNodeMeta;
    /**
     * The node\'s type text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNode
     */
    'type': UiNodeTypeEnum;
}

export const UiNodeGroupEnum = {
    Default: 'default',
    Password: 'password',
    Oidc: 'oidc',
    Profile: 'profile',
    Link: 'link',
    Code: 'code',
    Totp: 'totp',
    LookupSecret: 'lookup_secret',
    Webauthn: 'webauthn',
    Passkey: 'passkey',
    IdentifierFirst: 'identifier_first'
} as const;

export type UiNodeGroupEnum = typeof UiNodeGroupEnum[keyof typeof UiNodeGroupEnum];
export const UiNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeTypeEnum = typeof UiNodeTypeEnum[keyof typeof UiNodeTypeEnum];

/**
 * 
 * @export
 * @interface UiNodeAnchorAttributes
 */
export interface UiNodeAnchorAttributes {
    /**
     * The link\'s href (destination) URL.  format: uri
     * @type {string}
     * @memberof UiNodeAnchorAttributes
     */
    'href': string;
    /**
     * A unique identifier
     * @type {string}
     * @memberof UiNodeAnchorAttributes
     */
    'id': string;
    /**
     * NodeType represents this node\'s types. It is a mirror of `node.type` and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"a\". text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNodeAnchorAttributes
     */
    'node_type': UiNodeAnchorAttributesNodeTypeEnum;
    /**
     * 
     * @type {UiText}
     * @memberof UiNodeAnchorAttributes
     */
    'title': UiText;
}

export const UiNodeAnchorAttributesNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeAnchorAttributesNodeTypeEnum = typeof UiNodeAnchorAttributesNodeTypeEnum[keyof typeof UiNodeAnchorAttributesNodeTypeEnum];

/**
 * @type UiNodeAttributes
 * @export
 */
export type UiNodeAttributes = { node_type: 'a' } & UiNodeAnchorAttributes | { node_type: 'img' } & UiNodeImageAttributes | { node_type: 'input' } & UiNodeInputAttributes | { node_type: 'script' } & UiNodeScriptAttributes | { node_type: 'text' } & UiNodeTextAttributes;

/**
 * 
 * @export
 * @interface UiNodeImageAttributes
 */
export interface UiNodeImageAttributes {
    /**
     * Height of the image
     * @type {number}
     * @memberof UiNodeImageAttributes
     */
    'height': number;
    /**
     * A unique identifier
     * @type {string}
     * @memberof UiNodeImageAttributes
     */
    'id': string;
    /**
     * NodeType represents this node\'s types. It is a mirror of `node.type` and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"img\". text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNodeImageAttributes
     */
    'node_type': UiNodeImageAttributesNodeTypeEnum;
    /**
     * The image\'s source URL.  format: uri
     * @type {string}
     * @memberof UiNodeImageAttributes
     */
    'src': string;
    /**
     * Width of the image
     * @type {number}
     * @memberof UiNodeImageAttributes
     */
    'width': number;
}

export const UiNodeImageAttributesNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeImageAttributesNodeTypeEnum = typeof UiNodeImageAttributesNodeTypeEnum[keyof typeof UiNodeImageAttributesNodeTypeEnum];

/**
 * InputAttributes represents the attributes of an input node
 * @export
 * @interface UiNodeInputAttributes
 */
export interface UiNodeInputAttributes {
    /**
     * The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'autocomplete'?: UiNodeInputAttributesAutocompleteEnum;
    /**
     * Sets the input\'s disabled field to true or false.
     * @type {boolean}
     * @memberof UiNodeInputAttributes
     */
    'disabled': boolean;
    /**
     * 
     * @type {UiText}
     * @memberof UiNodeInputAttributes
     */
    'label'?: UiText;
    /**
     * MaxLength may contain the input\'s maximum length.
     * @type {number}
     * @memberof UiNodeInputAttributes
     */
    'maxlength'?: number;
    /**
     * The input\'s element name.
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'name': string;
    /**
     * NodeType represents this node\'s types. It is a mirror of `node.type` and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"input\". text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'node_type': UiNodeInputAttributesNodeTypeEnum;
    /**
     * OnClick may contain javascript which should be executed on click. This is primarily used for WebAuthn.  Deprecated: Using OnClick requires the use of eval() which is a security risk. Use OnClickTrigger instead.
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'onclick'?: string;
    /**
     * OnClickTrigger may contain a WebAuthn trigger which should be executed on click.  The trigger maps to a JavaScript function provided by Ory, which triggers actions such as PassKey registration or login. oryWebAuthnRegistration WebAuthnTriggersWebAuthnRegistration oryWebAuthnLogin WebAuthnTriggersWebAuthnLogin oryPasskeyLogin WebAuthnTriggersPasskeyLogin oryPasskeyLoginAutocompleteInit WebAuthnTriggersPasskeyLoginAutocompleteInit oryPasskeyRegistration WebAuthnTriggersPasskeyRegistration oryPasskeySettingsRegistration WebAuthnTriggersPasskeySettingsRegistration
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'onclickTrigger'?: UiNodeInputAttributesOnclickTriggerEnum;
    /**
     * OnLoad may contain javascript which should be executed on load. This is primarily used for WebAuthn.  Deprecated: Using OnLoad requires the use of eval() which is a security risk. Use OnLoadTrigger instead.
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'onload'?: string;
    /**
     * OnLoadTrigger may contain a WebAuthn trigger which should be executed on load.  The trigger maps to a JavaScript function provided by Ory, which triggers actions such as PassKey registration or login. oryWebAuthnRegistration WebAuthnTriggersWebAuthnRegistration oryWebAuthnLogin WebAuthnTriggersWebAuthnLogin oryPasskeyLogin WebAuthnTriggersPasskeyLogin oryPasskeyLoginAutocompleteInit WebAuthnTriggersPasskeyLoginAutocompleteInit oryPasskeyRegistration WebAuthnTriggersPasskeyRegistration oryPasskeySettingsRegistration WebAuthnTriggersPasskeySettingsRegistration
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'onloadTrigger'?: UiNodeInputAttributesOnloadTriggerEnum;
    /**
     * The input\'s pattern.
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'pattern'?: string;
    /**
     * Mark this input field as required.
     * @type {boolean}
     * @memberof UiNodeInputAttributes
     */
    'required'?: boolean;
    /**
     * The input\'s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI
     * @type {string}
     * @memberof UiNodeInputAttributes
     */
    'type': UiNodeInputAttributesTypeEnum;
    /**
     * The input\'s value.
     * @type {Null}
     * @memberof UiNodeInputAttributes
     */
    'value'?: Null;
}

export const UiNodeInputAttributesAutocompleteEnum = {
    Email: 'email',
    Tel: 'tel',
    Url: 'url',
    CurrentPassword: 'current-password',
    NewPassword: 'new-password',
    OneTimeCode: 'one-time-code'
} as const;

export type UiNodeInputAttributesAutocompleteEnum = typeof UiNodeInputAttributesAutocompleteEnum[keyof typeof UiNodeInputAttributesAutocompleteEnum];
export const UiNodeInputAttributesNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeInputAttributesNodeTypeEnum = typeof UiNodeInputAttributesNodeTypeEnum[keyof typeof UiNodeInputAttributesNodeTypeEnum];
export const UiNodeInputAttributesOnclickTriggerEnum = {
    OryWebAuthnRegistration: 'oryWebAuthnRegistration',
    OryWebAuthnLogin: 'oryWebAuthnLogin',
    OryPasskeyLogin: 'oryPasskeyLogin',
    OryPasskeyLoginAutocompleteInit: 'oryPasskeyLoginAutocompleteInit',
    OryPasskeyRegistration: 'oryPasskeyRegistration',
    OryPasskeySettingsRegistration: 'oryPasskeySettingsRegistration'
} as const;

export type UiNodeInputAttributesOnclickTriggerEnum = typeof UiNodeInputAttributesOnclickTriggerEnum[keyof typeof UiNodeInputAttributesOnclickTriggerEnum];
export const UiNodeInputAttributesOnloadTriggerEnum = {
    OryWebAuthnRegistration: 'oryWebAuthnRegistration',
    OryWebAuthnLogin: 'oryWebAuthnLogin',
    OryPasskeyLogin: 'oryPasskeyLogin',
    OryPasskeyLoginAutocompleteInit: 'oryPasskeyLoginAutocompleteInit',
    OryPasskeyRegistration: 'oryPasskeyRegistration',
    OryPasskeySettingsRegistration: 'oryPasskeySettingsRegistration'
} as const;

export type UiNodeInputAttributesOnloadTriggerEnum = typeof UiNodeInputAttributesOnloadTriggerEnum[keyof typeof UiNodeInputAttributesOnloadTriggerEnum];
export const UiNodeInputAttributesTypeEnum = {
    Text: 'text',
    Password: 'password',
    Number: 'number',
    Checkbox: 'checkbox',
    Hidden: 'hidden',
    Email: 'email',
    Tel: 'tel',
    Submit: 'submit',
    Button: 'button',
    DatetimeLocal: 'datetime-local',
    Date: 'date',
    Url: 'url'
} as const;

export type UiNodeInputAttributesTypeEnum = typeof UiNodeInputAttributesTypeEnum[keyof typeof UiNodeInputAttributesTypeEnum];

/**
 * This might include a label and other information that can optionally be used to render UIs.
 * @export
 * @interface UiNodeMeta
 */
export interface UiNodeMeta {
    /**
     * 
     * @type {UiText}
     * @memberof UiNodeMeta
     */
    'label'?: UiText;
}
/**
 * 
 * @export
 * @interface UiNodeScriptAttributes
 */
export interface UiNodeScriptAttributes {
    /**
     * The script async type
     * @type {boolean}
     * @memberof UiNodeScriptAttributes
     */
    'async': boolean;
    /**
     * The script cross origin policy
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'crossorigin': string;
    /**
     * A unique identifier
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'id': string;
    /**
     * The script\'s integrity hash
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'integrity': string;
    /**
     * NodeType represents this node\'s types. It is a mirror of `node.type` and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \"script\". text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'node_type': UiNodeScriptAttributesNodeTypeEnum;
    /**
     * Nonce for CSP  A nonce you may want to use to improve your Content Security Policy. You do not have to use this value but if you want to improve your CSP policies you may use it. You can also choose to use your own nonce value!
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'nonce': string;
    /**
     * The script referrer policy
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'referrerpolicy': string;
    /**
     * The script source
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'src': string;
    /**
     * The script MIME type
     * @type {string}
     * @memberof UiNodeScriptAttributes
     */
    'type': string;
}

export const UiNodeScriptAttributesNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeScriptAttributesNodeTypeEnum = typeof UiNodeScriptAttributesNodeTypeEnum[keyof typeof UiNodeScriptAttributesNodeTypeEnum];

/**
 * 
 * @export
 * @interface UiNodeTextAttributes
 */
export interface UiNodeTextAttributes {
    /**
     * A unique identifier
     * @type {string}
     * @memberof UiNodeTextAttributes
     */
    'id': string;
    /**
     * NodeType represents this node\'s types. It is a mirror of `node.type` and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"text\". text Text input Input img Image a Anchor script Script
     * @type {string}
     * @memberof UiNodeTextAttributes
     */
    'node_type': UiNodeTextAttributesNodeTypeEnum;
    /**
     * 
     * @type {UiText}
     * @memberof UiNodeTextAttributes
     */
    'text': UiText;
}

export const UiNodeTextAttributesNodeTypeEnum = {
    Text: 'text',
    Input: 'input',
    Img: 'img',
    A: 'a',
    Script: 'script'
} as const;

export type UiNodeTextAttributesNodeTypeEnum = typeof UiNodeTextAttributesNodeTypeEnum[keyof typeof UiNodeTextAttributesNodeTypeEnum];

/**
 * 
 * @export
 * @interface UiText
 */
export interface UiText {
    /**
     * The message\'s context. Useful when customizing messages.
     * @type {object}
     * @memberof UiText
     */
    'context'?: object;
    /**
     * 
     * @type {number}
     * @memberof UiText
     */
    'id': number;
    /**
     * The message text. Written in american english.
     * @type {string}
     * @memberof UiText
     */
    'text': string;
    /**
     * The message type. info Info error Error success Success
     * @type {string}
     * @memberof UiText
     */
    'type': UiTextTypeEnum;
}

export const UiTextTypeEnum = {
    Info: 'info',
    Error: 'error',
    Success: 'success'
} as const;

export type UiTextTypeEnum = typeof UiTextTypeEnum[keyof typeof UiTextTypeEnum];

/**
 * 
 * @export
 * @interface UpdateEvent400Response
 */
export interface UpdateEvent400Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateEvent400Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 1: Take Me, 0: Don\'t take me
     * @type {number}
     * @memberof UpdateUserRequest
     */
    'users_take_me_status': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_avatar': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'users_is_business': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'users_is_subscribed': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_object': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_password'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_setting_friend_auto_add': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_setting_is_visible_friends': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_setting_is_visible_statistics': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_setting_language': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_setting_visibility_activity_summary': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_source': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_source_id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'users_username': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_breathing_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_following_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'users_follower_count'?: number;
}
/**
 * 
 * @export
 * @interface UserAgg
 */
export interface UserAgg {
    /**
     * 
     * @type {string}
     * @memberof UserAgg
     */
    'user_avatar': string;
    /**
     * 
     * @type {string}
     * @memberof UserAgg
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof UserAgg
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserAgg
     */
    'user_name': string;
}
/**
 * 
 * @export
 * @interface UserBadges
 */
export interface UserBadges {
    /**
     * 
     * @type {UserBadgesDetail}
     * @memberof UserBadges
     */
    'user_badges_detail'?: UserBadgesDetail;
    /**
     * 
     * @type {string}
     * @memberof UserBadges
     */
    'user_badges_badge'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBadges
     */
    'user_badges_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBadges
     */
    'user_badges_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBadges
     */
    'user_badges_user'?: string;
}
/**
 * 
 * @export
 * @interface UserBadgesDetail
 */
export interface UserBadgesDetail {
    /**
     * 
     * @type {string}
     * @memberof UserBadgesDetail
     */
    'badges_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBadgesDetail
     */
    'badges_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBadgesDetail
     */
    'badges_name'?: string;
}
/**
 * 
 * @export
 * @interface UserFollowings
 */
export interface UserFollowings {
    /**
     * 
     * @type {string}
     * @memberof UserFollowings
     */
    'user_followings_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFollowings
     */
    'user_followings_following'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFollowings
     */
    'user_followings_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFollowings
     */
    'user_followings_user'?: string;
}
/**
 * @type UserFriendsInner
 * @export
 */
export type UserFriendsInner = UserFriendsOne;

/**
 * 
 * @export
 * @interface UserFriendsOne
 */
export interface UserFriendsOne {
    /**
     * 
     * @type {string}
     * @memberof UserFriendsOne
     */
    'users_avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFriendsOne
     */
    'users_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFriendsOne
     */
    'users_name'?: string;
}
/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * 
     * @type {User}
     * @memberof UserLogin
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof UserLogin
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UserMilestones
 */
export interface UserMilestones {
    /**
     * 
     * @type {string}
     * @memberof UserMilestones
     */
    'user_milestones_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMilestones
     */
    'user_milestones_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMilestones
     */
    'user_milestones_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMilestones
     */
    'user_milestones_milestone'?: string;
}
/**
 * 
 * @export
 * @interface UserNotifications
 */
export interface UserNotifications {
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_identifier'?: string;
    /**
     * 
     * @type {UserNotificationsNotificationsMessage}
     * @memberof UserNotifications
     */
    'notifications_message'?: UserNotificationsNotificationsMessage;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_state'?: UserNotificationsNotificationsStateEnum;
    /**
     * 
     * @type {string}
     * @memberof UserNotifications
     */
    'notifications_user'?: string;
}

export const UserNotificationsNotificationsStateEnum = {
    New: 'new',
    Done: 'done'
} as const;

export type UserNotificationsNotificationsStateEnum = typeof UserNotificationsNotificationsStateEnum[keyof typeof UserNotificationsNotificationsStateEnum];

/**
 * 
 * @export
 * @interface UserNotificationsNotificationsMessage
 */
export interface UserNotificationsNotificationsMessage {
    /**
     * message
     * @type {string}
     * @memberof UserNotificationsNotificationsMessage
     */
    'message': string;
    /**
     * 
     * @type {Array<UserNotificationsNotificationsMessageDataInner>}
     * @memberof UserNotificationsNotificationsMessage
     */
    'data': Array<UserNotificationsNotificationsMessageDataInner>;
}
/**
 * 
 * @export
 * @interface UserNotificationsNotificationsMessageDataInner
 */
export interface UserNotificationsNotificationsMessageDataInner {
    /**
     * 
     * @type {string}
     * @memberof UserNotificationsNotificationsMessageDataInner
     */
    'badges_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotificationsNotificationsMessageDataInner
     */
    'badges_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotificationsNotificationsMessageDataInner
     */
    'badges_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotificationsNotificationsMessageDataInner
     */
    'users_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotificationsNotificationsMessageDataInner
     */
    'users_name'?: string;
}
/**
 * 
 * @export
 * @interface UserOther
 */
export interface UserOther {
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_avatar': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_created_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOther
     */
    'users_is_business': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserOther
     */
    'users_is_subscribed': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_object': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_password'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_setting_friend_auto_add': number;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_setting_is_visible_friends': number;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_setting_is_visible_statistics': number;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_setting_language': string;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_setting_visibility_activity_summary': number;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_source': number;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_source_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOther
     */
    'users_username': string;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_breathing_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_following_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserOther
     */
    'users_follower_count'?: number;
    /**
     * 
     * @type {UserFollowings}
     * @memberof UserOther
     */
    'users_followings': UserFollowings;
}
/**
 * 
 * @export
 * @interface UserStarStatistics
 */
export interface UserStarStatistics {
    /**
     * 
     * @type {EventStatisticsId}
     * @memberof UserStarStatistics
     */
    'user_period': EventStatisticsId;
    /**
     * 
     * @type {number}
     * @memberof UserStarStatistics
     */
    'user_count': number;
    /**
     * 
     * @type {number}
     * @memberof UserStarStatistics
     */
    'total_star': number;
    /**
     * 
     * @type {number}
     * @memberof UserStarStatistics
     */
    'average_star': number;
}
/**
 * 
 * @export
 * @interface V1PlacesAutocompletePostRequest
 */
export interface V1PlacesAutocompletePostRequest {
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestriction}
     * @memberof V1PlacesAutocompletePostRequest
     */
    'locationRestriction': V1PlacesSearchNearbyPostRequestLocationRestriction;
    /**
     * 
     * @type {string}
     * @memberof V1PlacesAutocompletePostRequest
     */
    'languageCode': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1PlacesAutocompletePostRequest
     */
    'includedPrimaryTypes': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1PlacesAutocompletePostRequest
     */
    'input': string;
}
/**
 * 
 * @export
 * @interface V1PlacesSearchNearbyPostRequest
 */
export interface V1PlacesSearchNearbyPostRequest {
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestriction}
     * @memberof V1PlacesSearchNearbyPostRequest
     */
    'locationRestriction': V1PlacesSearchNearbyPostRequestLocationRestriction;
    /**
     * 
     * @type {number}
     * @memberof V1PlacesSearchNearbyPostRequest
     */
    'maxResultCount': number;
    /**
     * 
     * @type {string}
     * @memberof V1PlacesSearchNearbyPostRequest
     */
    'languageCode': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1PlacesSearchNearbyPostRequest
     */
    'includedTypes': Array<V1PlacesSearchNearbyPostRequestIncludedTypesEnum>;
}

export const V1PlacesSearchNearbyPostRequestIncludedTypesEnum = {
    HikingArea: 'hiking_area',
    TouristAttraction: 'tourist_attraction',
    Park: 'park',
    Playground: 'playground',
    Campground: 'campground',
    CampingCabin: 'camping_cabin',
    NationalPark: 'national_park'
} as const;

export type V1PlacesSearchNearbyPostRequestIncludedTypesEnum = typeof V1PlacesSearchNearbyPostRequestIncludedTypesEnum[keyof typeof V1PlacesSearchNearbyPostRequestIncludedTypesEnum];

/**
 * 
 * @export
 * @interface V1PlacesSearchNearbyPostRequestLocationRestriction
 */
export interface V1PlacesSearchNearbyPostRequestLocationRestriction {
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestrictionCircle}
     * @memberof V1PlacesSearchNearbyPostRequestLocationRestriction
     */
    'circle': V1PlacesSearchNearbyPostRequestLocationRestrictionCircle;
}
/**
 * 
 * @export
 * @interface V1PlacesSearchNearbyPostRequestLocationRestrictionCircle
 */
export interface V1PlacesSearchNearbyPostRequestLocationRestrictionCircle {
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter}
     * @memberof V1PlacesSearchNearbyPostRequestLocationRestrictionCircle
     */
    'center': V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter;
    /**
     * 
     * @type {number}
     * @memberof V1PlacesSearchNearbyPostRequestLocationRestrictionCircle
     */
    'radius': number;
}
/**
 * 
 * @export
 * @interface V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter
 */
export interface V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter {
    /**
     * 
     * @type {number}
     * @memberof V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof V1PlacesSearchNearbyPostRequestLocationRestrictionCircleCenter
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface V1PlacesSearchTextPostRequest
 */
export interface V1PlacesSearchTextPostRequest {
    /**
     * 
     * @type {V1PlacesSearchNearbyPostRequestLocationRestriction}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'locationBias': V1PlacesSearchNearbyPostRequestLocationRestriction;
    /**
     * 
     * @type {number}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'pageSize': number;
    /**
     * 
     * @type {string}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'languageCode': string;
    /**
     * hiking_area
     * @type {string}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'includedType'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'textQuery': string;
    /**
     * 
     * @type {boolean}
     * @memberof V1PlacesSearchTextPostRequest
     */
    'strictTypeFiltering'?: boolean;
}
/**
 * VerifiableAddress is an identity\'s verifiable address
 * @export
 * @interface VerifiableIdentityAddress
 */
export interface VerifiableIdentityAddress {
    /**
     * When this entry was created
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'created_at'?: string;
    /**
     * The ID
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'id'?: string;
    /**
     * VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'status': string;
    /**
     * When this entry was last updated
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'updated_at'?: string;
    /**
     * The address value  example foo@user.com
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'value': string;
    /**
     * Indicates if the address has already been verified
     * @type {boolean}
     * @memberof VerifiableIdentityAddress
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'verified_at'?: string;
    /**
     * The delivery method
     * @type {string}
     * @memberof VerifiableIdentityAddress
     */
    'via': VerifiableIdentityAddressViaEnum;
}

export const VerifiableIdentityAddressViaEnum = {
    Email: 'email',
    Sms: 'sms'
} as const;

export type VerifiableIdentityAddressViaEnum = typeof VerifiableIdentityAddressViaEnum[keyof typeof VerifiableIdentityAddressViaEnum];

/**
 * Used to verify an out-of-band communication channel such as an email address or a phone number.  For more information head over to: https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation
 * @export
 * @interface VerificationFlow
 */
export interface VerificationFlow {
    /**
     * Active, if set, contains the registration method that is being used. It is initially not set.
     * @type {string}
     * @memberof VerificationFlow
     */
    'active'?: string;
    /**
     * ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address, a new request has to be initiated.
     * @type {string}
     * @memberof VerificationFlow
     */
    'expires_at'?: string;
    /**
     * ID represents the request\'s unique ID. When performing the verification flow, this represents the id in the verify ui\'s query parameter: http://<selfservice.flows.verification.ui_url>?request=<id>  type: string format: uuid
     * @type {string}
     * @memberof VerificationFlow
     */
    'id': string;
    /**
     * IssuedAt is the time (UTC) when the request occurred.
     * @type {string}
     * @memberof VerificationFlow
     */
    'issued_at'?: string;
    /**
     * RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL\'s path or query for example.
     * @type {string}
     * @memberof VerificationFlow
     */
    'request_url'?: string;
    /**
     * ReturnTo contains the requested return_to URL.
     * @type {string}
     * @memberof VerificationFlow
     */
    'return_to'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationFlow
     */
    'state': string;
    /**
     * TransientPayload is used to pass data from the verification flow to hooks and email templates
     * @type {object}
     * @memberof VerificationFlow
     */
    'transient_payload'?: object;
    /**
     * The flow type can either be `api` or `browser`.
     * @type {string}
     * @memberof VerificationFlow
     */
    'type': string;
    /**
     * 
     * @type {UiContainer}
     * @memberof VerificationFlow
     */
    'ui': UiContainer;
}

/**
 * A1Api - axios parameter creator
 * @export
 */
export const A1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * A1Api - functional programming interface
 * @export
 */
export const A1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = A1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['A1Api.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * A1Api - factory interface
 * @export
 */
export const A1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = A1ApiFp(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * A1Api - object-oriented interface
 * @export
 * @class A1Api
 * @extends {BaseAPI}
 */
export class A1Api extends BaseAPI {
    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof A1Api
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return A1ApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * A1aApi - axios parameter creator
 * @export
 */
export const A1aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * A1aApi - functional programming interface
 * @export
 */
export const A1aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = A1aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['A1aApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * A1aApi - factory interface
 * @export
 */
export const A1aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = A1aApiFp(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * A1aApi - object-oriented interface
 * @export
 * @class A1aApi
 * @extends {BaseAPI}
 */
export class A1aApi extends BaseAPI {
    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof A1aApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return A1aApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * A1bApi - axios parameter creator
 * @export
 */
export const A1bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * A1bApi - functional programming interface
 * @export
 */
export const A1bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = A1bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['A1bApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * A1bApi - factory interface
 * @export
 */
export const A1bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = A1bApiFp(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * A1bApi - object-oriented interface
 * @export
 * @class A1bApi
 * @extends {BaseAPI}
 */
export class A1bApi extends BaseAPI {
    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof A1bApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return A1bApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * A1cApi - axios parameter creator
 * @export
 */
export const A1cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * A1cApi - functional programming interface
 * @export
 */
export const A1cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = A1cApiAxiosParamCreator(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['A1cApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * A1cApi - factory interface
 * @export
 */
export const A1cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = A1cApiFp(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * A1cApi - object-oriented interface
 * @export
 * @class A1cApi
 * @extends {BaseAPI}
 */
export class A1cApi extends BaseAPI {
    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof A1cApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return A1cApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AAddANewListApi - axios parameter creator
 * @export
 */
export const AAddANewListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AAddANewListApi - functional programming interface
 * @export
 */
export const AAddANewListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AAddANewListApiAxiosParamCreator(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AAddANewListApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AAddANewListApi - factory interface
 * @export
 */
export const AAddANewListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AAddANewListApiFp(configuration)
    return {
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AAddANewListApi - object-oriented interface
 * @export
 * @class AAddANewListApi
 * @extends {BaseAPI}
 */
export class AAddANewListApi extends BaseAPI {
    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AAddANewListApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return AAddANewListApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByApple: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/apple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail: async (requestUserLoginEmail?: RequestUserLoginEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserLoginEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle: async (requestGoogleAuth?: RequestGoogleAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGoogleAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister: async (requestUserRegisterEmail?: RequestUserRegisterEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserRegisterEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine: async (code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault: async (requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateAvatar, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture: async (usersAvatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (usersAvatar !== undefined) { 
                localVarFormParams.append('users_avatar', usersAvatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet: async (requestAuthUpdateSetting?: RequestAuthUpdateSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_1: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/take-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByApple(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByApple(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authByApple']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByEmail(requestUserLoginEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByGoogle(requestGoogleAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authByGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailRegister(requestUserRegisterEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.emailRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthByLine(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getAuthByLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getAuthInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUseDefault(requestAuthUpdateAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateAvatarUseDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUsePicture(usersAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateAvatarUsePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSet(requestAuthUpdateSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser_1(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateUser_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByApple(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByApple(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByEmail(requestUserLoginEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByGoogle(requestGoogleAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.emailRegister(requestUserRegisterEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.getAuthByLine(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getAuthInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUsePicture(usersAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserSet(requestAuthUpdateSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser_1(updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Use this endpoint to login/register using Apple
     * @summary Auth Apple
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authByApple(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authByApple(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login using email
     * @summary Auth Email
     * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authByEmail(requestUserLoginEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using google
     * @summary Auth Google
     * @param {RequestGoogleAuth} [requestGoogleAuth] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authByGoogle(requestGoogleAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to register using email
     * @summary Email - Register
     * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).emailRegister(requestUserRegisterEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Line
     * @summary Auth Line
     * @param {string} [code] Code passed to line
     * @param {string} [state] State passed to line
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthByLine(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
     * @summary Read Authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAuthInfo(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getAuthInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user avatar
     * @summary Update User Avatar
     * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile picture
     * @summary Update User Profile Picture
     * @param {File} [usersAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateAvatarUsePicture(usersAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings<br/>1 - True (On)<br />0 - False (Off)
     * @summary Update User Setting
     * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateUserSet(requestAuthUpdateSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User Take Me
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateUser_1(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class10Api - axios parameter creator
 * @export
 */
export const Class10ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class10Api - functional programming interface
 * @export
 */
export const Class10ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class10ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class10Api.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class10Api - factory interface
 * @export
 */
export const Class10ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class10ApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class10Api - object-oriented interface
 * @export
 * @class Class10Api
 * @extends {BaseAPI}
 */
export class Class10Api extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class10Api
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return Class10ApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class11Api - axios parameter creator
 * @export
 */
export const Class11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class11Api - functional programming interface
 * @export
 */
export const Class11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class11ApiAxiosParamCreator(configuration)
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class11Api.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class11Api.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class11Api - factory interface
 * @export
 */
export const Class11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class11ApiFp(configuration)
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class11Api - object-oriented interface
 * @export
 * @class Class11Api
 * @extends {BaseAPI}
 */
export class Class11Api extends BaseAPI {
    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class11Api
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return Class11ApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class11Api
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class11ApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class11aApi - axios parameter creator
 * @export
 */
export const Class11aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class11aApi - functional programming interface
 * @export
 */
export const Class11aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class11aApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class11aApi.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class11aApi - factory interface
 * @export
 */
export const Class11aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class11aApiFp(configuration)
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class11aApi - object-oriented interface
 * @export
 * @class Class11aApi
 * @extends {BaseAPI}
 */
export class Class11aApi extends BaseAPI {
    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class11aApi
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return Class11aApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];


/**
 * Class12Api - axios parameter creator
 * @export
 */
export const Class12ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText: async (keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (rectangleLowLat !== undefined) {
                localVarQueryParameter['rectangle_low_lat'] = rectangleLowLat;
            }

            if (rectangleLowLng !== undefined) {
                localVarQueryParameter['rectangle_low_lng'] = rectangleLowLng;
            }

            if (rectangleHightLat !== undefined) {
                localVarQueryParameter['rectangle_hight_lat'] = rectangleHightLat;
            }

            if (rectangleHightLng !== undefined) {
                localVarQueryParameter['rectangle_hight_lng'] = rectangleHightLng;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class12Api - functional programming interface
 * @export
 */
export const Class12ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class12ApiAxiosParamCreator(configuration)
    return {
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildSearchText200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class12Api.rewildSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class12Api - factory interface
 * @export
 */
export const Class12ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class12ApiFp(configuration)
    return {
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildSearchText200ResponseInner>> {
            return localVarFp.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class12Api - object-oriented interface
 * @export
 * @class Class12Api
 * @extends {BaseAPI}
 */
export class Class12Api extends BaseAPI {
    /**
     * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
     * @summary 野放點關鍵字搜尋
     * @param {string} [keyword] 
     * @param {string} [rectangleLowLat] 
     * @param {string} [rectangleLowLng] 
     * @param {number} [rectangleHightLat] 
     * @param {number} [rectangleHightLng] 
     * @param {RewildSearchTextLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class12Api
     */
    public rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig) {
        return Class12ApiFp(this.configuration).rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildSearchTextLanguageEnum = {
    ZhTw: 'zh-TW',
    En: 'en'
} as const;
export type RewildSearchTextLanguageEnum = typeof RewildSearchTextLanguageEnum[keyof typeof RewildSearchTextLanguageEnum];


/**
 * Class12aApi - axios parameter creator
 * @export
 */
export const Class12aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class12aApi - functional programming interface
 * @export
 */
export const Class12aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class12aApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class12aApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class12aApi - factory interface
 * @export
 */
export const Class12aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class12aApiFp(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class12aApi - object-oriented interface
 * @export
 * @class Class12aApi
 * @extends {BaseAPI}
 */
export class Class12aApi extends BaseAPI {
    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class12aApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return Class12aApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];


/**
 * Class12bApi - axios parameter creator
 * @export
 */
export const Class12bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class12bApi - functional programming interface
 * @export
 */
export const Class12bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class12bApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class12bApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class12bApi - factory interface
 * @export
 */
export const Class12bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class12bApiFp(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class12bApi - object-oriented interface
 * @export
 * @class Class12bApi
 * @extends {BaseAPI}
 */
export class Class12bApi extends BaseAPI {
    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class12bApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return Class12bApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];


/**
 * Class13Api - axios parameter creator
 * @export
 */
export const Class13ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class13Api - functional programming interface
 * @export
 */
export const Class13ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class13ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class13Api.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class13Api - factory interface
 * @export
 */
export const Class13ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class13ApiFp(configuration)
    return {
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class13Api - object-oriented interface
 * @export
 * @class Class13Api
 * @extends {BaseAPI}
 */
export class Class13Api extends BaseAPI {
    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class13Api
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return Class13ApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];


/**
 * Class141Api - axios parameter creator
 * @export
 */
export const Class141ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141Api - functional programming interface
 * @export
 */
export const Class141ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141Api.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141Api - factory interface
 * @export
 */
export const Class141ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141ApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141Api - object-oriented interface
 * @export
 * @class Class141Api
 * @extends {BaseAPI}
 */
export class Class141Api extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141Api
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141ApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1411Api - axios parameter creator
 * @export
 */
export const Class1411ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1411Api - functional programming interface
 * @export
 */
export const Class1411ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1411ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1411Api.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1411Api - factory interface
 * @export
 */
export const Class1411ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1411ApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1411Api - object-oriented interface
 * @export
 * @class Class1411Api
 * @extends {BaseAPI}
 */
export class Class1411Api extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1411Api
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class1411ApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1411aApi - axios parameter creator
 * @export
 */
export const Class1411aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1411aApi - functional programming interface
 * @export
 */
export const Class1411aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1411aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1411aApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1411aApi - factory interface
 * @export
 */
export const Class1411aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1411aApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1411aApi - object-oriented interface
 * @export
 * @class Class1411aApi
 * @extends {BaseAPI}
 */
export class Class1411aApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1411aApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class1411aApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1412Api - axios parameter creator
 * @export
 */
export const Class1412ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1412Api - functional programming interface
 * @export
 */
export const Class1412ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1412ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1412Api.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1412Api - factory interface
 * @export
 */
export const Class1412ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1412ApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1412Api - object-oriented interface
 * @export
 * @class Class1412Api
 * @extends {BaseAPI}
 */
export class Class1412Api extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1412Api
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class1412ApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1412aApi - axios parameter creator
 * @export
 */
export const Class1412aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1412aApi - functional programming interface
 * @export
 */
export const Class1412aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1412aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1412aApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1412aApi - factory interface
 * @export
 */
export const Class1412aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1412aApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1412aApi - object-oriented interface
 * @export
 * @class Class1412aApi
 * @extends {BaseAPI}
 */
export class Class1412aApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1412aApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class1412aApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1413Api - axios parameter creator
 * @export
 */
export const Class1413ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1413Api - functional programming interface
 * @export
 */
export const Class1413ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1413ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1413Api.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1413Api - factory interface
 * @export
 */
export const Class1413ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1413ApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1413Api - object-oriented interface
 * @export
 * @class Class1413Api
 * @extends {BaseAPI}
 */
export class Class1413Api extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1413Api
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class1413ApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141aApi - axios parameter creator
 * @export
 */
export const Class141aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141aApi - functional programming interface
 * @export
 */
export const Class141aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141aApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141aApi - factory interface
 * @export
 */
export const Class141aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141aApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141aApi - object-oriented interface
 * @export
 * @class Class141aApi
 * @extends {BaseAPI}
 */
export class Class141aApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141aApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141aApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141bApi - axios parameter creator
 * @export
 */
export const Class141bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141bApi - functional programming interface
 * @export
 */
export const Class141bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141bApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141bApi - factory interface
 * @export
 */
export const Class141bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141bApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141bApi - object-oriented interface
 * @export
 * @class Class141bApi
 * @extends {BaseAPI}
 */
export class Class141bApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141bApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141bApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141cApi - axios parameter creator
 * @export
 */
export const Class141cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141cApi - functional programming interface
 * @export
 */
export const Class141cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141cApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141cApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141cApi - factory interface
 * @export
 */
export const Class141cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141cApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141cApi - object-oriented interface
 * @export
 * @class Class141cApi
 * @extends {BaseAPI}
 */
export class Class141cApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141cApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141cApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141dApi - axios parameter creator
 * @export
 */
export const Class141dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141dApi - functional programming interface
 * @export
 */
export const Class141dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141dApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141dApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141dApi - factory interface
 * @export
 */
export const Class141dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141dApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141dApi - object-oriented interface
 * @export
 * @class Class141dApi
 * @extends {BaseAPI}
 */
export class Class141dApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141dApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141dApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141eApi - axios parameter creator
 * @export
 */
export const Class141eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141eApi - functional programming interface
 * @export
 */
export const Class141eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141eApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141eApi - factory interface
 * @export
 */
export const Class141eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141eApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141eApi - object-oriented interface
 * @export
 * @class Class141eApi
 * @extends {BaseAPI}
 */
export class Class141eApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141eApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141eApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141fApi - axios parameter creator
 * @export
 */
export const Class141fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141fApi - functional programming interface
 * @export
 */
export const Class141fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141fApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141fApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141fApi - factory interface
 * @export
 */
export const Class141fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141fApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141fApi - object-oriented interface
 * @export
 * @class Class141fApi
 * @extends {BaseAPI}
 */
export class Class141fApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141fApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141fApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141gApi - axios parameter creator
 * @export
 */
export const Class141gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141gApi - functional programming interface
 * @export
 */
export const Class141gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141gApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141gApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141gApi - factory interface
 * @export
 */
export const Class141gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141gApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141gApi - object-oriented interface
 * @export
 * @class Class141gApi
 * @extends {BaseAPI}
 */
export class Class141gApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141gApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141gApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141hApi - axios parameter creator
 * @export
 */
export const Class141hApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo: async (requestLinkQuery?: RequestLinkQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/link-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestLinkQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141hApi - functional programming interface
 * @export
 */
export const Class141hApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141hApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrlInfo(requestLinkQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141hApi.getUrlInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141hApi - factory interface
 * @export
 */
export const Class141hApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141hApiFp(configuration)
    return {
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): AxiosPromise<LinkQuery> {
            return localVarFp.getUrlInfo(requestLinkQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141hApi - object-oriented interface
 * @export
 * @class Class141hApi
 * @extends {BaseAPI}
 */
export class Class141hApi extends BaseAPI {
    /**
     * 
     * @summary Link Query
     * @param {RequestLinkQuery} [requestLinkQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141hApi
     */
    public getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig) {
        return Class141hApiFp(this.configuration).getUrlInfo(requestLinkQuery, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141iApi - axios parameter creator
 * @export
 */
export const Class141iApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141iApi - functional programming interface
 * @export
 */
export const Class141iApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141iApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141iApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141iApi - factory interface
 * @export
 */
export const Class141iApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141iApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141iApi - object-oriented interface
 * @export
 * @class Class141iApi
 * @extends {BaseAPI}
 */
export class Class141iApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141iApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141iApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class141jApi - axios parameter creator
 * @export
 */
export const Class141jApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class141jApi - functional programming interface
 * @export
 */
export const Class141jApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class141jApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class141jApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class141jApi - factory interface
 * @export
 */
export const Class141jApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class141jApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class141jApi - object-oriented interface
 * @export
 * @class Class141jApi
 * @extends {BaseAPI}
 */
export class Class141jApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class141jApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return Class141jApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class15Api - axios parameter creator
 * @export
 */
export const Class15ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class15Api - functional programming interface
 * @export
 */
export const Class15ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class15ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class15Api.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class15Api - factory interface
 * @export
 */
export const Class15ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class15ApiFp(configuration)
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class15Api - object-oriented interface
 * @export
 * @class Class15Api
 * @extends {BaseAPI}
 */
export class Class15Api extends BaseAPI {
    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class15Api
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return Class15ApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class151Api - axios parameter creator
 * @export
 */
export const Class151ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class151Api - functional programming interface
 * @export
 */
export const Class151ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class151ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class151Api.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class151Api - factory interface
 * @export
 */
export const Class151ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class151ApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class151Api - object-oriented interface
 * @export
 * @class Class151Api
 * @extends {BaseAPI}
 */
export class Class151Api extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class151Api
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class151ApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class151bApi - axios parameter creator
 * @export
 */
export const Class151bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('deleteRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class151bApi - functional programming interface
 * @export
 */
export const Class151bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class151bApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class151bApi.deleteRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class151bApi - factory interface
 * @export
 */
export const Class151bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class151bApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class151bApi - object-oriented interface
 * @export
 * @class Class151bApi
 * @extends {BaseAPI}
 */
export class Class151bApi extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Delete Rewilding
     * @param {string} rewildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class151bApi
     */
    public deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return Class151bApiFp(this.configuration).deleteRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class152Api - axios parameter creator
 * @export
 */
export const Class152ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItems', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class152Api - functional programming interface
 * @export
 */
export const Class152ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class152ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItems(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class152Api.getPocketListItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class152Api - factory interface
 * @export
 */
export const Class152ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class152ApiFp(configuration)
    return {
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInner>> {
            return localVarFp.getPocketListItems(pocketListId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class152Api - object-oriented interface
 * @export
 * @class Class152Api
 * @extends {BaseAPI}
 */
export class Class152Api extends BaseAPI {
    /**
     * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
     * @summary Get pocket list items by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class152Api
     */
    public getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig) {
        return Class152ApiFp(this.configuration).getPocketListItems(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1521Api - axios parameter creator
 * @export
 */
export const Class1521ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1521Api - functional programming interface
 * @export
 */
export const Class1521ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1521ApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1521Api.deletePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1521Api - factory interface
 * @export
 */
export const Class1521ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1521ApiFp(configuration)
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1521Api - object-oriented interface
 * @export
 * @class Class1521Api
 * @extends {BaseAPI}
 */
export class Class1521Api extends BaseAPI {
    /**
     * Delete pocket list
     * @summary Delete pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1521Api
     */
    public deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return Class1521ApiFp(this.configuration).deletePocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1522Api - axios parameter creator
 * @export
 */
export const Class1522ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1522Api - functional programming interface
 * @export
 */
export const Class1522ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1522ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1522Api.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1522Api - factory interface
 * @export
 */
export const Class1522ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1522ApiFp(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1522Api - object-oriented interface
 * @export
 * @class Class1522Api
 * @extends {BaseAPI}
 */
export class Class1522Api extends BaseAPI {
    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1522Api
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return Class1522ApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class15221Api - axios parameter creator
 * @export
 */
export const Class15221ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem: async (pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePocketListItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class15221Api - functional programming interface
 * @export
 */
export const Class15221ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class15221ApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketListItem(pocketListId, deletePocketListItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class15221Api.deletePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class15221Api - factory interface
 * @export
 */
export const Class15221ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class15221ApiFp(configuration)
    return {
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class15221Api - object-oriented interface
 * @export
 * @class Class15221Api
 * @extends {BaseAPI}
 */
export class Class15221Api extends BaseAPI {
    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class15221Api
     */
    public deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig) {
        return Class15221ApiFp(this.configuration).deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class15222Api - axios parameter creator
 * @export
 */
export const Class15222ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem: async (pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('movePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdateBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class15222Api - functional programming interface
 * @export
 */
export const Class15222ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class15222ApiAxiosParamCreator(configuration)
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class15222Api.movePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class15222Api - factory interface
 * @export
 */
export const Class15222ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class15222ApiFp(configuration)
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class15222Api - object-oriented interface
 * @export
 * @class Class15222Api
 * @extends {BaseAPI}
 */
export class Class15222Api extends BaseAPI {
    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class15222Api
     */
    public movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig) {
        return Class15222ApiFp(this.configuration).movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class15222aApi - axios parameter creator
 * @export
 */
export const Class15222aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem: async (pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('movePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdateBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class15222aApi - functional programming interface
 * @export
 */
export const Class15222aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class15222aApiAxiosParamCreator(configuration)
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class15222aApi.movePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class15222aApi - factory interface
 * @export
 */
export const Class15222aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class15222aApiFp(configuration)
    return {
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class15222aApi - object-oriented interface
 * @export
 * @class Class15222aApi
 * @extends {BaseAPI}
 */
export class Class15222aApi extends BaseAPI {
    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class15222aApi
     */
    public movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig) {
        return Class15222aApiFp(this.configuration).movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1522aApi - axios parameter creator
 * @export
 */
export const Class1522aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1522aApi - functional programming interface
 * @export
 */
export const Class1522aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1522aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1522aApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1522aApi - factory interface
 * @export
 */
export const Class1522aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1522aApiFp(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1522aApi - object-oriented interface
 * @export
 * @class Class1522aApi
 * @extends {BaseAPI}
 */
export class Class1522aApi extends BaseAPI {
    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1522aApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return Class1522aApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1522bApi - axios parameter creator
 * @export
 */
export const Class1522bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1522bApi - functional programming interface
 * @export
 */
export const Class1522bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1522bApiAxiosParamCreator(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1522bApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1522bApi - factory interface
 * @export
 */
export const Class1522bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1522bApiFp(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1522bApi - object-oriented interface
 * @export
 * @class Class1522bApi
 * @extends {BaseAPI}
 */
export class Class1522bApi extends BaseAPI {
    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1522bApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return Class1522bApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class1522cApi - axios parameter creator
 * @export
 */
export const Class1522cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class1522cApi - functional programming interface
 * @export
 */
export const Class1522cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class1522cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class1522cApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class1522cApi - factory interface
 * @export
 */
export const Class1522cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class1522cApiFp(configuration)
    return {
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class1522cApi - object-oriented interface
 * @export
 * @class Class1522cApi
 * @extends {BaseAPI}
 */
export class Class1522cApi extends BaseAPI {
    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class1522cApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return Class1522cApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class152aApi - axios parameter creator
 * @export
 */
export const Class152aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class152aApi - functional programming interface
 * @export
 */
export const Class152aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class152aApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class152aApi.deletePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class152aApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class152aApi - factory interface
 * @export
 */
export const Class152aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class152aApiFp(configuration)
    return {
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class152aApi - object-oriented interface
 * @export
 * @class Class152aApi
 * @extends {BaseAPI}
 */
export class Class152aApi extends BaseAPI {
    /**
     * Delete pocket list
     * @summary Delete pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class152aApi
     */
    public deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return Class152aApiFp(this.configuration).deletePocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class152aApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return Class152aApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class20Api - axios parameter creator
 * @export
 */
export const Class20ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class20Api - functional programming interface
 * @export
 */
export const Class20ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class20ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class20Api.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class20Api - factory interface
 * @export
 */
export const Class20ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class20ApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class20Api - object-oriented interface
 * @export
 * @class Class20Api
 * @extends {BaseAPI}
 */
export class Class20Api extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class20Api
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return Class20ApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class20aApi - axios parameter creator
 * @export
 */
export const Class20aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class20aApi - functional programming interface
 * @export
 */
export const Class20aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class20aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class20aApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class20aApi - factory interface
 * @export
 */
export const Class20aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class20aApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class20aApi - object-oriented interface
 * @export
 * @class Class20aApi
 * @extends {BaseAPI}
 */
export class Class20aApi extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class20aApi
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return Class20aApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21Api - axios parameter creator
 * @export
 */
export const Class21ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21Api - functional programming interface
 * @export
 */
export const Class21ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21Api.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21Api - factory interface
 * @export
 */
export const Class21ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21ApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21Api - object-oriented interface
 * @export
 * @class Class21Api
 * @extends {BaseAPI}
 */
export class Class21Api extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21Api
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21ApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class211Api - axios parameter creator
 * @export
 */
export const Class211ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class211Api - functional programming interface
 * @export
 */
export const Class211ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class211ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class211Api.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class211Api - factory interface
 * @export
 */
export const Class211ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class211ApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class211Api - object-oriented interface
 * @export
 * @class Class211Api
 * @extends {BaseAPI}
 */
export class Class211Api extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class211Api
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class211ApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111aApi - axios parameter creator
 * @export
 */
export const Class2111aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111aApi - functional programming interface
 * @export
 */
export const Class2111aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111aApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111aApi - factory interface
 * @export
 */
export const Class2111aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111aApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111aApi - object-oriented interface
 * @export
 * @class Class2111aApi
 * @extends {BaseAPI}
 */
export class Class2111aApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111aApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111aApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111bApi - axios parameter creator
 * @export
 */
export const Class2111bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111bApi - functional programming interface
 * @export
 */
export const Class2111bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111bApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111bApi - factory interface
 * @export
 */
export const Class2111bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111bApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111bApi - object-oriented interface
 * @export
 * @class Class2111bApi
 * @extends {BaseAPI}
 */
export class Class2111bApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111bApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111bApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111cApi - axios parameter creator
 * @export
 */
export const Class2111cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111cApi - functional programming interface
 * @export
 */
export const Class2111cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111cApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111cApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111cApi - factory interface
 * @export
 */
export const Class2111cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111cApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111cApi - object-oriented interface
 * @export
 * @class Class2111cApi
 * @extends {BaseAPI}
 */
export class Class2111cApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111cApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111cApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111dApi - axios parameter creator
 * @export
 */
export const Class2111dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111dApi - functional programming interface
 * @export
 */
export const Class2111dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111dApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111dApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111dApi - factory interface
 * @export
 */
export const Class2111dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111dApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111dApi - object-oriented interface
 * @export
 * @class Class2111dApi
 * @extends {BaseAPI}
 */
export class Class2111dApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111dApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111dApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111eApi - axios parameter creator
 * @export
 */
export const Class2111eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111eApi - functional programming interface
 * @export
 */
export const Class2111eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111eApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111eApi - factory interface
 * @export
 */
export const Class2111eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111eApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111eApi - object-oriented interface
 * @export
 * @class Class2111eApi
 * @extends {BaseAPI}
 */
export class Class2111eApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111eApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111eApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class2111fApi - axios parameter creator
 * @export
 */
export const Class2111fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class2111fApi - functional programming interface
 * @export
 */
export const Class2111fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class2111fApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class2111fApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class2111fApi - factory interface
 * @export
 */
export const Class2111fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class2111fApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class2111fApi - object-oriented interface
 * @export
 * @class Class2111fApi
 * @extends {BaseAPI}
 */
export class Class2111fApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class2111fApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class2111fApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class211aApi - axios parameter creator
 * @export
 */
export const Class211aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class211aApi - functional programming interface
 * @export
 */
export const Class211aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class211aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class211aApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class211aApi - factory interface
 * @export
 */
export const Class211aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class211aApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class211aApi - object-oriented interface
 * @export
 * @class Class211aApi
 * @extends {BaseAPI}
 */
export class Class211aApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class211aApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class211aApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class211bApi - axios parameter creator
 * @export
 */
export const Class211bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class211bApi - functional programming interface
 * @export
 */
export const Class211bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class211bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class211bApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class211bApi - factory interface
 * @export
 */
export const Class211bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class211bApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class211bApi - object-oriented interface
 * @export
 * @class Class211bApi
 * @extends {BaseAPI}
 */
export class Class211bApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class211bApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class211bApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21aApi - axios parameter creator
 * @export
 */
export const Class21aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21aApi - functional programming interface
 * @export
 */
export const Class21aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21aApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21aApi - factory interface
 * @export
 */
export const Class21aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21aApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21aApi - object-oriented interface
 * @export
 * @class Class21aApi
 * @extends {BaseAPI}
 */
export class Class21aApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21aApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21aApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21bApi - axios parameter creator
 * @export
 */
export const Class21bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21bApi - functional programming interface
 * @export
 */
export const Class21bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21bApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21bApi - factory interface
 * @export
 */
export const Class21bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21bApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21bApi - object-oriented interface
 * @export
 * @class Class21bApi
 * @extends {BaseAPI}
 */
export class Class21bApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21bApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21bApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21cApi - axios parameter creator
 * @export
 */
export const Class21cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21cApi - functional programming interface
 * @export
 */
export const Class21cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21cApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21cApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21cApi - factory interface
 * @export
 */
export const Class21cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21cApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21cApi - object-oriented interface
 * @export
 * @class Class21cApi
 * @extends {BaseAPI}
 */
export class Class21cApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21cApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21cApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c1Api - axios parameter creator
 * @export
 */
export const Class21c1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c1Api - functional programming interface
 * @export
 */
export const Class21c1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c1Api.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c1Api - factory interface
 * @export
 */
export const Class21c1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c1ApiFp(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c1Api - object-oriented interface
 * @export
 * @class Class21c1Api
 * @extends {BaseAPI}
 */
export class Class21c1Api extends BaseAPI {
    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class21c1Api
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return Class21c1ApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * Class21c11Api - axios parameter creator
 * @export
 */
export const Class21c11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c11Api - functional programming interface
 * @export
 */
export const Class21c11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c11ApiAxiosParamCreator(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c11Api.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c11Api - factory interface
 * @export
 */
export const Class21c11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c11ApiFp(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c11Api - object-oriented interface
 * @export
 * @class Class21c11Api
 * @extends {BaseAPI}
 */
export class Class21c11Api extends BaseAPI {
    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class21c11Api
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return Class21c11ApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * Class21c11aApi - axios parameter creator
 * @export
 */
export const Class21c11aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c11aApi - functional programming interface
 * @export
 */
export const Class21c11aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c11aApiAxiosParamCreator(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c11aApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c11aApi - factory interface
 * @export
 */
export const Class21c11aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c11aApiFp(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c11aApi - object-oriented interface
 * @export
 * @class Class21c11aApi
 * @extends {BaseAPI}
 */
export class Class21c11aApi extends BaseAPI {
    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class21c11aApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return Class21c11aApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * Class21c11bApi - axios parameter creator
 * @export
 */
export const Class21c11bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c11bApi - functional programming interface
 * @export
 */
export const Class21c11bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c11bApiAxiosParamCreator(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c11bApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c11bApi - factory interface
 * @export
 */
export const Class21c11bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c11bApiFp(configuration)
    return {
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c11bApi - object-oriented interface
 * @export
 * @class Class21c11bApi
 * @extends {BaseAPI}
 */
export class Class21c11bApi extends BaseAPI {
    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class21c11bApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return Class21c11bApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * Class21c12Api - axios parameter creator
 * @export
 */
export const Class21c12ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c12Api - functional programming interface
 * @export
 */
export const Class21c12ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c12ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c12Api.getReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c12Api - factory interface
 * @export
 */
export const Class21c12ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c12ApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.getReferences(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c12Api - object-oriented interface
 * @export
 * @class Class21c12Api
 * @extends {BaseAPI}
 */
export class Class21c12Api extends BaseAPI {
    /**
     * 
     * @summary Retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c12Api
     */
    public getReferences(options?: RawAxiosRequestConfig) {
        return Class21c12ApiFp(this.configuration).getReferences(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c12aApi - axios parameter creator
 * @export
 */
export const Class21c12aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c12aApi - functional programming interface
 * @export
 */
export const Class21c12aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c12aApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c12aApi.getReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c12aApi - factory interface
 * @export
 */
export const Class21c12aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c12aApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.getReferences(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c12aApi - object-oriented interface
 * @export
 * @class Class21c12aApi
 * @extends {BaseAPI}
 */
export class Class21c12aApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c12aApi
     */
    public getReferences(options?: RawAxiosRequestConfig) {
        return Class21c12aApiFp(this.configuration).getReferences(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c12bApi - axios parameter creator
 * @export
 */
export const Class21c12bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c12bApi - functional programming interface
 * @export
 */
export const Class21c12bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c12bApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c12bApi.getReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c12bApi - factory interface
 * @export
 */
export const Class21c12bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c12bApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.getReferences(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c12bApi - object-oriented interface
 * @export
 * @class Class21c12bApi
 * @extends {BaseAPI}
 */
export class Class21c12bApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c12bApi
     */
    public getReferences(options?: RawAxiosRequestConfig) {
        return Class21c12bApiFp(this.configuration).getReferences(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c2Api - axios parameter creator
 * @export
 */
export const Class21c2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c2Api - functional programming interface
 * @export
 */
export const Class21c2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c2ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c2Api.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c2Api - factory interface
 * @export
 */
export const Class21c2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c2ApiFp(configuration)
    return {
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c2Api - object-oriented interface
 * @export
 * @class Class21c2Api
 * @extends {BaseAPI}
 */
export class Class21c2Api extends BaseAPI {
    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c2Api
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return Class21c2ApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c22Api - axios parameter creator
 * @export
 */
export const Class21c22ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c22Api - functional programming interface
 * @export
 */
export const Class21c22ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c22ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c22Api.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c22Api - factory interface
 * @export
 */
export const Class21c22ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c22ApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c22Api - object-oriented interface
 * @export
 * @class Class21c22Api
 * @extends {BaseAPI}
 */
export class Class21c22Api extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c22Api
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class21c22ApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21c22aApi - axios parameter creator
 * @export
 */
export const Class21c22aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21c22aApi - functional programming interface
 * @export
 */
export const Class21c22aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21c22aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21c22aApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21c22aApi - factory interface
 * @export
 */
export const Class21c22aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21c22aApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21c22aApi - object-oriented interface
 * @export
 * @class Class21c22aApi
 * @extends {BaseAPI}
 */
export class Class21c22aApi extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21c22aApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class21c22aApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21dApi - axios parameter creator
 * @export
 */
export const Class21dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21dApi - functional programming interface
 * @export
 */
export const Class21dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21dApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21dApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21dApi - factory interface
 * @export
 */
export const Class21dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21dApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21dApi - object-oriented interface
 * @export
 * @class Class21dApi
 * @extends {BaseAPI}
 */
export class Class21dApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21dApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21dApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class21eApi - axios parameter creator
 * @export
 */
export const Class21eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class21eApi - functional programming interface
 * @export
 */
export const Class21eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class21eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class21eApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class21eApi - factory interface
 * @export
 */
export const Class21eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class21eApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class21eApi - object-oriented interface
 * @export
 * @class Class21eApi
 * @extends {BaseAPI}
 */
export class Class21eApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class21eApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class21eApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class22Api - axios parameter creator
 * @export
 */
export const Class22ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class22Api - functional programming interface
 * @export
 */
export const Class22ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class22ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class22Api.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class22Api - factory interface
 * @export
 */
export const Class22ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class22ApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class22Api - object-oriented interface
 * @export
 * @class Class22Api
 * @extends {BaseAPI}
 */
export class Class22Api extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class22Api
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return Class22ApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30Api - axios parameter creator
 * @export
 */
export const Class30ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30Api - functional programming interface
 * @export
 */
export const Class30ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30Api.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30Api.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30Api - factory interface
 * @export
 */
export const Class30ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30ApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30Api - object-oriented interface
 * @export
 * @class Class30Api
 * @extends {BaseAPI}
 */
export class Class30Api extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30Api
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return Class30ApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30Api
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class30ApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30aApi - axios parameter creator
 * @export
 */
export const Class30aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30aApi - functional programming interface
 * @export
 */
export const Class30aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30aApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30aApi - factory interface
 * @export
 */
export const Class30aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30aApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30aApi - object-oriented interface
 * @export
 * @class Class30aApi
 * @extends {BaseAPI}
 */
export class Class30aApi extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30aApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class30aApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30bApi - axios parameter creator
 * @export
 */
export const Class30bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30bApi - functional programming interface
 * @export
 */
export const Class30bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30bApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30bApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30bApi - factory interface
 * @export
 */
export const Class30bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30bApiFp(configuration)
    return {
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30bApi - object-oriented interface
 * @export
 * @class Class30bApi
 * @extends {BaseAPI}
 */
export class Class30bApi extends BaseAPI {
    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30bApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return Class30bApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30cApi - axios parameter creator
 * @export
 */
export const Class30cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30cApi - functional programming interface
 * @export
 */
export const Class30cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30cApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30cApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30cApi - factory interface
 * @export
 */
export const Class30cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30cApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30cApi - object-oriented interface
 * @export
 * @class Class30cApi
 * @extends {BaseAPI}
 */
export class Class30cApi extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30cApi
     */
    public getAchievements(achievementType?: string, options?: RawAxiosRequestConfig) {
        return Class30cApiFp(this.configuration).getAchievements(achievementType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30dApi - axios parameter creator
 * @export
 */
export const Class30dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30dApi - functional programming interface
 * @export
 */
export const Class30dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30dApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30dApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30dApi - factory interface
 * @export
 */
export const Class30dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30dApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30dApi - object-oriented interface
 * @export
 * @class Class30dApi
 * @extends {BaseAPI}
 */
export class Class30dApi extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30dApi
     */
    public getAchievements(achievementType?: string, options?: RawAxiosRequestConfig) {
        return Class30dApiFp(this.configuration).getAchievements(achievementType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class30eApi - axios parameter creator
 * @export
 */
export const Class30eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class30eApi - functional programming interface
 * @export
 */
export const Class30eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class30eApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class30eApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class30eApi - factory interface
 * @export
 */
export const Class30eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class30eApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class30eApi - object-oriented interface
 * @export
 * @class Class30eApi
 * @extends {BaseAPI}
 */
export class Class30eApi extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class30eApi
     */
    public getAchievements(achievementType?: string, options?: RawAxiosRequestConfig) {
        return Class30eApiFp(this.configuration).getAchievements(achievementType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class31Api - axios parameter creator
 * @export
 */
export const Class31ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs: async (rewildingId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rewildingId !== undefined) {
                localVarQueryParameter['rewilding_id'] = rewildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class31Api - functional programming interface
 * @export
 */
export const Class31ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class31ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeLogs(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class31Api.getCollaborativeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class31Api - factory interface
 * @export
 */
export const Class31ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class31ApiFp(configuration)
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getCollaborativeLogs(rewildingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class31Api - object-oriented interface
 * @export
 * @class Class31Api
 * @extends {BaseAPI}
 */
export class Class31Api extends BaseAPI {
    /**
     * Retrieve events that has ended
     * @summary Event Collaborate
     * @param {string} [rewildingId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class31Api
     */
    public getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig) {
        return Class31ApiFp(this.configuration).getCollaborativeLogs(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311Api - axios parameter creator
 * @export
 */
export const Class311ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCollaborativeAlbumLinks', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPolaroids', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311Api - functional programming interface
 * @export
 */
export const Class311ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAlbumLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeAlbumLinks(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311Api.getCollaborativeAlbumLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolaroids(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPolaroids200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolaroids(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311Api.getPolaroids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311Api - factory interface
 * @export
 */
export const Class311ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311ApiFp(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAlbumLink>> {
            return localVarFp.getCollaborativeAlbumLinks(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPolaroids200ResponseInner>> {
            return localVarFp.getPolaroids(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311Api - object-oriented interface
 * @export
 * @class Class311Api
 * @extends {BaseAPI}
 */
export class Class311Api extends BaseAPI {
    /**
     * Retrieve album link in event
     * @summary Retrieve Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311Api
     */
    public getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig) {
        return Class311ApiFp(this.configuration).getCollaborativeAlbumLinks(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve event polaroid
     * @summary Retrieve Polaroid
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311Api
     */
    public getPolaroids(eventId: string, options?: RawAxiosRequestConfig) {
        return Class311ApiFp(this.configuration).getPolaroids(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3111Api - axios parameter creator
 * @export
 */
export const Class3111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPolaroids', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3111Api - functional programming interface
 * @export
 */
export const Class3111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolaroids(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPolaroids200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolaroids(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3111Api.getPolaroids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3111Api - factory interface
 * @export
 */
export const Class3111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3111ApiFp(configuration)
    return {
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPolaroids200ResponseInner>> {
            return localVarFp.getPolaroids(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3111Api - object-oriented interface
 * @export
 * @class Class3111Api
 * @extends {BaseAPI}
 */
export class Class3111Api extends BaseAPI {
    /**
     * Retrieve event polaroid
     * @summary Retrieve Polaroid
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3111Api
     */
    public getPolaroids(eventId: string, options?: RawAxiosRequestConfig) {
        return Class3111ApiFp(this.configuration).getPolaroids(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3113Api - axios parameter creator
 * @export
 */
export const Class3113ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3113Api - functional programming interface
 * @export
 */
export const Class3113ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3113ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3113Api.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3113Api - factory interface
 * @export
 */
export const Class3113ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3113ApiFp(configuration)
    return {
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3113Api - object-oriented interface
 * @export
 * @class Class3113Api
 * @extends {BaseAPI}
 */
export class Class3113Api extends BaseAPI {
    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3113Api
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return Class3113ApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3114Api - axios parameter creator
 * @export
 */
export const Class3114ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3114Api - functional programming interface
 * @export
 */
export const Class3114ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3114ApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3114Api.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3114Api - factory interface
 * @export
 */
export const Class3114ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3114ApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3114Api - object-oriented interface
 * @export
 * @class Class3114Api
 * @extends {BaseAPI}
 */
export class Class3114Api extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3114Api
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3114ApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3114aApi - axios parameter creator
 * @export
 */
export const Class3114aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3114aApi - functional programming interface
 * @export
 */
export const Class3114aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3114aApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3114aApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3114aApi - factory interface
 * @export
 */
export const Class3114aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3114aApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3114aApi - object-oriented interface
 * @export
 * @class Class3114aApi
 * @extends {BaseAPI}
 */
export class Class3114aApi extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3114aApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3114aApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311aApi - axios parameter creator
 * @export
 */
export const Class311aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311aApi - functional programming interface
 * @export
 */
export const Class311aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311aApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311aApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311aApi - factory interface
 * @export
 */
export const Class311aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311aApiFp(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311aApi - object-oriented interface
 * @export
 * @class Class311aApi
 * @extends {BaseAPI}
 */
export class Class311aApi extends BaseAPI {
    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311aApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311aApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311aApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311aApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311bApi - axios parameter creator
 * @export
 */
export const Class311bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311bApi - functional programming interface
 * @export
 */
export const Class311bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311bApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311bApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311bApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311bApi - factory interface
 * @export
 */
export const Class311bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311bApiFp(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311bApi - object-oriented interface
 * @export
 * @class Class311bApi
 * @extends {BaseAPI}
 */
export class Class311bApi extends BaseAPI {
    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311bApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311bApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311bApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311bApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311cApi - axios parameter creator
 * @export
 */
export const Class311cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311cApi - functional programming interface
 * @export
 */
export const Class311cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311cApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311cApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311cApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311cApi - factory interface
 * @export
 */
export const Class311cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311cApiFp(configuration)
    return {
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311cApi - object-oriented interface
 * @export
 * @class Class311cApi
 * @extends {BaseAPI}
 */
export class Class311cApi extends BaseAPI {
    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311cApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311cApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311cApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return Class311cApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311eApi - axios parameter creator
 * @export
 */
export const Class311eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311eApi - functional programming interface
 * @export
 */
export const Class311eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311eApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311eApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311eApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311eApi - factory interface
 * @export
 */
export const Class311eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311eApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311eApi - object-oriented interface
 * @export
 * @class Class311eApi
 * @extends {BaseAPI}
 */
export class Class311eApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311eApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311eApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311eApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311eApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311eApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311eApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311fApi - axios parameter creator
 * @export
 */
export const Class311fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311fApi - functional programming interface
 * @export
 */
export const Class311fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311fApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311fApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311fApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311fApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311fApi - factory interface
 * @export
 */
export const Class311fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311fApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311fApi - object-oriented interface
 * @export
 * @class Class311fApi
 * @extends {BaseAPI}
 */
export class Class311fApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311fApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311fApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311fApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311fApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311fApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311fApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class311gApi - axios parameter creator
 * @export
 */
export const Class311gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class311gApi - functional programming interface
 * @export
 */
export const Class311gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class311gApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311gApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311gApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class311gApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class311gApi - factory interface
 * @export
 */
export const Class311gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class311gApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class311gApi - object-oriented interface
 * @export
 * @class Class311gApi
 * @extends {BaseAPI}
 */
export class Class311gApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311gApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311gApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311gApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311gApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class311gApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return Class311gApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class321Api - axios parameter creator
 * @export
 */
export const Class321ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class321Api - functional programming interface
 * @export
 */
export const Class321ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class321ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class321Api.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class321Api - factory interface
 * @export
 */
export const Class321ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class321ApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class321Api - object-oriented interface
 * @export
 * @class Class321Api
 * @extends {BaseAPI}
 */
export class Class321Api extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class321Api
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class321ApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class321aApi - axios parameter creator
 * @export
 */
export const Class321aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class321aApi - functional programming interface
 * @export
 */
export const Class321aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class321aApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class321aApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class321aApi - factory interface
 * @export
 */
export const Class321aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class321aApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class321aApi - object-oriented interface
 * @export
 * @class Class321aApi
 * @extends {BaseAPI}
 */
export class Class321aApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class321aApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class321aApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class32aApi - axios parameter creator
 * @export
 */
export const Class32aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs: async (rewildingId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rewildingId !== undefined) {
                localVarQueryParameter['rewilding_id'] = rewildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class32aApi - functional programming interface
 * @export
 */
export const Class32aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class32aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeLogs(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class32aApi.getCollaborativeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class32aApi - factory interface
 * @export
 */
export const Class32aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class32aApiFp(configuration)
    return {
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getCollaborativeLogs(rewildingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class32aApi - object-oriented interface
 * @export
 * @class Class32aApi
 * @extends {BaseAPI}
 */
export class Class32aApi extends BaseAPI {
    /**
     * Retrieve events that has ended
     * @summary Event Collaborate
     * @param {string} [rewildingId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class32aApi
     */
    public getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig) {
        return Class32aApiFp(this.configuration).getCollaborativeLogs(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331Api - axios parameter creator
 * @export
 */
export const Class331ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331Api - functional programming interface
 * @export
 */
export const Class331ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331Api.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331Api - factory interface
 * @export
 */
export const Class331ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331ApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331Api - object-oriented interface
 * @export
 * @class Class331Api
 * @extends {BaseAPI}
 */
export class Class331Api extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331Api
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331ApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class33111Api - axios parameter creator
 * @export
 */
export const Class33111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class33111Api - functional programming interface
 * @export
 */
export const Class33111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class33111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class33111Api.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class33111Api - factory interface
 * @export
 */
export const Class33111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class33111ApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class33111Api - object-oriented interface
 * @export
 * @class Class33111Api
 * @extends {BaseAPI}
 */
export class Class33111Api extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class33111Api
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class33111ApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331111dApi - axios parameter creator
 * @export
 */
export const Class331111dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp: async (eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabExp', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/experience`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogExperience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331111dApi - functional programming interface
 * @export
 */
export const Class331111dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331111dApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabExp(eventId, requestCollaborativeLogExperience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331111dApi.createCollabExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331111dApi - factory interface
 * @export
 */
export const Class331111dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331111dApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331111dApi - object-oriented interface
 * @export
 * @class Class331111dApi
 * @extends {BaseAPI}
 */
export class Class331111dApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Experience
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331111dApi
     */
    public createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig) {
        return Class331111dApiFp(this.configuration).createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331111eApi - axios parameter creator
 * @export
 */
export const Class331111eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp: async (eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabExp', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/experience`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogExperience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331111eApi - functional programming interface
 * @export
 */
export const Class331111eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331111eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabExp(eventId, requestCollaborativeLogExperience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331111eApi.createCollabExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331111eApi - factory interface
 * @export
 */
export const Class331111eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331111eApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331111eApi - object-oriented interface
 * @export
 * @class Class331111eApi
 * @extends {BaseAPI}
 */
export class Class331111eApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Experience
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331111eApi
     */
    public createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig) {
        return Class331111eApiFp(this.configuration).createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class33111aApi - axios parameter creator
 * @export
 */
export const Class33111aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class33111aApi - functional programming interface
 * @export
 */
export const Class33111aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class33111aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class33111aApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class33111aApi - factory interface
 * @export
 */
export const Class33111aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class33111aApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class33111aApi - object-oriented interface
 * @export
 * @class Class33111aApi
 * @extends {BaseAPI}
 */
export class Class33111aApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class33111aApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class33111aApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class33111bApi - axios parameter creator
 * @export
 */
export const Class33111bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class33111bApi - functional programming interface
 * @export
 */
export const Class33111bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class33111bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class33111bApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class33111bApi - factory interface
 * @export
 */
export const Class33111bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class33111bApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class33111bApi - object-oriented interface
 * @export
 * @class Class33111bApi
 * @extends {BaseAPI}
 */
export class Class33111bApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class33111bApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class33111bApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3311aApi - axios parameter creator
 * @export
 */
export const Class3311aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3311aApi - functional programming interface
 * @export
 */
export const Class3311aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3311aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3311aApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3311aApi - factory interface
 * @export
 */
export const Class3311aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3311aApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3311aApi - object-oriented interface
 * @export
 * @class Class3311aApi
 * @extends {BaseAPI}
 */
export class Class3311aApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3311aApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class3311aApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3311bApi - axios parameter creator
 * @export
 */
export const Class3311bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3311bApi - functional programming interface
 * @export
 */
export const Class3311bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3311bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3311bApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3311bApi - factory interface
 * @export
 */
export const Class3311bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3311bApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3311bApi - object-oriented interface
 * @export
 * @class Class3311bApi
 * @extends {BaseAPI}
 */
export class Class3311bApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3311bApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class3311bApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331aApi - axios parameter creator
 * @export
 */
export const Class331aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331aApi - functional programming interface
 * @export
 */
export const Class331aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331aApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331aApi - factory interface
 * @export
 */
export const Class331aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331aApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331aApi - object-oriented interface
 * @export
 * @class Class331aApi
 * @extends {BaseAPI}
 */
export class Class331aApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331aApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331aApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331bApi - axios parameter creator
 * @export
 */
export const Class331bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331bApi - functional programming interface
 * @export
 */
export const Class331bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331bApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331bApi - factory interface
 * @export
 */
export const Class331bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331bApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331bApi - object-oriented interface
 * @export
 * @class Class331bApi
 * @extends {BaseAPI}
 */
export class Class331bApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331bApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331bApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331cApi - axios parameter creator
 * @export
 */
export const Class331cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331cApi - functional programming interface
 * @export
 */
export const Class331cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331cApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331cApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331cApi - factory interface
 * @export
 */
export const Class331cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331cApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331cApi - object-oriented interface
 * @export
 * @class Class331cApi
 * @extends {BaseAPI}
 */
export class Class331cApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331cApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331cApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331dApi - axios parameter creator
 * @export
 */
export const Class331dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331dApi - functional programming interface
 * @export
 */
export const Class331dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331dApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331dApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331dApi - factory interface
 * @export
 */
export const Class331dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331dApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331dApi - object-oriented interface
 * @export
 * @class Class331dApi
 * @extends {BaseAPI}
 */
export class Class331dApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331dApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331dApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331eApi - axios parameter creator
 * @export
 */
export const Class331eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331eApi - functional programming interface
 * @export
 */
export const Class331eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331eApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331eApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331eApi - factory interface
 * @export
 */
export const Class331eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331eApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331eApi - object-oriented interface
 * @export
 * @class Class331eApi
 * @extends {BaseAPI}
 */
export class Class331eApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331eApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331eApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331fApi - axios parameter creator
 * @export
 */
export const Class331fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331fApi - functional programming interface
 * @export
 */
export const Class331fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331fApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331fApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331fApi - factory interface
 * @export
 */
export const Class331fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331fApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331fApi - object-oriented interface
 * @export
 * @class Class331fApi
 * @extends {BaseAPI}
 */
export class Class331fApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331fApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331fApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class331gApi - axios parameter creator
 * @export
 */
export const Class331gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class331gApi - functional programming interface
 * @export
 */
export const Class331gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class331gApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class331gApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class331gApi - factory interface
 * @export
 */
export const Class331gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class331gApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class331gApi - object-oriented interface
 * @export
 * @class Class331gApi
 * @extends {BaseAPI}
 */
export class Class331gApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class331gApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return Class331gApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class332Api - axios parameter creator
 * @export
 */
export const Class332ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class332Api - functional programming interface
 * @export
 */
export const Class332ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class332ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class332Api.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class332Api - factory interface
 * @export
 */
export const Class332ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class332ApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class332Api - object-oriented interface
 * @export
 * @class Class332Api
 * @extends {BaseAPI}
 */
export class Class332Api extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class332Api
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class332ApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3321Api - axios parameter creator
 * @export
 */
export const Class3321ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3321Api - functional programming interface
 * @export
 */
export const Class3321ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3321ApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3321Api.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3321Api - factory interface
 * @export
 */
export const Class3321ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3321ApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3321Api - object-oriented interface
 * @export
 * @class Class3321Api
 * @extends {BaseAPI}
 */
export class Class3321Api extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3321Api
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3321ApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3321aApi - axios parameter creator
 * @export
 */
export const Class3321aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3321aApi - functional programming interface
 * @export
 */
export const Class3321aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3321aApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3321aApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3321aApi - factory interface
 * @export
 */
export const Class3321aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3321aApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3321aApi - object-oriented interface
 * @export
 * @class Class3321aApi
 * @extends {BaseAPI}
 */
export class Class3321aApi extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3321aApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3321aApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3321bApi - axios parameter creator
 * @export
 */
export const Class3321bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3321bApi - functional programming interface
 * @export
 */
export const Class3321bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3321bApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3321bApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3321bApi - factory interface
 * @export
 */
export const Class3321bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3321bApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3321bApi - object-oriented interface
 * @export
 * @class Class3321bApi
 * @extends {BaseAPI}
 */
export class Class3321bApi extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3321bApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3321bApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class3321cApi - axios parameter creator
 * @export
 */
export const Class3321cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class3321cApi - functional programming interface
 * @export
 */
export const Class3321cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class3321cApiAxiosParamCreator(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class3321cApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class3321cApi - factory interface
 * @export
 */
export const Class3321cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class3321cApiFp(configuration)
    return {
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class3321cApi - object-oriented interface
 * @export
 * @class Class3321cApi
 * @extends {BaseAPI}
 */
export class Class3321cApi extends BaseAPI {
    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class3321cApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class3321cApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class332aApi - axios parameter creator
 * @export
 */
export const Class332aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class332aApi - functional programming interface
 * @export
 */
export const Class332aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class332aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class332aApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class332aApi - factory interface
 * @export
 */
export const Class332aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class332aApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class332aApi - object-oriented interface
 * @export
 * @class Class332aApi
 * @extends {BaseAPI}
 */
export class Class332aApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class332aApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return Class332aApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class34Api - axios parameter creator
 * @export
 */
export const Class34ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class34Api - functional programming interface
 * @export
 */
export const Class34ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class34ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class34Api.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class34Api - factory interface
 * @export
 */
export const Class34ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class34ApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class34Api - object-oriented interface
 * @export
 * @class Class34Api
 * @extends {BaseAPI}
 */
export class Class34Api extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class34Api
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return Class34ApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class34aApi - axios parameter creator
 * @export
 */
export const Class34aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class34aApi - functional programming interface
 * @export
 */
export const Class34aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class34aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class34aApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class34aApi - factory interface
 * @export
 */
export const Class34aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class34aApiFp(configuration)
    return {
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class34aApi - object-oriented interface
 * @export
 * @class Class34aApi
 * @extends {BaseAPI}
 */
export class Class34aApi extends BaseAPI {
    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class34aApi
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return Class34aApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class34bApi - axios parameter creator
 * @export
 */
export const Class34bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class34bApi - functional programming interface
 * @export
 */
export const Class34bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class34bApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class34bApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class34bApi - factory interface
 * @export
 */
export const Class34bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class34bApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class34bApi - object-oriented interface
 * @export
 * @class Class34bApi
 * @extends {BaseAPI}
 */
export class Class34bApi extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class34bApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return Class34bApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class34cApi - axios parameter creator
 * @export
 */
export const Class34cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class34cApi - functional programming interface
 * @export
 */
export const Class34cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class34cApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class34cApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class34cApi - factory interface
 * @export
 */
export const Class34cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class34cApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class34cApi - object-oriented interface
 * @export
 * @class Class34cApi
 * @extends {BaseAPI}
 */
export class Class34cApi extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class34cApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return Class34cApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class40Api - axios parameter creator
 * @export
 */
export const Class40ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oosa-daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class40Api - functional programming interface
 * @export
 */
export const Class40ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class40ApiAxiosParamCreator(configuration)
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserDailyVideo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserDailyVideo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class40Api.checkUserDailyVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorldStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWorldStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorldStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class40Api.getUserWorldStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class40Api - factory interface
 * @export
 */
export const Class40ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class40ApiFp(configuration)
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo(options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.checkUserDailyVideo(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserWorldStat200Response> {
            return localVarFp.getUserWorldStat(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class40Api - object-oriented interface
 * @export
 * @class Class40Api
 * @extends {BaseAPI}
 */
export class Class40Api extends BaseAPI {
    /**
     * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
     * @summary OOSA User Daily Video Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class40Api
     */
    public checkUserDailyVideo(options?: RawAxiosRequestConfig) {
        return Class40ApiFp(this.configuration).checkUserDailyVideo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve World Statistics
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class40Api
     */
    public getUserWorldStat(options?: RawAxiosRequestConfig) {
        return Class40ApiFp(this.configuration).getUserWorldStat(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class41Api - axios parameter creator
 * @export
 */
export const Class41ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class41Api - functional programming interface
 * @export
 */
export const Class41ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class41ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getNews(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<News>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNews(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class41Api.getNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class41Api - factory interface
 * @export
 */
export const Class41ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class41ApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews(options?: RawAxiosRequestConfig): AxiosPromise<Array<News>> {
            return localVarFp.getNews(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class41Api - object-oriented interface
 * @export
 * @class Class41Api
 * @extends {BaseAPI}
 */
export class Class41Api extends BaseAPI {
    /**
     * Create new event
     * @summary Retrieve News
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class41Api
     */
    public getNews(options?: RawAxiosRequestConfig) {
        return Class41ApiFp(this.configuration).getNews(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42Api - axios parameter creator
 * @export
 */
export const Class42ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42Api - functional programming interface
 * @export
 */
export const Class42ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42ApiAxiosParamCreator(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42Api.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42Api - factory interface
 * @export
 */
export const Class42ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42ApiFp(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42Api - object-oriented interface
 * @export
 * @class Class42Api
 * @extends {BaseAPI}
 */
export class Class42Api extends BaseAPI {
    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42Api
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42ApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42aApi - axios parameter creator
 * @export
 */
export const Class42aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42aApi - functional programming interface
 * @export
 */
export const Class42aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42aApiAxiosParamCreator(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42aApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42aApi - factory interface
 * @export
 */
export const Class42aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42aApiFp(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42aApi - object-oriented interface
 * @export
 * @class Class42aApi
 * @extends {BaseAPI}
 */
export class Class42aApi extends BaseAPI {
    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42aApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42aApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42bApi - axios parameter creator
 * @export
 */
export const Class42bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42bApi - functional programming interface
 * @export
 */
export const Class42bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42bApiAxiosParamCreator(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42bApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42bApi - factory interface
 * @export
 */
export const Class42bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42bApiFp(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42bApi - object-oriented interface
 * @export
 * @class Class42bApi
 * @extends {BaseAPI}
 */
export class Class42bApi extends BaseAPI {
    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42bApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42bApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42cApi - axios parameter creator
 * @export
 */
export const Class42cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42cApi - functional programming interface
 * @export
 */
export const Class42cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42cApiAxiosParamCreator(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42cApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42cApi - factory interface
 * @export
 */
export const Class42cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42cApiFp(configuration)
    return {
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42cApi - object-oriented interface
 * @export
 * @class Class42cApi
 * @extends {BaseAPI}
 */
export class Class42cApi extends BaseAPI {
    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42cApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42cApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42dApi - axios parameter creator
 * @export
 */
export const Class42dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById: async (requestUserFriend?: RequestUserFriend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFriend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42dApi - functional programming interface
 * @export
 */
export const Class42dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42dApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserFriendById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFriendById(requestUserFriend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42dApi.createUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42dApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42dApi - factory interface
 * @export
 */
export const Class42dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42dApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserFriendById200Response> {
            return localVarFp.createUserFriendById(requestUserFriend, options).then((request) => request(axios, basePath));
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42dApi - object-oriented interface
 * @export
 * @class Class42dApi
 * @extends {BaseAPI}
 */
export class Class42dApi extends BaseAPI {
    /**
     * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
     * @summary Add User Friend
     * @param {RequestUserFriend} [requestUserFriend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42dApi
     */
    public createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig) {
        return Class42dApiFp(this.configuration).createUserFriendById(requestUserFriend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42dApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42dApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42eApi - axios parameter creator
 * @export
 */
export const Class42eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById: async (requestUserFriend?: RequestUserFriend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFriend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42eApi - functional programming interface
 * @export
 */
export const Class42eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42eApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserFriendById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFriendById(requestUserFriend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42eApi.createUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42eApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42eApi - factory interface
 * @export
 */
export const Class42eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42eApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserFriendById200Response> {
            return localVarFp.createUserFriendById(requestUserFriend, options).then((request) => request(axios, basePath));
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42eApi - object-oriented interface
 * @export
 * @class Class42eApi
 * @extends {BaseAPI}
 */
export class Class42eApi extends BaseAPI {
    /**
     * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
     * @summary Add User Friend
     * @param {RequestUserFriend} [requestUserFriend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42eApi
     */
    public createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig) {
        return Class42eApiFp(this.configuration).createUserFriendById(requestUserFriend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42eApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42eApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42fApi - axios parameter creator
 * @export
 */
export const Class42fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42fApi - functional programming interface
 * @export
 */
export const Class42fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42fApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42fApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42fApi - factory interface
 * @export
 */
export const Class42fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42fApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42fApi - object-oriented interface
 * @export
 * @class Class42fApi
 * @extends {BaseAPI}
 */
export class Class42fApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42fApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42fApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42gApi - axios parameter creator
 * @export
 */
export const Class42gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42gApi - functional programming interface
 * @export
 */
export const Class42gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42gApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42gApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42gApi - factory interface
 * @export
 */
export const Class42gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42gApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42gApi - object-oriented interface
 * @export
 * @class Class42gApi
 * @extends {BaseAPI}
 */
export class Class42gApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42gApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42gApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class42hApi - axios parameter creator
 * @export
 */
export const Class42hApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class42hApi - functional programming interface
 * @export
 */
export const Class42hApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class42hApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class42hApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class42hApi - factory interface
 * @export
 */
export const Class42hApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class42hApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class42hApi - object-oriented interface
 * @export
 * @class Class42hApi
 * @extends {BaseAPI}
 */
export class Class42hApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class42hApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class42hApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class43Api - axios parameter creator
 * @export
 */
export const Class43ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel: async (feelings?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-feelings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feelings !== undefined) {
                localVarQueryParameter['feelings'] = feelings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class43Api - functional programming interface
 * @export
 */
export const Class43ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class43ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankFeel(feelings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class43Api.getRankFeel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankRewild(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankRewild(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class43Api.getRankRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class43Api - factory interface
 * @export
 */
export const Class43ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class43ApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankFeel(feelings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild(options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankRewild(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class43Api - object-oriented interface
 * @export
 * @class Class43Api
 * @extends {BaseAPI}
 */
export class Class43Api extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Ranking Feelings
     * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class43Api
     */
    public getRankFeel(feelings?: string, options?: RawAxiosRequestConfig) {
        return Class43ApiFp(this.configuration).getRankFeel(feelings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class43Api
     */
    public getRankRewild(options?: RawAxiosRequestConfig) {
        return Class43ApiFp(this.configuration).getRankRewild(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class50Api - axios parameter creator
 * @export
 */
export const Class50ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/take-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class50Api - functional programming interface
 * @export
 */
export const Class50ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class50ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class50Api.getAuthInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class50Api.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class50Api - factory interface
 * @export
 */
export const Class50ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class50ApiFp(configuration)
    return {
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getAuthInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class50Api - object-oriented interface
 * @export
 * @class Class50Api
 * @extends {BaseAPI}
 */
export class Class50Api extends BaseAPI {
    /**
     * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
     * @summary Read Authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class50Api
     */
    public getAuthInfo(options?: RawAxiosRequestConfig) {
        return Class50ApiFp(this.configuration).getAuthInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User Take Me
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class50Api
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return Class50ApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class50aApi - axios parameter creator
 * @export
 */
export const Class50aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/take-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class50aApi - functional programming interface
 * @export
 */
export const Class50aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class50aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class50aApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class50aApi - factory interface
 * @export
 */
export const Class50aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class50aApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class50aApi - object-oriented interface
 * @export
 * @class Class50aApi
 * @extends {BaseAPI}
 */
export class Class50aApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User Take Me
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class50aApi
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return Class50aApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class51Api - axios parameter creator
 * @export
 */
export const Class51ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class51Api - functional programming interface
 * @export
 */
export const Class51ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class51ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNotifications>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class51Api.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class51Api - factory interface
 * @export
 */
export const Class51ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class51ApiFp(configuration)
    return {
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserNotifications>> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class51Api - object-oriented interface
 * @export
 * @class Class51Api
 * @extends {BaseAPI}
 */
export class Class51Api extends BaseAPI {
    /**
     * Retrieve notifications
     * @summary Retrieve User Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class51Api
     */
    public getUserNotifications(options?: RawAxiosRequestConfig) {
        return Class51ApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class511Api - axios parameter creator
 * @export
 */
export const Class511ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat: async (eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('changeEventInvitationStat', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class511Api - functional programming interface
 * @export
 */
export const Class511ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class511ApiAxiosParamCreator(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEventInvitationStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class511Api.changeEventInvitationStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class511Api - factory interface
 * @export
 */
export const Class511ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class511ApiFp(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEventInvitationStat200Response> {
            return localVarFp.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class511Api - object-oriented interface
 * @export
 * @class Class511Api
 * @extends {BaseAPI}
 */
export class Class511Api extends BaseAPI {
    /**
     * Change event invitation status
     * @summary Change event invitation status
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {boolean} [applied] set true if its a join request
     * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class511Api
     */
    public changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig) {
        return Class511ApiFp(this.configuration).changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class511aApi - axios parameter creator
 * @export
 */
export const Class511aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat: async (eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('changeEventInvitationStat', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class511aApi - functional programming interface
 * @export
 */
export const Class511aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class511aApiAxiosParamCreator(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEventInvitationStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class511aApi.changeEventInvitationStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class511aApi - factory interface
 * @export
 */
export const Class511aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class511aApiFp(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEventInvitationStat200Response> {
            return localVarFp.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class511aApi - object-oriented interface
 * @export
 * @class Class511aApi
 * @extends {BaseAPI}
 */
export class Class511aApi extends BaseAPI {
    /**
     * Change event invitation status
     * @summary Change event invitation status
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {boolean} [applied] set true if its a join request
     * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class511aApi
     */
    public changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig) {
        return Class511aApiFp(this.configuration).changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class52111Api - axios parameter creator
 * @export
 */
export const Class52111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture: async (usersAvatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (usersAvatar !== undefined) { 
                localVarFormParams.append('users_avatar', usersAvatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class52111Api - functional programming interface
 * @export
 */
export const Class52111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class52111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUsePicture(usersAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class52111Api.updateAvatarUsePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class52111Api - factory interface
 * @export
 */
export const Class52111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class52111ApiFp(configuration)
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUsePicture(usersAvatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class52111Api - object-oriented interface
 * @export
 * @class Class52111Api
 * @extends {BaseAPI}
 */
export class Class52111Api extends BaseAPI {
    /**
     * Update profile picture
     * @summary Update User Profile Picture
     * @param {File} [usersAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class52111Api
     */
    public updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig) {
        return Class52111ApiFp(this.configuration).updateAvatarUsePicture(usersAvatar, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class52111aApi - axios parameter creator
 * @export
 */
export const Class52111aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture: async (usersAvatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (usersAvatar !== undefined) { 
                localVarFormParams.append('users_avatar', usersAvatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class52111aApi - functional programming interface
 * @export
 */
export const Class52111aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class52111aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUsePicture(usersAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class52111aApi.updateAvatarUsePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class52111aApi - factory interface
 * @export
 */
export const Class52111aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class52111aApiFp(configuration)
    return {
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUsePicture(usersAvatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class52111aApi - object-oriented interface
 * @export
 * @class Class52111aApi
 * @extends {BaseAPI}
 */
export class Class52111aApi extends BaseAPI {
    /**
     * Update profile picture
     * @summary Update User Profile Picture
     * @param {File} [usersAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class52111aApi
     */
    public updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig) {
        return Class52111aApiFp(this.configuration).updateAvatarUsePicture(usersAvatar, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class52112Api - axios parameter creator
 * @export
 */
export const Class52112ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault: async (requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateAvatar, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class52112Api - functional programming interface
 * @export
 */
export const Class52112ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class52112ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUseDefault(requestAuthUpdateAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class52112Api.updateAvatarUseDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class52112Api - factory interface
 * @export
 */
export const Class52112ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class52112ApiFp(configuration)
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class52112Api - object-oriented interface
 * @export
 * @class Class52112Api
 * @extends {BaseAPI}
 */
export class Class52112Api extends BaseAPI {
    /**
     * Update user avatar
     * @summary Update User Avatar
     * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class52112Api
     */
    public updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig) {
        return Class52112ApiFp(this.configuration).updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class52112aApi - axios parameter creator
 * @export
 */
export const Class52112aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault: async (requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateAvatar, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class52112aApi - functional programming interface
 * @export
 */
export const Class52112aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class52112aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUseDefault(requestAuthUpdateAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class52112aApi.updateAvatarUseDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class52112aApi - factory interface
 * @export
 */
export const Class52112aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class52112aApiFp(configuration)
    return {
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class52112aApi - object-oriented interface
 * @export
 * @class Class52112aApi
 * @extends {BaseAPI}
 */
export class Class52112aApi extends BaseAPI {
    /**
     * Update user avatar
     * @summary Update User Avatar
     * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class52112aApi
     */
    public updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig) {
        return Class52112aApiFp(this.configuration).updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212Api - axios parameter creator
 * @export
 */
export const Class5212ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212Api - functional programming interface
 * @export
 */
export const Class5212ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212Api.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212Api - factory interface
 * @export
 */
export const Class5212ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212ApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212Api - object-oriented interface
 * @export
 * @class Class5212Api
 * @extends {BaseAPI}
 */
export class Class5212Api extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212Api
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212ApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212aApi - axios parameter creator
 * @export
 */
export const Class5212aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212aApi - functional programming interface
 * @export
 */
export const Class5212aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212aApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212aApi - factory interface
 * @export
 */
export const Class5212aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212aApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212aApi - object-oriented interface
 * @export
 * @class Class5212aApi
 * @extends {BaseAPI}
 */
export class Class5212aApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212aApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212aApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212bApi - axios parameter creator
 * @export
 */
export const Class5212bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212bApi - functional programming interface
 * @export
 */
export const Class5212bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212bApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212bApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212bApi - factory interface
 * @export
 */
export const Class5212bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212bApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212bApi - object-oriented interface
 * @export
 * @class Class5212bApi
 * @extends {BaseAPI}
 */
export class Class5212bApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212bApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212bApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212cApi - axios parameter creator
 * @export
 */
export const Class5212cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212cApi - functional programming interface
 * @export
 */
export const Class5212cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212cApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212cApi - factory interface
 * @export
 */
export const Class5212cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212cApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212cApi - object-oriented interface
 * @export
 * @class Class5212cApi
 * @extends {BaseAPI}
 */
export class Class5212cApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212cApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212cApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212dApi - axios parameter creator
 * @export
 */
export const Class5212dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212dApi - functional programming interface
 * @export
 */
export const Class5212dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212dApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212dApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212dApi - factory interface
 * @export
 */
export const Class5212dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212dApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212dApi - object-oriented interface
 * @export
 * @class Class5212dApi
 * @extends {BaseAPI}
 */
export class Class5212dApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212dApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212dApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5212eApi - axios parameter creator
 * @export
 */
export const Class5212eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5212eApi - functional programming interface
 * @export
 */
export const Class5212eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5212eApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5212eApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5212eApi - factory interface
 * @export
 */
export const Class5212eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5212eApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5212eApi - object-oriented interface
 * @export
 * @class Class5212eApi
 * @extends {BaseAPI}
 */
export class Class5212eApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5212eApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5212eApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213Api - axios parameter creator
 * @export
 */
export const Class5213ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213Api - functional programming interface
 * @export
 */
export const Class5213ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213Api.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213Api - factory interface
 * @export
 */
export const Class5213ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213ApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213Api - object-oriented interface
 * @export
 * @class Class5213Api
 * @extends {BaseAPI}
 */
export class Class5213Api extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213Api
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213ApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213aApi - axios parameter creator
 * @export
 */
export const Class5213aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213aApi - functional programming interface
 * @export
 */
export const Class5213aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213aApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213aApi - factory interface
 * @export
 */
export const Class5213aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213aApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213aApi - object-oriented interface
 * @export
 * @class Class5213aApi
 * @extends {BaseAPI}
 */
export class Class5213aApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213aApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213aApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213bApi - axios parameter creator
 * @export
 */
export const Class5213bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213bApi - functional programming interface
 * @export
 */
export const Class5213bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213bApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213bApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213bApi - factory interface
 * @export
 */
export const Class5213bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213bApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213bApi - object-oriented interface
 * @export
 * @class Class5213bApi
 * @extends {BaseAPI}
 */
export class Class5213bApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213bApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213bApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213cApi - axios parameter creator
 * @export
 */
export const Class5213cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213cApi - functional programming interface
 * @export
 */
export const Class5213cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213cApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213cApi - factory interface
 * @export
 */
export const Class5213cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213cApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213cApi - object-oriented interface
 * @export
 * @class Class5213cApi
 * @extends {BaseAPI}
 */
export class Class5213cApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213cApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213cApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213dApi - axios parameter creator
 * @export
 */
export const Class5213dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213dApi - functional programming interface
 * @export
 */
export const Class5213dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213dApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213dApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213dApi - factory interface
 * @export
 */
export const Class5213dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213dApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213dApi - object-oriented interface
 * @export
 * @class Class5213dApi
 * @extends {BaseAPI}
 */
export class Class5213dApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213dApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213dApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213eApi - axios parameter creator
 * @export
 */
export const Class5213eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213eApi - functional programming interface
 * @export
 */
export const Class5213eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213eApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213eApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213eApi - factory interface
 * @export
 */
export const Class5213eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213eApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213eApi - object-oriented interface
 * @export
 * @class Class5213eApi
 * @extends {BaseAPI}
 */
export class Class5213eApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213eApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213eApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213fApi - axios parameter creator
 * @export
 */
export const Class5213fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213fApi - functional programming interface
 * @export
 */
export const Class5213fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213fApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213fApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213fApi - factory interface
 * @export
 */
export const Class5213fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213fApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213fApi - object-oriented interface
 * @export
 * @class Class5213fApi
 * @extends {BaseAPI}
 */
export class Class5213fApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213fApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213fApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5213gApi - axios parameter creator
 * @export
 */
export const Class5213gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5213gApi - functional programming interface
 * @export
 */
export const Class5213gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5213gApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5213gApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5213gApi - factory interface
 * @export
 */
export const Class5213gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5213gApiFp(configuration)
    return {
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5213gApi - object-oriented interface
 * @export
 * @class Class5213gApi
 * @extends {BaseAPI}
 */
export class Class5213gApi extends BaseAPI {
    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5213gApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return Class5213gApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215Api - axios parameter creator
 * @export
 */
export const Class5215ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215Api - functional programming interface
 * @export
 */
export const Class5215ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215Api.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215Api - factory interface
 * @export
 */
export const Class5215ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215ApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215Api - object-oriented interface
 * @export
 * @class Class5215Api
 * @extends {BaseAPI}
 */
export class Class5215Api extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215Api
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215ApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class52151Api - axios parameter creator
 * @export
 */
export const Class52151ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword: async (requestForgetPassword?: RequestForgetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class52151Api - functional programming interface
 * @export
 */
export const Class52151ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class52151ApiAxiosParamCreator(configuration)
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(requestForgetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class52151Api.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class52151Api - factory interface
 * @export
 */
export const Class52151ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class52151ApiFp(configuration)
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPassword(requestForgetPassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class52151Api - object-oriented interface
 * @export
 * @class Class52151Api
 * @extends {BaseAPI}
 */
export class Class52151Api extends BaseAPI {
    /**
     * Forget Password Request
     * @summary Forget Password
     * @param {RequestForgetPassword} [requestForgetPassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class52151Api
     */
    public forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig) {
        return Class52151ApiFp(this.configuration).forgetPassword(requestForgetPassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511Api - axios parameter creator
 * @export
 */
export const Class521511ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511Api - functional programming interface
 * @export
 */
export const Class521511ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511Api.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511Api - factory interface
 * @export
 */
export const Class521511ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511ApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511Api - object-oriented interface
 * @export
 * @class Class521511Api
 * @extends {BaseAPI}
 */
export class Class521511Api extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511Api
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511ApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511aApi - axios parameter creator
 * @export
 */
export const Class521511aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511aApi - functional programming interface
 * @export
 */
export const Class521511aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511aApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511aApi - factory interface
 * @export
 */
export const Class521511aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511aApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511aApi - object-oriented interface
 * @export
 * @class Class521511aApi
 * @extends {BaseAPI}
 */
export class Class521511aApi extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511aApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511aApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511bApi - axios parameter creator
 * @export
 */
export const Class521511bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511bApi - functional programming interface
 * @export
 */
export const Class521511bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511bApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511bApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511bApi - factory interface
 * @export
 */
export const Class521511bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511bApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511bApi - object-oriented interface
 * @export
 * @class Class521511bApi
 * @extends {BaseAPI}
 */
export class Class521511bApi extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511bApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511bApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511cApi - axios parameter creator
 * @export
 */
export const Class521511cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511cApi - functional programming interface
 * @export
 */
export const Class521511cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511cApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511cApi - factory interface
 * @export
 */
export const Class521511cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511cApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511cApi - object-oriented interface
 * @export
 * @class Class521511cApi
 * @extends {BaseAPI}
 */
export class Class521511cApi extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511cApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511cApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511dApi - axios parameter creator
 * @export
 */
export const Class521511dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511dApi - functional programming interface
 * @export
 */
export const Class521511dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511dApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511dApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511dApi - factory interface
 * @export
 */
export const Class521511dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511dApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511dApi - object-oriented interface
 * @export
 * @class Class521511dApi
 * @extends {BaseAPI}
 */
export class Class521511dApi extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511dApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511dApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class521511eApi - axios parameter creator
 * @export
 */
export const Class521511eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class521511eApi - functional programming interface
 * @export
 */
export const Class521511eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class521511eApiAxiosParamCreator(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class521511eApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class521511eApi - factory interface
 * @export
 */
export const Class521511eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class521511eApiFp(configuration)
    return {
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class521511eApi - object-oriented interface
 * @export
 * @class Class521511eApi
 * @extends {BaseAPI}
 */
export class Class521511eApi extends BaseAPI {
    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class521511eApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return Class521511eApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215aApi - axios parameter creator
 * @export
 */
export const Class5215aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215aApi - functional programming interface
 * @export
 */
export const Class5215aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215aApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215aApi - factory interface
 * @export
 */
export const Class5215aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215aApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215aApi - object-oriented interface
 * @export
 * @class Class5215aApi
 * @extends {BaseAPI}
 */
export class Class5215aApi extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215aApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215aApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215bApi - axios parameter creator
 * @export
 */
export const Class5215bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215bApi - functional programming interface
 * @export
 */
export const Class5215bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215bApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215bApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215bApi - factory interface
 * @export
 */
export const Class5215bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215bApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215bApi - object-oriented interface
 * @export
 * @class Class5215bApi
 * @extends {BaseAPI}
 */
export class Class5215bApi extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215bApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215bApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215cApi - axios parameter creator
 * @export
 */
export const Class5215cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215cApi - functional programming interface
 * @export
 */
export const Class5215cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215cApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215cApi - factory interface
 * @export
 */
export const Class5215cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215cApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215cApi - object-oriented interface
 * @export
 * @class Class5215cApi
 * @extends {BaseAPI}
 */
export class Class5215cApi extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215cApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215cApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215dApi - axios parameter creator
 * @export
 */
export const Class5215dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215dApi - functional programming interface
 * @export
 */
export const Class5215dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215dApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215dApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215dApi - factory interface
 * @export
 */
export const Class5215dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215dApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215dApi - object-oriented interface
 * @export
 * @class Class5215dApi
 * @extends {BaseAPI}
 */
export class Class5215dApi extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215dApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215dApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5215eApi - axios parameter creator
 * @export
 */
export const Class5215eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5215eApi - functional programming interface
 * @export
 */
export const Class5215eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5215eApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5215eApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5215eApi - factory interface
 * @export
 */
export const Class5215eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5215eApiFp(configuration)
    return {
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5215eApi - object-oriented interface
 * @export
 * @class Class5215eApi
 * @extends {BaseAPI}
 */
export class Class5215eApi extends BaseAPI {
    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5215eApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return Class5215eApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5216Api - axios parameter creator
 * @export
 */
export const Class5216ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5216Api - functional programming interface
 * @export
 */
export const Class5216ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5216ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5216Api.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5216Api - factory interface
 * @export
 */
export const Class5216ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5216ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5216Api - object-oriented interface
 * @export
 * @class Class5216Api
 * @extends {BaseAPI}
 */
export class Class5216Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5216Api
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return Class5216ApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5216aApi - axios parameter creator
 * @export
 */
export const Class5216aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5216aApi - functional programming interface
 * @export
 */
export const Class5216aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5216aApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5216aApi.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5216aApi - factory interface
 * @export
 */
export const Class5216aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5216aApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5216aApi - object-oriented interface
 * @export
 * @class Class5216aApi
 * @extends {BaseAPI}
 */
export class Class5216aApi extends BaseAPI {
    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class5216aApi
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return Class5216aApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class522Api - axios parameter creator
 * @export
 */
export const Class522ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet: async (requestAuthUpdateSetting?: RequestAuthUpdateSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class522Api - functional programming interface
 * @export
 */
export const Class522ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class522ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSet(requestAuthUpdateSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class522Api.updateUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class522Api - factory interface
 * @export
 */
export const Class522ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class522ApiFp(configuration)
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserSet(requestAuthUpdateSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class522Api - object-oriented interface
 * @export
 * @class Class522Api
 * @extends {BaseAPI}
 */
export class Class522Api extends BaseAPI {
    /**
     * Update settings<br/>1 - True (On)<br />0 - False (Off)
     * @summary Update User Setting
     * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class522Api
     */
    public updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig) {
        return Class522ApiFp(this.configuration).updateUserSet(requestAuthUpdateSetting, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class522aApi - axios parameter creator
 * @export
 */
export const Class522aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet: async (requestAuthUpdateSetting?: RequestAuthUpdateSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class522aApi - functional programming interface
 * @export
 */
export const Class522aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class522aApiAxiosParamCreator(configuration)
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSet(requestAuthUpdateSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class522aApi.updateUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class522aApi - factory interface
 * @export
 */
export const Class522aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class522aApiFp(configuration)
    return {
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserSet(requestAuthUpdateSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class522aApi - object-oriented interface
 * @export
 * @class Class522aApi
 * @extends {BaseAPI}
 */
export class Class522aApi extends BaseAPI {
    /**
     * Update settings<br/>1 - True (On)<br />0 - False (Off)
     * @summary Update User Setting
     * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class522aApi
     */
    public updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig) {
        return Class522aApiFp(this.configuration).updateUserSet(requestAuthUpdateSetting, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class525Api - axios parameter creator
 * @export
 */
export const Class525ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class525Api - functional programming interface
 * @export
 */
export const Class525ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class525ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class525Api.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class525Api - factory interface
 * @export
 */
export const Class525ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class525ApiFp(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class525Api - object-oriented interface
 * @export
 * @class Class525Api
 * @extends {BaseAPI}
 */
export class Class525Api extends BaseAPI {
    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class525Api
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return Class525ApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class5251Api - axios parameter creator
 * @export
 */
export const Class5251ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class5251Api - functional programming interface
 * @export
 */
export const Class5251ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class5251ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class5251Api.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class5251Api - factory interface
 * @export
 */
export const Class5251ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class5251ApiFp(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class5251Api - object-oriented interface
 * @export
 * @class Class5251Api
 * @extends {BaseAPI}
 */
export class Class5251Api extends BaseAPI {
    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class5251Api
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return Class5251ApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class525aApi - axios parameter creator
 * @export
 */
export const Class525aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class525aApi - functional programming interface
 * @export
 */
export const Class525aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class525aApiAxiosParamCreator(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class525aApi.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class525aApi - factory interface
 * @export
 */
export const Class525aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class525aApiFp(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class525aApi - object-oriented interface
 * @export
 * @class Class525aApi
 * @extends {BaseAPI}
 */
export class Class525aApi extends BaseAPI {
    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class525aApi
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return Class525aApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class525bApi - axios parameter creator
 * @export
 */
export const Class525bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class525bApi - functional programming interface
 * @export
 */
export const Class525bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class525bApiAxiosParamCreator(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class525bApi.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class525bApi - factory interface
 * @export
 */
export const Class525bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class525bApiFp(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class525bApi - object-oriented interface
 * @export
 * @class Class525bApi
 * @extends {BaseAPI}
 */
export class Class525bApi extends BaseAPI {
    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class525bApi
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return Class525bApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class53Api - axios parameter creator
 * @export
 */
export const Class53ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations: async (applied?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class53Api - functional programming interface
 * @export
 */
export const Class53ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class53ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventsInvitations(applied, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class53Api.getAllEventsInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class53Api - factory interface
 * @export
 */
export const Class53ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class53ApiFp(configuration)
    return {
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>> {
            return localVarFp.getAllEventsInvitations(applied, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class53Api - object-oriented interface
 * @export
 * @class Class53Api
 * @extends {BaseAPI}
 */
export class Class53Api extends BaseAPI {
    /**
     * Retrieve all event invitations
     * @summary Retrieve all event invitations
     * @param {boolean} [applied] Pass true to retrieve applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class53Api
     */
    public getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig) {
        return Class53ApiFp(this.configuration).getAllEventsInvitations(applied, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class531Api - axios parameter creator
 * @export
 */
export const Class531ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class531Api - functional programming interface
 * @export
 */
export const Class531ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class531ApiAxiosParamCreator(configuration)
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class531Api.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class531Api - factory interface
 * @export
 */
export const Class531ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class531ApiFp(configuration)
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class531Api - object-oriented interface
 * @export
 * @class Class531Api
 * @extends {BaseAPI}
 */
export class Class531Api extends BaseAPI {
    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class531Api
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return Class531ApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class531aApi - axios parameter creator
 * @export
 */
export const Class531aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class531aApi - functional programming interface
 * @export
 */
export const Class531aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class531aApiAxiosParamCreator(configuration)
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class531aApi.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class531aApi - factory interface
 * @export
 */
export const Class531aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class531aApiFp(configuration)
    return {
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class531aApi - object-oriented interface
 * @export
 * @class Class531aApi
 * @extends {BaseAPI}
 */
export class Class531aApi extends BaseAPI {
    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class531aApi
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return Class531aApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class54Api - axios parameter creator
 * @export
 */
export const Class54ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class54Api - functional programming interface
 * @export
 */
export const Class54ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class54ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class54Api.getUserStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class54Api.getUserStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class54Api - factory interface
 * @export
 */
export const Class54ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class54ApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserStat200Response> {
            return localVarFp.getUserStat(options).then((request) => request(axios, basePath));
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserStatistics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class54Api - object-oriented interface
 * @export
 * @class Class54Api
 * @extends {BaseAPI}
 */
export class Class54Api extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class54Api
     */
    public getUserStat(options?: RawAxiosRequestConfig) {
        return Class54ApiFp(this.configuration).getUserStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get my statistics
     * @summary Auth Statistics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Class54Api
     */
    public getUserStatistics(options?: RawAxiosRequestConfig) {
        return Class54ApiFp(this.configuration).getUserStatistics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Class55Api - axios parameter creator
 * @export
 */
export const Class55ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class55Api - functional programming interface
 * @export
 */
export const Class55ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Class55ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Class55Api.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Class55Api - factory interface
 * @export
 */
export const Class55ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Class55ApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class55Api - object-oriented interface
 * @export
 * @class Class55Api
 * @extends {BaseAPI}
 */
export class Class55Api extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class55Api
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return Class55ApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactUsApi - axios parameter creator
 * @export
 */
export const ContactUsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactUsApi - functional programming interface
 * @export
 */
export const ContactUsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactUsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactUsApi.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactUsApi - factory interface
 * @export
 */
export const ContactUsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactUsApiFp(configuration)
    return {
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContactUsApi - object-oriented interface
 * @export
 * @class ContactUsApi
 * @extends {BaseAPI}
 */
export class ContactUsApi extends BaseAPI {
    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactUsApi
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return ContactUsApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate cookies and anti-CSRF measures required for browser-based flows.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter `?refresh=true` was set.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_already_available`: The user is already signed in. `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  The optional query parameter login_challenge is set when using Kratos with Hydra in an OAuth2 flow. See the oauth2_provider.url configuration option.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 初始登入流程(取得flowId)
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserLoginFlow: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/login/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 建立瀏覽器註冊流程
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserRegistrationFlow: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/registration/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 建立通知
         * @summary Create notification
         * @param {CreateNotificationRequest} [createNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (createNotificationRequest?: CreateNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNotificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Badge
         * @param {string} userBadgeId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBadgeById: async (userBadgeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userBadgeId' is not null or undefined
            assertParamExists('getBadgeById', 'userBadgeId', userBadgeId)
            const localVarPath = `/auth/badges/{userBadgeId}`
                .replace(`{${"userBadgeId"}}`, encodeURIComponent(String(userBadgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a login flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/login\', async function (req, res) { const flow = await client.getLoginFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'login\', flow) }) ```  This request may fail due to several reasons. The `error.id` can be one of:  `session_already_available`: The user is already signed in. `self_service_flow_expired`: The flow is expired and you should request a new one.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 取得登入流程所需要的資訊(csrf_token)
         * @param {string} [id] The Login Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/login?flow&#x3D;abcde&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginFlow: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/login/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 取得Registration Flow
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationFlow: async (id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/registration/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read User Notification
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        isReadNotificationById: async (notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('isReadNotificationById', 'notificationId', notificationId)
            const localVarPath = `/auth/notifications/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 登入
         * @param {string} [flow] 
         * @param {Oauth2LoginRequest} [oauth2LoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2Login: async (flow?: string, oauth2LoginRequest?: Oauth2LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauth2LoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 註冊使用者
         * @param {string} [flow] 
         * @param {RegistrationByEmailFlowRequest} [registrationByEmailFlowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationByEmailFlow: async (flow?: string, registrationByEmailFlowRequest?: RegistrationByEmailFlowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationByEmailFlowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get photo url from google
         * @param {string} placeId 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildingPlacesPlaceIdPhotosPhotoIdGet: async (placeId: string, photoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('rewildingPlacesPlaceIdPhotosPhotoIdGet', 'placeId', placeId)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('rewildingPlacesPlaceIdPhotosPhotoIdGet', 'photoId', photoId)
            const localVarPath = `/rewilding/places/{placeId}/photos/{photoId}`
                .replace(`{${"placeId"}}`, encodeURIComponent(String(placeId)))
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 「精華行程」建立
         * @summary Untitled Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary OIDC call back
         * @param {SelfServiceMethodsOidcCallbackProviderGetProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfServiceMethodsOidcCallbackProviderGet: async (provider: SelfServiceMethodsOidcCallbackProviderGetProviderEnum, code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('selfServiceMethodsOidcCallbackProviderGet', 'provider', provider)
            const localVarPath = `/self-service/methods/oidc/callback/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary OIDC call back (Apple)
         * @param {SelfServiceMethodsOidcCallbackProviderPostProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfServiceMethodsOidcCallbackProviderPost: async (provider: SelfServiceMethodsOidcCallbackProviderPostProviderEnum, code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('selfServiceMethodsOidcCallbackProviderPost', 'provider', provider)
            const localVarPath = `/self-service/methods/oidc/callback/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated. Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent. When the request it successful it adds the user ID to the \'X-Kratos-Authenticated-Identity-Id\' header in the response.  If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:  ```js pseudo-code example router.get(\'/protected-endpoint\', async function (req, res) { const session = await client.toSession(undefined, req.header(\'cookie\'))  console.log(session) }) ```  When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\")  console.log(session) ```  When using a token template, the token is included in the `tokenized` field of the session.  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\", { tokenize_as: \"example-jwt-template\" })  console.log(session.tokenized) // The JWT ```  Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  This endpoint is useful for:  AJAX calls. Remember to send credentials and set up CORS correctly! Reverse proxies and API Gateways Server-side calls - use the `X-Session-Token` header!  This endpoint authenticates users by checking:  if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie; if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token; if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.  If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.  As explained above, this request may fail due to several reasons. The `error.id` can be one of:  `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token). `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
         * @summary Check Who the Current HTTP Session Belongs To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sessions/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自動完成 (新版)
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesAutocompletePostRequest} [v1PlacesAutocompletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesAutocompletePost: async (xGoogApiKey?: string, v1PlacesAutocompletePostRequest?: V1PlacesAutocompletePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/places:autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xGoogApiKey != null) {
                localVarHeaderParameter['X-Goog-Api-Key'] = String(xGoogApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PlacesAutocompletePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 搜尋附近地點 (新)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchNearbyPostRequest} [v1PlacesSearchNearbyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesSearchNearbyPost: async (xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchNearbyPostRequest?: V1PlacesSearchNearbyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/places:searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xGoogFieldMask != null) {
                localVarHeaderParameter['X-Goog-FieldMask'] = String(xGoogFieldMask);
            }
            if (xGoogApiKey != null) {
                localVarHeaderParameter['X-Goog-Api-Key'] = String(xGoogApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PlacesSearchNearbyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Text Search (新版)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchTextPostRequest} [v1PlacesSearchTextPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesSearchTextPost: async (xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchTextPostRequest?: V1PlacesSearchTextPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/places:searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xGoogFieldMask != null) {
                localVarHeaderParameter['X-Goog-FieldMask'] = String(xGoogFieldMask);
            }
            if (xGoogApiKey != null) {
                localVarHeaderParameter['X-Goog-Api-Key'] = String(xGoogApiKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v1PlacesSearchTextPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate cookies and anti-CSRF measures required for browser-based flows.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter `?refresh=true` was set.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_already_available`: The user is already signed in. `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  The optional query parameter login_challenge is set when using Kratos with Hydra in an OAuth2 flow. See the oauth2_provider.url configuration option.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 初始登入流程(取得flowId)
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserLoginFlow(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserLoginFlow(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createBrowserLoginFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 建立瀏覽器註冊流程
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserRegistrationFlow(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserRegistrationFlow(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createBrowserRegistrationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 建立通知
         * @summary Create notification
         * @param {CreateNotificationRequest} [createNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(createNotificationRequest?: CreateNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(createNotificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Badge
         * @param {string} userBadgeId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getBadgeById(userBadgeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBadgeById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadgeById(userBadgeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBadgeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a login flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/login\', async function (req, res) { const flow = await client.getLoginFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'login\', flow) }) ```  This request may fail due to several reasons. The `error.id` can be one of:  `session_already_available`: The user is already signed in. `self_service_flow_expired`: The flow is expired and you should request a new one.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 取得登入流程所需要的資訊(csrf_token)
         * @param {string} [id] The Login Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/login?flow&#x3D;abcde&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoginFlow(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginFlow1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoginFlow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLoginFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 取得Registration Flow
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationFlow(id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegistrationFlow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRegistrationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read User Notification
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async isReadNotificationById(notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isReadNotificationById(notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.isReadNotificationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 登入
         * @param {string} [flow] 
         * @param {Oauth2LoginRequest} [oauth2LoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauth2Login(flow?: string, oauth2LoginRequest?: Oauth2LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Oauth2Login200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauth2Login(flow, oauth2LoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.oauth2Login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 註冊使用者
         * @param {string} [flow] 
         * @param {RegistrationByEmailFlowRequest} [registrationByEmailFlowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registrationByEmailFlow(flow?: string, registrationByEmailFlowRequest?: RegistrationByEmailFlowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registrationByEmailFlow(flow, registrationByEmailFlowRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.registrationByEmailFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get photo url from google
         * @param {string} placeId 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId: string, photoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId, photoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rewildingPlacesPlaceIdPhotosPhotoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 「精華行程」建立
         * @summary Untitled Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary OIDC call back
         * @param {SelfServiceMethodsOidcCallbackProviderGetProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selfServiceMethodsOidcCallbackProviderGet(provider: SelfServiceMethodsOidcCallbackProviderGetProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selfServiceMethodsOidcCallbackProviderGet(provider, code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.selfServiceMethodsOidcCallbackProviderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary OIDC call back (Apple)
         * @param {SelfServiceMethodsOidcCallbackProviderPostProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selfServiceMethodsOidcCallbackProviderPost(provider: SelfServiceMethodsOidcCallbackProviderPostProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selfServiceMethodsOidcCallbackProviderPost(provider, code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.selfServiceMethodsOidcCallbackProviderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated. Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent. When the request it successful it adds the user ID to the \'X-Kratos-Authenticated-Identity-Id\' header in the response.  If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:  ```js pseudo-code example router.get(\'/protected-endpoint\', async function (req, res) { const session = await client.toSession(undefined, req.header(\'cookie\'))  console.log(session) }) ```  When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\")  console.log(session) ```  When using a token template, the token is included in the `tokenized` field of the session.  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\", { tokenize_as: \"example-jwt-template\" })  console.log(session.tokenized) // The JWT ```  Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  This endpoint is useful for:  AJAX calls. Remember to send credentials and set up CORS correctly! Reverse proxies and API Gateways Server-side calls - use the `X-Session-Token` header!  This endpoint authenticates users by checking:  if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie; if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token; if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.  If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.  As explained above, this request may fail due to several reasons. The `error.id` can be one of:  `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token). `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
         * @summary Check Who the Current HTTP Session Belongs To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.toSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 自動完成 (新版)
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesAutocompletePostRequest} [v1PlacesAutocompletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlacesAutocompletePost(xGoogApiKey?: string, v1PlacesAutocompletePostRequest?: V1PlacesAutocompletePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlacesAutocompletePost(xGoogApiKey, v1PlacesAutocompletePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1PlacesAutocompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 搜尋附近地點 (新)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchNearbyPostRequest} [v1PlacesSearchNearbyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlacesSearchNearbyPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchNearbyPostRequest?: V1PlacesSearchNearbyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlacesSearchNearbyPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchNearbyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1PlacesSearchNearbyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Text Search (新版)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchTextPostRequest} [v1PlacesSearchTextPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlacesSearchTextPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchTextPostRequest?: V1PlacesSearchTextPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlacesSearchTextPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchTextPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.v1PlacesSearchTextPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate cookies and anti-CSRF measures required for browser-based flows.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter `?refresh=true` was set.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_already_available`: The user is already signed in. `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  The optional query parameter login_challenge is set when using Kratos with Hydra in an OAuth2 flow. See the oauth2_provider.url configuration option.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 初始登入流程(取得flowId)
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserLoginFlow(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<LoginFlow> {
            return localVarFp.createBrowserLoginFlow(returnTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 建立瀏覽器註冊流程
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserRegistrationFlow(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createBrowserRegistrationFlow(returnTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 建立通知
         * @summary Create notification
         * @param {CreateNotificationRequest} [createNotificationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(createNotificationRequest?: CreateNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createNotification(createNotificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Badge
         * @param {string} userBadgeId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getBadgeById(userBadgeId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBadgeById200Response> {
            return localVarFp.getBadgeById(userBadgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a login flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/login\', async function (req, res) { const flow = await client.getLoginFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'login\', flow) }) ```  This request may fail due to several reasons. The `error.id` can be one of:  `session_already_available`: The user is already signed in. `self_service_flow_expired`: The flow is expired and you should request a new one.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
         * @summary 取得登入流程所需要的資訊(csrf_token)
         * @param {string} [id] The Login Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/login?flow&#x3D;abcde&#x60;).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoginFlow(id?: string, options?: RawAxiosRequestConfig): AxiosPromise<LoginFlow1> {
            return localVarFp.getLoginFlow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 取得Registration Flow
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationFlow(id?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getRegistrationFlow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read User Notification
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        isReadNotificationById(notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.isReadNotificationById(notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 登入
         * @param {string} [flow] 
         * @param {Oauth2LoginRequest} [oauth2LoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2Login(flow?: string, oauth2LoginRequest?: Oauth2LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<Oauth2Login200Response> {
            return localVarFp.oauth2Login(flow, oauth2LoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 註冊使用者
         * @param {string} [flow] 
         * @param {RegistrationByEmailFlowRequest} [registrationByEmailFlowRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrationByEmailFlow(flow?: string, registrationByEmailFlowRequest?: RegistrationByEmailFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.registrationByEmailFlow(flow, registrationByEmailFlowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get photo url from google
         * @param {string} placeId 
         * @param {string} photoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId: string, photoId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId, photoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 「精華行程」建立
         * @summary Untitled Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary OIDC call back
         * @param {SelfServiceMethodsOidcCallbackProviderGetProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfServiceMethodsOidcCallbackProviderGet(provider: SelfServiceMethodsOidcCallbackProviderGetProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.selfServiceMethodsOidcCallbackProviderGet(provider, code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary OIDC call back (Apple)
         * @param {SelfServiceMethodsOidcCallbackProviderPostProviderEnum} provider 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfServiceMethodsOidcCallbackProviderPost(provider: SelfServiceMethodsOidcCallbackProviderPostProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.selfServiceMethodsOidcCallbackProviderPost(provider, code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated. Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent. When the request it successful it adds the user ID to the \'X-Kratos-Authenticated-Identity-Id\' header in the response.  If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:  ```js pseudo-code example router.get(\'/protected-endpoint\', async function (req, res) { const session = await client.toSession(undefined, req.header(\'cookie\'))  console.log(session) }) ```  When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\")  console.log(session) ```  When using a token template, the token is included in the `tokenized` field of the session.  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\", { tokenize_as: \"example-jwt-template\" })  console.log(session.tokenized) // The JWT ```  Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  This endpoint is useful for:  AJAX calls. Remember to send credentials and set up CORS correctly! Reverse proxies and API Gateways Server-side calls - use the `X-Session-Token` header!  This endpoint authenticates users by checking:  if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie; if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token; if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.  If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.  As explained above, this request may fail due to several reasons. The `error.id` can be one of:  `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token). `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
         * @summary Check Who the Current HTTP Session Belongs To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toSession(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.toSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自動完成 (新版)
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesAutocompletePostRequest} [v1PlacesAutocompletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesAutocompletePost(xGoogApiKey?: string, v1PlacesAutocompletePostRequest?: V1PlacesAutocompletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1PlacesAutocompletePost(xGoogApiKey, v1PlacesAutocompletePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 搜尋附近地點 (新)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchNearbyPostRequest} [v1PlacesSearchNearbyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesSearchNearbyPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchNearbyPostRequest?: V1PlacesSearchNearbyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1PlacesSearchNearbyPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchNearbyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Text Search (新版)
         * @param {string} [xGoogFieldMask] 
         * @param {string} [xGoogApiKey] 
         * @param {V1PlacesSearchTextPostRequest} [v1PlacesSearchTextPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlacesSearchTextPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchTextPostRequest?: V1PlacesSearchTextPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.v1PlacesSearchTextPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchTextPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * This endpoint initializes a browser-based user login flow. This endpoint will set the appropriate cookies and anti-CSRF measures required for browser-based flows.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter `?refresh=true` was set.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_already_available`: The user is already signed in. `session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  The optional query parameter login_challenge is set when using Kratos with Hydra in an OAuth2 flow. See the oauth2_provider.url configuration option.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
     * @summary 初始登入流程(取得flowId)
     * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBrowserLoginFlow(returnTo?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBrowserLoginFlow(returnTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 建立瀏覽器註冊流程
     * @param {string} [returnTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBrowserRegistrationFlow(returnTo?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createBrowserRegistrationFlow(returnTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 建立通知
     * @summary Create notification
     * @param {CreateNotificationRequest} [createNotificationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNotification(createNotificationRequest?: CreateNotificationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createNotification(createNotificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Badge
     * @param {string} userBadgeId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getBadgeById(userBadgeId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBadgeById(userBadgeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a login flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/login\', async function (req, res) { const flow = await client.getLoginFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'login\', flow) }) ```  This request may fail due to several reasons. The `error.id` can be one of:  `session_already_available`: The user is already signed in. `self_service_flow_expired`: The flow is expired and you should request a new one.  More information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).
     * @summary 取得登入流程所需要的資訊(csrf_token)
     * @param {string} [id] The Login Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/login?flow&#x3D;abcde&#x60;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLoginFlow(id?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLoginFlow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 取得Registration Flow
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRegistrationFlow(id?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRegistrationFlow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read User Notification
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isReadNotificationById(notificationId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isReadNotificationById(notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 登入
     * @param {string} [flow] 
     * @param {Oauth2LoginRequest} [oauth2LoginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2Login(flow?: string, oauth2LoginRequest?: Oauth2LoginRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).oauth2Login(flow, oauth2LoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 註冊使用者
     * @param {string} [flow] 
     * @param {RegistrationByEmailFlowRequest} [registrationByEmailFlowRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registrationByEmailFlow(flow?: string, registrationByEmailFlowRequest?: RegistrationByEmailFlowRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registrationByEmailFlow(flow, registrationByEmailFlowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get photo url from google
     * @param {string} placeId 
     * @param {string} photoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId: string, photoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rewildingPlacesPlaceIdPhotosPhotoIdGet(placeId, photoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 「精華行程」建立
     * @summary Untitled Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary OIDC call back
     * @param {SelfServiceMethodsOidcCallbackProviderGetProviderEnum} provider 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public selfServiceMethodsOidcCallbackProviderGet(provider: SelfServiceMethodsOidcCallbackProviderGetProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).selfServiceMethodsOidcCallbackProviderGet(provider, code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary OIDC call back (Apple)
     * @param {SelfServiceMethodsOidcCallbackProviderPostProviderEnum} provider 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public selfServiceMethodsOidcCallbackProviderPost(provider: SelfServiceMethodsOidcCallbackProviderPostProviderEnum, code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).selfServiceMethodsOidcCallbackProviderPost(provider, code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated. Returns a session object in the body or 401 if the credentials are invalid or no credentials were sent. When the request it successful it adds the user ID to the \'X-Kratos-Authenticated-Identity-Id\' header in the response.  If you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:  ```js pseudo-code example router.get(\'/protected-endpoint\', async function (req, res) { const session = await client.toSession(undefined, req.header(\'cookie\'))  console.log(session) }) ```  When calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\")  console.log(session) ```  When using a token template, the token is included in the `tokenized` field of the session.  ```js pseudo-code example ... const session = await client.toSession(\"the-session-token\", { tokenize_as: \"example-jwt-template\" })  console.log(session.tokenized) // The JWT ```  Depending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  This endpoint is useful for:  AJAX calls. Remember to send credentials and set up CORS correctly! Reverse proxies and API Gateways Server-side calls - use the `X-Session-Token` header!  This endpoint authenticates users by checking:  if the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie; if the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token; if the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.  If none of these headers are set or the cookie or token are invalid, the endpoint returns a HTTP 401 status code.  As explained above, this request may fail due to several reasons. The `error.id` can be one of:  `session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token). `session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.
     * @summary Check Who the Current HTTP Session Belongs To
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public toSession(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).toSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自動完成 (新版)
     * @param {string} [xGoogApiKey] 
     * @param {V1PlacesAutocompletePostRequest} [v1PlacesAutocompletePostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1PlacesAutocompletePost(xGoogApiKey?: string, v1PlacesAutocompletePostRequest?: V1PlacesAutocompletePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1PlacesAutocompletePost(xGoogApiKey, v1PlacesAutocompletePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 搜尋附近地點 (新)
     * @param {string} [xGoogFieldMask] 
     * @param {string} [xGoogApiKey] 
     * @param {V1PlacesSearchNearbyPostRequest} [v1PlacesSearchNearbyPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1PlacesSearchNearbyPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchNearbyPostRequest?: V1PlacesSearchNearbyPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1PlacesSearchNearbyPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchNearbyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Text Search (新版)
     * @param {string} [xGoogFieldMask] 
     * @param {string} [xGoogApiKey] 
     * @param {V1PlacesSearchTextPostRequest} [v1PlacesSearchTextPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public v1PlacesSearchTextPost(xGoogFieldMask?: string, xGoogApiKey?: string, v1PlacesSearchTextPostRequest?: V1PlacesSearchTextPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).v1PlacesSearchTextPost(xGoogFieldMask, xGoogApiKey, v1PlacesSearchTextPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SelfServiceMethodsOidcCallbackProviderGetProviderEnum = {
    Line: 'line',
    Google: 'google',
    Apple: 'apple'
} as const;
export type SelfServiceMethodsOidcCallbackProviderGetProviderEnum = typeof SelfServiceMethodsOidcCallbackProviderGetProviderEnum[keyof typeof SelfServiceMethodsOidcCallbackProviderGetProviderEnum];
/**
 * @export
 */
export const SelfServiceMethodsOidcCallbackProviderPostProviderEnum = {
    Line: 'line',
    Google: 'google',
    Apple: 'apple'
} as const;
export type SelfServiceMethodsOidcCallbackProviderPostProviderEnum = typeof SelfServiceMethodsOidcCallbackProviderPostProviderEnum[keyof typeof SelfServiceMethodsOidcCallbackProviderPostProviderEnum];


/**
 * E1Api - axios parameter creator
 * @export
 */
export const E1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccountings', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventByEventId', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E1Api - functional programming interface
 * @export
 */
export const E1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccountings(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventAccountings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMessageBoard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMessageBoard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventReferenceLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventReferenceLink(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1Api.getEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E1Api - factory interface
 * @export
 */
export const E1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E1ApiFp(configuration)
    return {
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.getEventAccountings(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.getEventByEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventMessageBoard>> {
            return localVarFp.getEventMessageBoard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventReferenceLinks>> {
            return localVarFp.getEventReferenceLink(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.getEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E1Api - object-oriented interface
 * @export
 * @class E1Api
 * @extends {BaseAPI}
 */
export class E1Api extends BaseAPI {
    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Retrieve Event Accounting
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventAccountings(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventAccountings(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read an Event
     * @summary Read Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventByEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventByEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Retrieve Event Message Board
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventMessageBoard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Retrieve Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventReferenceLink(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s schedule
     * @summary Retrieve Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1Api
     */
    public getEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return E1ApiFp(this.configuration).getEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E11Api - axios parameter creator
 * @export
 */
export const E11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('updateEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('updateEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('updateEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('updateEvent', 'eventsName', eventsName)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E11Api - functional programming interface
 * @export
 */
export const E11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E11ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E11Api.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E11Api - factory interface
 * @export
 */
export const E11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E11ApiFp(configuration)
    return {
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E11Api - object-oriented interface
 * @export
 * @class E11Api
 * @extends {BaseAPI}
 */
export class E11Api extends BaseAPI {
    /**
     * Update an event
     * @summary Update Event
     * @param {string} eventId 
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E11Api
     */
    public updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return E11ApiFp(this.configuration).updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12Api - axios parameter creator
 * @export
 */
export const E12ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12Api - functional programming interface
 * @export
 */
export const E12ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12Api.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12Api - factory interface
 * @export
 */
export const E12ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12ApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12Api - object-oriented interface
 * @export
 * @class E12Api
 * @extends {BaseAPI}
 */
export class E12Api extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12Api
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E12ApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E121Api - axios parameter creator
 * @export
 */
export const E121ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E121Api - functional programming interface
 * @export
 */
export const E121ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E121ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E121Api.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E121Api - factory interface
 * @export
 */
export const E121ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E121ApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E121Api - object-oriented interface
 * @export
 * @class E121Api
 * @extends {BaseAPI}
 */
export class E121Api extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E121Api
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E121ApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E1211Api - axios parameter creator
 * @export
 */
export const E1211ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E1211Api - functional programming interface
 * @export
 */
export const E1211ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E1211ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E1211Api.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E1211Api - factory interface
 * @export
 */
export const E1211ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E1211ApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E1211Api - object-oriented interface
 * @export
 * @class E1211Api
 * @extends {BaseAPI}
 */
export class E1211Api extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E1211Api
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E1211ApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12111Api - axios parameter creator
 * @export
 */
export const E12111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12111Api - functional programming interface
 * @export
 */
export const E12111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111Api.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111Api.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111Api.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12111Api - factory interface
 * @export
 */
export const E12111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12111ApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12111Api - object-oriented interface
 * @export
 * @class E12111Api
 * @extends {BaseAPI}
 */
export class E12111Api extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111Api
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111ApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111Api
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111ApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111Api
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E12111ApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E121111Api - axios parameter creator
 * @export
 */
export const E121111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant: async (eventId: string, requestEventParticipant?: RequestEventParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E121111Api - functional programming interface
 * @export
 */
export const E121111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E121111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEventParticipant200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventParticipant(eventId, requestEventParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E121111Api.createEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E121111Api - factory interface
 * @export
 */
export const E121111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E121111ApiFp(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEventParticipant200ResponseInner>> {
            return localVarFp.createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E121111Api - object-oriented interface
 * @export
 * @class E121111Api
 * @extends {BaseAPI}
 */
export class E121111Api extends BaseAPI {
    /**
     * Invite a participant to event
     * @summary Create Event Participant
     * @param {string} eventId String ID of the event
     * @param {RequestEventParticipant} [requestEventParticipant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E121111Api
     */
    public createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig) {
        return E121111ApiFp(this.configuration).createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12111aApi - axios parameter creator
 * @export
 */
export const E12111aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12111aApi - functional programming interface
 * @export
 */
export const E12111aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12111aApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111aApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111aApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12111aApi - factory interface
 * @export
 */
export const E12111aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12111aApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12111aApi - object-oriented interface
 * @export
 * @class E12111aApi
 * @extends {BaseAPI}
 */
export class E12111aApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111aApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111aApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111aApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111aApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12111bApi - axios parameter creator
 * @export
 */
export const E12111bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12111bApi - functional programming interface
 * @export
 */
export const E12111bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12111bApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111bApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111bApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12111bApi - factory interface
 * @export
 */
export const E12111bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12111bApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12111bApi - object-oriented interface
 * @export
 * @class E12111bApi
 * @extends {BaseAPI}
 */
export class E12111bApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111bApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111bApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111bApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111bApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12111cApi - axios parameter creator
 * @export
 */
export const E12111cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12111cApi - functional programming interface
 * @export
 */
export const E12111cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12111cApiAxiosParamCreator(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111cApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111cApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12111cApi - factory interface
 * @export
 */
export const E12111cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12111cApiFp(configuration)
    return {
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12111cApi - object-oriented interface
 * @export
 * @class E12111cApi
 * @extends {BaseAPI}
 */
export class E12111cApi extends BaseAPI {
    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111cApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111cApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111cApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return E12111cApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E12111dApi - axios parameter creator
 * @export
 */
export const E12111dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant: async (eventId: string, requestEventParticipant?: RequestEventParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E12111dApi - functional programming interface
 * @export
 */
export const E12111dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E12111dApiAxiosParamCreator(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEventParticipant200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventParticipant(eventId, requestEventParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E12111dApi.createEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E12111dApi - factory interface
 * @export
 */
export const E12111dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E12111dApiFp(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEventParticipant200ResponseInner>> {
            return localVarFp.createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E12111dApi - object-oriented interface
 * @export
 * @class E12111dApi
 * @extends {BaseAPI}
 */
export class E12111dApi extends BaseAPI {
    /**
     * Invite a participant to event
     * @summary Create Event Participant
     * @param {string} eventId String ID of the event
     * @param {RequestEventParticipant} [requestEventParticipant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E12111dApi
     */
    public createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig) {
        return E12111dApiFp(this.configuration).createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E121aApi - axios parameter creator
 * @export
 */
export const E121aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E121aApi - functional programming interface
 * @export
 */
export const E121aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E121aApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E121aApi.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E121aApi - factory interface
 * @export
 */
export const E121aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E121aApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E121aApi - object-oriented interface
 * @export
 * @class E121aApi
 * @extends {BaseAPI}
 */
export class E121aApi extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E121aApi
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E121aApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E121bApi - axios parameter creator
 * @export
 */
export const E121bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E121bApi - functional programming interface
 * @export
 */
export const E121bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E121bApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E121bApi.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E121bApi - factory interface
 * @export
 */
export const E121bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E121bApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E121bApi - object-oriented interface
 * @export
 * @class E121bApi
 * @extends {BaseAPI}
 */
export class E121bApi extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E121bApi
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return E121bApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E14Api - axios parameter creator
 * @export
 */
export const E14ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink: async (eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventReferenceLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E14Api - functional programming interface
 * @export
 */
export const E14ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E14ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinksSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReferenceLink(eventId, requestEventReferenceLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E14Api.createReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E14Api - factory interface
 * @export
 */
export const E14ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E14ApiFp(configuration)
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinksSimple> {
            return localVarFp.createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E14Api - object-oriented interface
 * @export
 * @class E14Api
 * @extends {BaseAPI}
 */
export class E14Api extends BaseAPI {
    /**
     * Create an event\'s reference links
     * @summary Create Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E14Api
     */
    public createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig) {
        return E14ApiFp(this.configuration).createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E15Api - axios parameter creator
 * @export
 */
export const E15ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule: async (eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E15Api - functional programming interface
 * @export
 */
export const E15ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E15ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchedule(eventId, createEventScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E15Api.createEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E15Api - factory interface
 * @export
 */
export const E15ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E15ApiFp(configuration)
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E15Api - object-oriented interface
 * @export
 * @class E15Api
 * @extends {BaseAPI}
 */
export class E15Api extends BaseAPI {
    /**
     * Create an event\'s schedule
     * @summary Create Event Schedule
     * @param {string} eventId String ID of the event
     * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E15Api
     */
    public createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig) {
        return E15ApiFp(this.configuration).createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E16Api - axios parameter creator
 * @export
 */
export const E16ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard: async (eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E16Api - functional programming interface
 * @export
 */
export const E16ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E16ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageBoard(eventId, requestEventMessageBoard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E16Api.createMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E16Api - factory interface
 * @export
 */
export const E16ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E16ApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E16Api - object-oriented interface
 * @export
 * @class E16Api
 * @extends {BaseAPI}
 */
export class E16Api extends BaseAPI {
    /**
     * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
     * @summary Create Event Message Board
     * @param {string} eventId String ID of the event
     * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E16Api
     */
    public createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig) {
        return E16ApiFp(this.configuration).createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E17Api - axios parameter creator
 * @export
 */
export const E17ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting: async (eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAccounting', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E17Api - functional programming interface
 * @export
 */
export const E17ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E17ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAccounting(eventId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E17Api.createEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E17Api - factory interface
 * @export
 */
export const E17ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E17ApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E17Api - object-oriented interface
 * @export
 * @class E17Api
 * @extends {BaseAPI}
 */
export class E17Api extends BaseAPI {
    /**
     * Create an entry on event\'s accounting
     * @summary Create Event Accounting
     * @param {string} eventId String ID of the event
     * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E17Api
     */
    public createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig) {
        return E17ApiFp(this.configuration).createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E18Api - axios parameter creator
 * @export
 */
export const E18ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E18Api - functional programming interface
 * @export
 */
export const E18ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E18ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E18Api.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E18Api - factory interface
 * @export
 */
export const E18ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E18ApiFp(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E18Api - object-oriented interface
 * @export
 * @class E18Api
 * @extends {BaseAPI}
 */
export class E18Api extends BaseAPI {
    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E18Api
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return E18ApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E181Api - axios parameter creator
 * @export
 */
export const E181ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E181Api - functional programming interface
 * @export
 */
export const E181ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E181ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E181Api.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E181Api - factory interface
 * @export
 */
export const E181ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E181ApiFp(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E181Api - object-oriented interface
 * @export
 * @class E181Api
 * @extends {BaseAPI}
 */
export class E181Api extends BaseAPI {
    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E181Api
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return E181ApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * E18aApi - axios parameter creator
 * @export
 */
export const E18aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * E18aApi - functional programming interface
 * @export
 */
export const E18aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = E18aApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['E18aApi.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * E18aApi - factory interface
 * @export
 */
export const E18aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = E18aApiFp(configuration)
    return {
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * E18aApi - object-oriented interface
 * @export
 * @class E18aApi
 * @extends {BaseAPI}
 */
export class E18aApi extends BaseAPI {
    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof E18aApi
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return E18aApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EEventApi - axios parameter creator
 * @export
 */
export const EEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting: async (eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAccounting', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce: async (eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnnouncementEventAnnouncementInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant: async (eventId: string, requestEventParticipant?: RequestEventParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule: async (eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard: async (eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink: async (eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventReferenceLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccountings', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce: async (eventId: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventByEventId', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo: async (requestLinkQuery?: RequestLinkQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/link-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestLinkQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('updateEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('updateEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('updateEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('updateEvent', 'eventsName', eventsName)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EEventApi - functional programming interface
 * @export
 */
export const EEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EEventApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAccounting(eventId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEventParticipant200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventParticipant(eventId, requestEventParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchedule(eventId, createEventScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageBoard(eventId, requestEventMessageBoard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinksSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReferenceLink(eventId, requestEventReferenceLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.createReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccountings(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventAccountings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAnnounce(eventId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMessageBoard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMessageBoard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventReferenceLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventReferenceLink(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrlInfo(requestLinkQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getUrlInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EEventApi.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EEventApi - factory interface
 * @export
 */
export const EEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EEventApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEventParticipant200ResponseInner>> {
            return localVarFp.createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinksSimple> {
            return localVarFp.createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.getEventAccountings(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.getEventAnnounce(eventId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.getEventByEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventMessageBoard>> {
            return localVarFp.getEventMessageBoard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventReferenceLinks>> {
            return localVarFp.getEventReferenceLink(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.getEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): AxiosPromise<LinkQuery> {
            return localVarFp.getUrlInfo(requestLinkQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EEventApi - object-oriented interface
 * @export
 * @class EEventApi
 * @extends {BaseAPI}
 */
export class EEventApi extends BaseAPI {
    /**
     * Create an entry on event\'s accounting
     * @summary Create Event Accounting
     * @param {string} eventId String ID of the event
     * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an entry on event\'s announcement 
     * @summary Create Event Announcement
     * @param {string} eventId String ID of the event
     * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a participant to event
     * @summary Create Event Participant
     * @param {string} eventId String ID of the event
     * @param {RequestEventParticipant} [requestEventParticipant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event\'s schedule
     * @summary Create Event Schedule
     * @param {string} eventId String ID of the event
     * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
     * @summary Create Event Message Board
     * @param {string} eventId String ID of the event
     * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event\'s reference links
     * @summary Create Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Retrieve Event Accounting
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventAccountings(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventAccountings(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s announcement
     * @summary Retrieve Event Announcement
     * @param {string} eventId String ID of the event
     * @param {string} [category] For filter category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventAnnounce(eventId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read an Event
     * @summary Read Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventByEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventByEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Retrieve Event Message Board
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventMessageBoard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Retrieve Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventReferenceLink(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s schedule
     * @summary Retrieve Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Query
     * @param {RequestLinkQuery} [requestLinkQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getUrlInfo(requestLinkQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event
     * @summary Update Event
     * @param {string} eventId 
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EEventApi
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return EEventApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNews: async (requestNews?: RequestNews, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestNews, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEvent', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage: async (imagename: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagename' is not null or undefined
            assertParamExists('getCoverImage', 'imagename', imagename)
            const localVarPath = `/event/cover/{imagename}`
                .replace(`{${"imagename"}}`, encodeURIComponent(String(imagename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventByEventId', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('updateEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('updateEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('updateEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('updateEvent', 'eventsName', eventsName)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNews(requestNews, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.createNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsDeleted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements_1(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getAchievements_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoverImage(imagename: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoverImage(imagename, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getCoverImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getEventByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getNews(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<News>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNews(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.getNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig): AxiosPromise<CreateNews200Response> {
            return localVarFp.createNews(requestNews, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventsDeleted> {
            return localVarFp.deleteEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements_1(achievementType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage(imagename: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCoverImage(imagename, options).then((request) => request(axios, basePath));
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.getEventByEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews(options?: RawAxiosRequestConfig): AxiosPromise<Array<News>> {
            return localVarFp.getNews(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Create News
     * @param {RequestNews} [requestNews] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).createNews(requestNews, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event
     * @summary Delete Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public deleteEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).deleteEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getAchievements_1(achievementType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Cover Image
     * @param {string} imagename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getCoverImage(imagename: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getCoverImage(imagename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read an Event
     * @summary Read Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventByEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventByEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Retrieve News
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getNews(options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).getNews(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event
     * @summary Update Event
     * @param {string} eventId 
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventAccountingApi - axios parameter creator
 * @export
 */
export const EventAccountingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting: async (eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAccounting', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAccounting: async (eventId: string, accountingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('deleteEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccounting: async (eventId: string, accountingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('getEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccountings', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAccounting: async (eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('updateEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventAccountingApi - functional programming interface
 * @export
 */
export const EventAccountingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventAccountingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAccounting(eventId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAccountingApi.createEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventAccounting(eventId, accountingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAccountingApi.deleteEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAccountingSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccounting(eventId, accountingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAccountingApi.getEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccountings(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAccountingApi.getEventAccountings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAccountingSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventAccounting(eventId, accountingId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAccountingApi.updateEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventAccountingApi - factory interface
 * @export
 */
export const EventAccountingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventAccountingApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventAccounting(eventId, accountingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventAccountingSingle> {
            return localVarFp.getEventAccounting(eventId, accountingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.getEventAccountings(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig): AxiosPromise<EventAccountingSingle> {
            return localVarFp.updateEventAccounting(eventId, accountingId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventAccountingApi - object-oriented interface
 * @export
 * @class EventAccountingApi
 * @extends {BaseAPI}
 */
export class EventAccountingApi extends BaseAPI {
    /**
     * Create an entry on event\'s accounting
     * @summary Create Event Accounting
     * @param {string} eventId String ID of the event
     * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAccountingApi
     */
    public createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig) {
        return EventAccountingApiFp(this.configuration).createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entry on event\'s accounting
     * @summary Delete Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId String ID of the accounting record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAccountingApi
     */
    public deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig) {
        return EventAccountingApiFp(this.configuration).deleteEventAccounting(eventId, accountingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Read Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAccountingApi
     */
    public getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig) {
        return EventAccountingApiFp(this.configuration).getEventAccounting(eventId, accountingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Retrieve Event Accounting
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAccountingApi
     */
    public getEventAccountings(eventId: string, options?: RawAxiosRequestConfig) {
        return EventAccountingApiFp(this.configuration).getEventAccountings(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Update Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId 
     * @param {RequestEventAccounting} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAccountingApi
     */
    public updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig) {
        return EventAccountingApiFp(this.configuration).updateEventAccounting(eventId, accountingId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventAnnouncementApi - axios parameter creator
 * @export
 */
export const EventAnnouncementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce: async (eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnnouncementEventAnnouncementInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce: async (eventId: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventAnnouncementApi - functional programming interface
 * @export
 */
export const EventAnnouncementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventAnnouncementApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAnnouncementApi.createEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAnnounce(eventId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventAnnouncementApi.getEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventAnnouncementApi - factory interface
 * @export
 */
export const EventAnnouncementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventAnnouncementApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.getEventAnnounce(eventId, category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventAnnouncementApi - object-oriented interface
 * @export
 * @class EventAnnouncementApi
 * @extends {BaseAPI}
 */
export class EventAnnouncementApi extends BaseAPI {
    /**
     * Create an entry on event\'s announcement 
     * @summary Create Event Announcement
     * @param {string} eventId String ID of the event
     * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAnnouncementApi
     */
    public createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig) {
        return EventAnnouncementApiFp(this.configuration).createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s announcement
     * @summary Retrieve Event Announcement
     * @param {string} eventId String ID of the event
     * @param {string} [category] For filter category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventAnnouncementApi
     */
    public getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig) {
        return EventAnnouncementApiFp(this.configuration).getEventAnnounce(eventId, category, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventCollaborateApi - axios parameter creator
 * @export
 */
export const EventCollaborateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp: async (eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabExp', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/experience`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogExperience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCollaborativeAlbumLinks', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs: async (rewildingId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rewildingId !== undefined) {
                localVarQueryParameter['rewilding_id'] = rewildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPolaroids', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventCollaborateApi - functional programming interface
 * @export
 */
export const EventCollaborateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventCollaborateApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabExp(eventId, requestCollaborativeLogExperience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.createCollabExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAlbumLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeAlbumLinks(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.getCollaborativeAlbumLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeLogs(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.getCollaborativeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolaroids(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPolaroids200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolaroids(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.getPolaroids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventCollaborateApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventCollaborateApi - factory interface
 * @export
 */
export const EventCollaborateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventCollaborateApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAlbumLink>> {
            return localVarFp.getCollaborativeAlbumLinks(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getCollaborativeLogs(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPolaroids200ResponseInner>> {
            return localVarFp.getPolaroids(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventCollaborateApi - object-oriented interface
 * @export
 * @class EventCollaborateApi
 * @extends {BaseAPI}
 */
export class EventCollaborateApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Experience
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Retrieve Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).getCollaborativeAlbumLinks(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve events that has ended
     * @summary Event Collaborate
     * @param {string} [rewildingId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).getCollaborativeLogs(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve event polaroid
     * @summary Retrieve Polaroid
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public getPolaroids(eventId: string, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).getPolaroids(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventCollaborateApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return EventCollaborateApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventInvitationApi - axios parameter creator
 * @export
 */
export const EventInvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat: async (eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('changeEventInvitationStat', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations: async (applied?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventInvitationApi - functional programming interface
 * @export
 */
export const EventInvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventInvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEventInvitationStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventInvitationApi.changeEventInvitationStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventsInvitations(applied, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventInvitationApi.getAllEventsInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventInvitationApi.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventInvitationApi - factory interface
 * @export
 */
export const EventInvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventInvitationApiFp(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEventInvitationStat200Response> {
            return localVarFp.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>> {
            return localVarFp.getAllEventsInvitations(applied, options).then((request) => request(axios, basePath));
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventInvitationApi - object-oriented interface
 * @export
 * @class EventInvitationApi
 * @extends {BaseAPI}
 */
export class EventInvitationApi extends BaseAPI {
    /**
     * Change event invitation status
     * @summary Change event invitation status
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {boolean} [applied] set true if its a join request
     * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventInvitationApi
     */
    public changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig) {
        return EventInvitationApiFp(this.configuration).changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all event invitations
     * @summary Retrieve all event invitations
     * @param {boolean} [applied] Pass true to retrieve applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventInvitationApi
     */
    public getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig) {
        return EventInvitationApiFp(this.configuration).getAllEventsInvitations(applied, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventInvitationApi
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return EventInvitationApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventInvitationDetailApi - axios parameter creator
 * @export
 */
export const EventInvitationDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventInvitationDetailApi - functional programming interface
 * @export
 */
export const EventInvitationDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventInvitationDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventInvitationDetailApi.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventInvitationDetailApi.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventInvitationDetailApi - factory interface
 * @export
 */
export const EventInvitationDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventInvitationDetailApiFp(configuration)
    return {
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventInvitationDetailApi - object-oriented interface
 * @export
 * @class EventInvitationDetailApi
 * @extends {BaseAPI}
 */
export class EventInvitationDetailApi extends BaseAPI {
    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventInvitationDetailApi
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return EventInvitationDetailApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventInvitationDetailApi
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return EventInvitationDetailApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventMessageBoardApi - axios parameter creator
 * @export
 */
export const EventMessageBoardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard: async (eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('deleteMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('getMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessageBoard: async (eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('pinMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('pinMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}/pin`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoardPin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('updateMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventMessageBoardApi - functional programming interface
 * @export
 */
export const EventMessageBoardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventMessageBoardApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageBoard(eventId, requestEventMessageBoard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.createMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.deleteMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMessageBoard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMessageBoard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.getEventMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.getMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.pinMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventMessageBoardApi.updateMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventMessageBoardApi - factory interface
 * @export
 */
export const EventMessageBoardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventMessageBoardApiFp(configuration)
    return {
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventMessageBoard>> {
            return localVarFp.getEventMessageBoard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.getMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.updateMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventMessageBoardApi - object-oriented interface
 * @export
 * @class EventMessageBoardApi
 * @extends {BaseAPI}
 */
export class EventMessageBoardApi extends BaseAPI {
    /**
     * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
     * @summary Create Event Message Board
     * @param {string} eventId String ID of the event
     * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entry on event\'s message board
     * @summary Delete message board entry
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId String ID of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).deleteMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Retrieve Event Message Board
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).getEventMessageBoard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Read Event Message Board
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).getMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Pin Event Message Board 
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Update Event Message Board
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventMessageBoardApi
     */
    public updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return EventMessageBoardApiFp(this.configuration).updateMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventParticipantsApi - axios parameter creator
 * @export
 */
export const EventParticipantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant: async (eventId: string, requestEventParticipant?: RequestEventParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventParticipant: async (eventId: string, participantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventParticipant', 'eventId', eventId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('deleteEventParticipant', 'participantId', participantId)
            const localVarPath = `/event/{eventId}/participants/{participantId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventParticipantsApi - functional programming interface
 * @export
 */
export const EventParticipantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventParticipantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEventParticipant200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventParticipant(eventId, requestEventParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventParticipantsApi.createEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventParticipant(eventId, participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventParticipantsApi.deleteEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventParticipantsApi.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventParticipantsApi - factory interface
 * @export
 */
export const EventParticipantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventParticipantsApiFp(configuration)
    return {
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEventParticipant200ResponseInner>> {
            return localVarFp.createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventParticipant(eventId, participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventParticipantsApi - object-oriented interface
 * @export
 * @class EventParticipantsApi
 * @extends {BaseAPI}
 */
export class EventParticipantsApi extends BaseAPI {
    /**
     * Invite a participant to event
     * @summary Create Event Participant
     * @param {string} eventId String ID of the event
     * @param {RequestEventParticipant} [requestEventParticipant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantsApi
     */
    public createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig) {
        return EventParticipantsApiFp(this.configuration).createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a participant from an event
     * @summary Delete Event Participant
     * @param {string} eventId String ID of the event
     * @param {string} participantId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantsApi
     */
    public deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig) {
        return EventParticipantsApiFp(this.configuration).deleteEventParticipant(eventId, participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventParticipantsApi
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return EventParticipantsApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventReferenceLinksApi - axios parameter creator
 * @export
 */
export const EventReferenceLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink: async (eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventReferenceLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('deleteReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('getReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('updateReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventReferenceLinksApi - functional programming interface
 * @export
 */
export const EventReferenceLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventReferenceLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinksSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReferenceLink(eventId, requestEventReferenceLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventReferenceLinksApi.createReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventReferenceLinksApi.deleteReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventReferenceLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventReferenceLink(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventReferenceLinksApi.getEventReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventReferenceLinksApi.getReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventReferenceLinksApi.updateReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventReferenceLinksApi - factory interface
 * @export
 */
export const EventReferenceLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventReferenceLinksApiFp(configuration)
    return {
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinksSimple> {
            return localVarFp.createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventReferenceLinks>> {
            return localVarFp.getEventReferenceLink(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinks> {
            return localVarFp.getReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinks> {
            return localVarFp.updateReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventReferenceLinksApi - object-oriented interface
 * @export
 * @class EventReferenceLinksApi
 * @extends {BaseAPI}
 */
export class EventReferenceLinksApi extends BaseAPI {
    /**
     * Create an event\'s reference links
     * @summary Create Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventReferenceLinksApi
     */
    public createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig) {
        return EventReferenceLinksApiFp(this.configuration).createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s reference links
     * @summary Delete Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId String ID of the reference link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventReferenceLinksApi
     */
    public deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return EventReferenceLinksApiFp(this.configuration).deleteReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Retrieve Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventReferenceLinksApi
     */
    public getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig) {
        return EventReferenceLinksApiFp(this.configuration).getEventReferenceLink(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Read Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventReferenceLinksApi
     */
    public getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return EventReferenceLinksApiFp(this.configuration).getReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Update Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventReferenceLinksApi
     */
    public updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return EventReferenceLinksApiFp(this.configuration).updateReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventScheduleApi - axios parameter creator
 * @export
 */
export const EventScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule: async (eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdDelete: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdDelete', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdGet: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdGet', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdPut: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdPut', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdPut', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventScheduleApi - functional programming interface
 * @export
 */
export const EventScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchedule(eventId, createEventScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.createEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.deleteEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.eventEventIdScheduleScheduleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchedules>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.eventEventIdScheduleScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchedules>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.eventEventIdScheduleScheduleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventScheduleApi.getEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventScheduleApi - factory interface
 * @export
 */
export const EventScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventScheduleApiFp(configuration)
    return {
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventSchedules> {
            return localVarFp.eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventSchedules> {
            return localVarFp.eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.getEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventScheduleApi - object-oriented interface
 * @export
 * @class EventScheduleApi
 * @extends {BaseAPI}
 */
export class EventScheduleApi extends BaseAPI {
    /**
     * Create an event\'s schedule
     * @summary Create Event Schedule
     * @param {string} eventId String ID of the event
     * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Delete Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).deleteEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Delete Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Read Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Update Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s schedule
     * @summary Retrieve Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventScheduleApi
     */
    public getEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return EventScheduleApiFp(this.configuration).getEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ForgetPasswordApi - axios parameter creator
 * @export
 */
export const ForgetPasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword: async (requestForgetPassword?: RequestForgetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForgetPasswordApi - functional programming interface
 * @export
 */
export const ForgetPasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ForgetPasswordApiAxiosParamCreator(configuration)
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(requestForgetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForgetPasswordApi.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForgetPasswordApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ForgetPasswordApi - factory interface
 * @export
 */
export const ForgetPasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ForgetPasswordApiFp(configuration)
    return {
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPassword(requestForgetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ForgetPasswordApi - object-oriented interface
 * @export
 * @class ForgetPasswordApi
 * @extends {BaseAPI}
 */
export class ForgetPasswordApi extends BaseAPI {
    /**
     * Forget Password Request
     * @summary Forget Password
     * @param {RequestForgetPassword} [requestForgetPassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ForgetPasswordApi
     */
    public forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig) {
        return ForgetPasswordApiFp(this.configuration).forgetPassword(requestForgetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ForgetPasswordApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return ForgetPasswordApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FrontendApi - axios parameter creator
 * @export
 */
export const FrontendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns a 401 error.  When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
         * @summary Create a Logout URL for Browsers
         * @param {string} [returnTo] Return to URL  The URL to which the browser should be redirected to after the logout has been performed.
         * @param {string} [cookie] HTTP Cookies  If you call this endpoint from a backend, please include the original Cookie header in the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserLogoutFlow: async (returnTo?: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/logout/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            if (cookie != null) {
                localVarHeaderParameter['cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists, the browser is returned to the configured return URL.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects or a 400 bad request error if the user is already authenticated.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Create Recovery Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserRecoveryFlow: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/recovery/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid Ory Kratos Session Cookie is included in the request, a login flow will be initialized.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session was set, the browser will be redirected to the login endpoint.  If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects or a 401 forbidden error if no valid session was set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Create Settings Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserSettingsFlow: async (returnTo?: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/settings/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Create Verification Flow for Browser Clients
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserVerificationFlow: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/verification/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow With Link
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [code] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompleteVerificationFlow: async (flow: string, code?: string, cookie?: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flow' is not null or undefined
            assertParamExists('getCompleteVerificationFlow', 'flow', flow)
            const localVarPath = `/self-service/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the error associated with a user-facing self service errors.  This endpoint supports stub values to help you implement the error UI:  `?id=stub:500` - returns a stub 500 (Internal Server Error) error.  More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
         * @summary Get User-Flow Errors
         * @param {string} id Error is the error\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowError: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFlowError', 'id', id)
            const localVarPath = `/self-service/errors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a recovery flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getRecoveryFlow(req.header(\'Cookie\'), req.query[\'flow\'])  res.render(\'recovery\', flow) }) ```  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Get Recovery Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecoveryFlow: async (id: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRecoveryFlow', 'id', id)
            const localVarPath = `/self-service/recovery/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When accessing this endpoint through Ory Kratos\' Public API you must ensure that either the Ory Kratos Session Cookie or the Ory Kratos Session Token are set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  You can access this endpoint without credentials when using Ory Kratos\' Admin API.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Get Settings Flow
         * @param {string} id ID is the Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token  When using the SDK in an app without a browser, please include the session token here.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsFlow: async (id: string, xSessionToken?: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSettingsFlow', 'id', id)
            const localVarPath = `/self-service/settings/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a verification flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getVerificationFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'verification\', flow) }) ```  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Get Verification Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK on the server side you must include the HTTP Cookie Header originally sent to your HTTP handler here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationFlow: async (id: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVerificationFlow', 'id', id)
            const localVarPath = `/self-service/verification/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            if (cookie != null) {
                localVarHeaderParameter['cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint logs out an identity in a self-service manner.  If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other) to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.  If the `Accept` HTTP header is set to `application/json`, a 204 No Content response will be sent on successful logout instead.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
         * @summary Update Logout Flow
         * @param {string} [token] A Valid Logout Token  If you do not have a logout token because you only have a session cookie, call &#x60;/self-service/logout/browser&#x60; to generate a URL for this endpoint.
         * @param {string} [returnTo] The URL to return to after the logout was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogoutFlow: async (token?: string, returnTo?: string, cookie?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/self-service/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a recovery flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid. and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended. `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a recovery link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with a new Recovery Flow ID which contains an error message that the recovery link was invalid.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Update Recovery Flow
         * @param {string} flow The Recovery Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Recovery Token  The recovery token which completes the recovery request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoveryFlow: async (flow: string, token?: string, cookie?: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flow' is not null or undefined
            assertParamExists('updateRecoveryFlow', 'flow', flow)
            const localVarPath = `/self-service/recovery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to complete a settings flow by sending an identity\'s updated password. This endpoint behaves differently for API and browser flows.  API-initiated flows expect `application/json` to be sent in the body and respond with HTTP 200 and an application/json body with the session token on success; HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set; HTTP 400 on form validation errors. HTTP 401 when the endpoint is called without a valid session token. HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low. Implies that the user needs to re-authenticate.  Browser flows without HTTP Header `Accept` or with `Accept: text/_*` respond with a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded; a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise. a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low.  Browser flows with HTTP Header `Accept: application/json` respond with HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success; HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set; HTTP 401 when the endpoint is called without a valid session cookie. HTTP 403 when the page is accessed without a session cookie or the session\'s AAL is too low. HTTP 400 on form validation errors.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`, or initiate a refresh login flow otherwise. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration! `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL. Most likely used in Social Sign In flows.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Complete Settings Flow
         * @param {string} flow The Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token of the Identity performing the settings flow.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettingsFlow: async (flow: string, xSessionToken?: string, cookie?: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flow' is not null or undefined
            assertParamExists('updateSettingsFlow', 'flow', flow)
            const localVarPath = `/self-service/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVerificationFlow: async (flow: string, token?: string, cookie?: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flow' is not null or undefined
            assertParamExists('updateVerificationFlow', 'flow', flow)
            const localVarPath = `/self-service/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (flow !== undefined) {
                localVarQueryParameter['flow'] = flow;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (cookie != null) {
                localVarHeaderParameter['Cookie'] = String(cookie);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontendApi - functional programming interface
 * @export
 */
export const FrontendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontendApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns a 401 error.  When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
         * @summary Create a Logout URL for Browsers
         * @param {string} [returnTo] Return to URL  The URL to which the browser should be redirected to after the logout has been performed.
         * @param {string} [cookie] HTTP Cookies  If you call this endpoint from a backend, please include the original Cookie header in the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserLogoutFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserLogoutFlow(returnTo, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.createBrowserLogoutFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists, the browser is returned to the configured return URL.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects or a 400 bad request error if the user is already authenticated.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Create Recovery Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserRecoveryFlow(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoveryFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserRecoveryFlow(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.createBrowserRecoveryFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid Ory Kratos Session Cookie is included in the request, a login flow will be initialized.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session was set, the browser will be redirected to the login endpoint.  If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects or a 401 forbidden error if no valid session was set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Create Settings Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserSettingsFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserSettingsFlow(returnTo, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.createBrowserSettingsFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Create Verification Flow for Browser Clients
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowserVerificationFlow(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowserVerificationFlow(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.createBrowserVerificationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow With Link
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [code] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompleteVerificationFlow(flow: string, code?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompleteVerificationFlow(flow, code, cookie, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.getCompleteVerificationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns the error associated with a user-facing self service errors.  This endpoint supports stub values to help you implement the error UI:  `?id=stub:500` - returns a stub 500 (Internal Server Error) error.  More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
         * @summary Get User-Flow Errors
         * @param {string} id Error is the error\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlowError(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlowError(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.getFlowError']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a recovery flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getRecoveryFlow(req.header(\'Cookie\'), req.query[\'flow\'])  res.render(\'recovery\', flow) }) ```  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Get Recovery Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecoveryFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoveryFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecoveryFlow(id, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.getRecoveryFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * When accessing this endpoint through Ory Kratos\' Public API you must ensure that either the Ory Kratos Session Cookie or the Ory Kratos Session Token are set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  You can access this endpoint without credentials when using Ory Kratos\' Admin API.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Get Settings Flow
         * @param {string} id ID is the Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token  When using the SDK in an app without a browser, please include the session token here.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingsFlow(id: string, xSessionToken?: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsFlow(id, xSessionToken, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.getSettingsFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a verification flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getVerificationFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'verification\', flow) }) ```  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Get Verification Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK on the server side you must include the HTTP Cookie Header originally sent to your HTTP handler here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationFlow(id, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.getVerificationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint logs out an identity in a self-service manner.  If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other) to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.  If the `Accept` HTTP header is set to `application/json`, a 204 No Content response will be sent on successful logout instead.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
         * @summary Update Logout Flow
         * @param {string} [token] A Valid Logout Token  If you do not have a logout token because you only have a session cookie, call &#x60;/self-service/logout/browser&#x60; to generate a URL for this endpoint.
         * @param {string} [returnTo] The URL to return to after the logout was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLogoutFlow(token?: string, returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorGeneric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLogoutFlow(token, returnTo, cookie, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.updateLogoutFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update a recovery flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid. and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended. `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a recovery link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with a new Recovery Flow ID which contains an error message that the recovery link was invalid.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Update Recovery Flow
         * @param {string} flow The Recovery Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Recovery Token  The recovery token which completes the recovery request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecoveryFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoveryFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecoveryFlow(flow, token, cookie, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.updateRecoveryFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to complete a settings flow by sending an identity\'s updated password. This endpoint behaves differently for API and browser flows.  API-initiated flows expect `application/json` to be sent in the body and respond with HTTP 200 and an application/json body with the session token on success; HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set; HTTP 400 on form validation errors. HTTP 401 when the endpoint is called without a valid session token. HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low. Implies that the user needs to re-authenticate.  Browser flows without HTTP Header `Accept` or with `Accept: text/_*` respond with a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded; a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise. a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low.  Browser flows with HTTP Header `Accept: application/json` respond with HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success; HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set; HTTP 401 when the endpoint is called without a valid session cookie. HTTP 403 when the page is accessed without a session cookie or the session\'s AAL is too low. HTTP 400 on form validation errors.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`, or initiate a refresh login flow otherwise. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration! `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL. Most likely used in Social Sign In flows.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Complete Settings Flow
         * @param {string} flow The Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token of the Identity performing the settings flow.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettingsFlow(flow: string, xSessionToken?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettingsFlow(flow, xSessionToken, cookie, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.updateSettingsFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVerificationFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVerificationFlow(flow, token, cookie, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontendApi.updateVerificationFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FrontendApi - factory interface
 * @export
 */
export const FrontendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontendApiFp(configuration)
    return {
        /**
         * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns a 401 error.  When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
         * @summary Create a Logout URL for Browsers
         * @param {string} [returnTo] Return to URL  The URL to which the browser should be redirected to after the logout has been performed.
         * @param {string} [cookie] HTTP Cookies  If you call this endpoint from a backend, please include the original Cookie header in the request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserLogoutFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<LogoutFlow> {
            return localVarFp.createBrowserLogoutFlow(returnTo, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists, the browser is returned to the configured return URL.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects or a 400 bad request error if the user is already authenticated.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Create Recovery Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserRecoveryFlow(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecoveryFlow> {
            return localVarFp.createBrowserRecoveryFlow(returnTo, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid Ory Kratos Session Cookie is included in the request, a login flow will be initialized.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session was set, the browser will be redirected to the login endpoint.  If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects or a 401 forbidden error if no valid session was set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Create Settings Flow for Browsers
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserSettingsFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<SettingsFlow> {
            return localVarFp.createBrowserSettingsFlow(returnTo, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Create Verification Flow for Browser Clients
         * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowserVerificationFlow(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<VerificationFlow> {
            return localVarFp.createBrowserVerificationFlow(returnTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow With Link
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [code] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompleteVerificationFlow(flow: string, code?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<VerificationFlow> {
            return localVarFp.getCompleteVerificationFlow(flow, code, cookie, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the error associated with a user-facing self service errors.  This endpoint supports stub values to help you implement the error UI:  `?id=stub:500` - returns a stub 500 (Internal Server Error) error.  More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
         * @summary Get User-Flow Errors
         * @param {string} id Error is the error\&#39;s ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlowError(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FlowError> {
            return localVarFp.getFlowError(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a recovery flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getRecoveryFlow(req.header(\'Cookie\'), req.query[\'flow\'])  res.render(\'recovery\', flow) }) ```  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Get Recovery Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecoveryFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecoveryFlow> {
            return localVarFp.getRecoveryFlow(id, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * When accessing this endpoint through Ory Kratos\' Public API you must ensure that either the Ory Kratos Session Cookie or the Ory Kratos Session Token are set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  You can access this endpoint without credentials when using Ory Kratos\' Admin API.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Get Settings Flow
         * @param {string} id ID is the Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token  When using the SDK in an app without a browser, please include the session token here.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsFlow(id: string, xSessionToken?: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<SettingsFlow> {
            return localVarFp.getSettingsFlow(id, xSessionToken, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a verification flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getVerificationFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'verification\', flow) }) ```  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Get Verification Flow
         * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [cookie] HTTP Cookies  When using the SDK on the server side you must include the HTTP Cookie Header originally sent to your HTTP handler here.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<VerificationFlow> {
            return localVarFp.getVerificationFlow(id, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint logs out an identity in a self-service manner.  If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other) to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.  If the `Accept` HTTP header is set to `application/json`, a 204 No Content response will be sent on successful logout instead.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
         * @summary Update Logout Flow
         * @param {string} [token] A Valid Logout Token  If you do not have a logout token because you only have a session cookie, call &#x60;/self-service/logout/browser&#x60; to generate a URL for this endpoint.
         * @param {string} [returnTo] The URL to return to after the logout was completed.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogoutFlow(token?: string, returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig): AxiosPromise<ErrorGeneric> {
            return localVarFp.updateLogoutFlow(token, returnTo, cookie, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a recovery flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid. and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended. `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a recovery link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with a new Recovery Flow ID which contains an error message that the recovery link was invalid.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
         * @summary Update Recovery Flow
         * @param {string} flow The Recovery Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Recovery Token  The recovery token which completes the recovery request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecoveryFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<RecoveryFlow> {
            return localVarFp.updateRecoveryFlow(flow, token, cookie, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to complete a settings flow by sending an identity\'s updated password. This endpoint behaves differently for API and browser flows.  API-initiated flows expect `application/json` to be sent in the body and respond with HTTP 200 and an application/json body with the session token on success; HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set; HTTP 400 on form validation errors. HTTP 401 when the endpoint is called without a valid session token. HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low. Implies that the user needs to re-authenticate.  Browser flows without HTTP Header `Accept` or with `Accept: text/_*` respond with a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded; a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise. a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low.  Browser flows with HTTP Header `Accept: application/json` respond with HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success; HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set; HTTP 401 when the endpoint is called without a valid session cookie. HTTP 403 when the page is accessed without a session cookie or the session\'s AAL is too low. HTTP 400 on form validation errors.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`, or initiate a refresh login flow otherwise. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration! `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL. Most likely used in Social Sign In flows.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
         * @summary Complete Settings Flow
         * @param {string} flow The Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
         * @param {string} [xSessionToken] The Session Token of the Identity performing the settings flow.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettingsFlow(flow: string, xSessionToken?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<SettingsFlow> {
            return localVarFp.updateSettingsFlow(flow, xSessionToken, cookie, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
         * @summary Complete Verification Flow
         * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
         * @param {string} [token] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
         * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVerificationFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<VerificationFlow> {
            return localVarFp.updateVerificationFlow(flow, token, cookie, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontendApi - object-oriented interface
 * @export
 * @class FrontendApi
 * @extends {BaseAPI}
 */
export class FrontendApi extends BaseAPI {
    /**
     * This endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  The URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns a 401 error.  When calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.
     * @summary Create a Logout URL for Browsers
     * @param {string} [returnTo] Return to URL  The URL to which the browser should be redirected to after the logout has been performed.
     * @param {string} [cookie] HTTP Cookies  If you call this endpoint from a backend, please include the original Cookie header in the request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public createBrowserLogoutFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).createBrowserLogoutFlow(returnTo, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to `selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session exists, the browser is returned to the configured return URL.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects or a 400 bad request error if the user is already authenticated.  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
     * @summary Create Recovery Flow for Browsers
     * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public createBrowserRecoveryFlow(returnTo?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).createBrowserRecoveryFlow(returnTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid Ory Kratos Session Cookie is included in the request, a login flow will be initialized.  If this endpoint is opened as a link in the browser, it will be redirected to `selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session was set, the browser will be redirected to the login endpoint.  If this endpoint is called via an AJAX request, the response contains the settings flow without any redirects or a 401 forbidden error if no valid session was set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!  This endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
     * @summary Create Settings Flow for Browsers
     * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public createBrowserSettingsFlow(returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).createBrowserSettingsFlow(returnTo, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to `selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.  If this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
     * @summary Create Verification Flow for Browser Clients
     * @param {string} [returnTo] The URL to return the browser to after the flow was completed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public createBrowserVerificationFlow(returnTo?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).createBrowserVerificationFlow(returnTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
     * @summary Complete Verification Flow With Link
     * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
     * @param {string} [code] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public getCompleteVerificationFlow(flow: string, code?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).getCompleteVerificationFlow(flow, code, cookie, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the error associated with a user-facing self service errors.  This endpoint supports stub values to help you implement the error UI:  `?id=stub:500` - returns a stub 500 (Internal Server Error) error.  More information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).
     * @summary Get User-Flow Errors
     * @param {string} id Error is the error\&#39;s ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public getFlowError(id: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).getFlowError(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a recovery flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getRecoveryFlow(req.header(\'Cookie\'), req.query[\'flow\'])  res.render(\'recovery\', flow) }) ```  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
     * @summary Get Recovery Flow
     * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public getRecoveryFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).getRecoveryFlow(id, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * When accessing this endpoint through Ory Kratos\' Public API you must ensure that either the Ory Kratos Session Cookie or the Ory Kratos Session Token are set.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor or change the configuration.  You can access this endpoint without credentials when using Ory Kratos\' Admin API.  If this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
     * @summary Get Settings Flow
     * @param {string} id ID is the Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
     * @param {string} [xSessionToken] The Session Token  When using the SDK in an app without a browser, please include the session token here.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public getSettingsFlow(id: string, xSessionToken?: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).getSettingsFlow(id, xSessionToken, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a verification flow\'s context with, for example, error details and other information.  Browser flows expect the anti-CSRF cookie to be included in the request\'s HTTP Cookie Header. For AJAX requests you must ensure that cookies are included in the request or requests will fail.  If you use the browser-flow for server-side apps, the services need to run on a common top-level-domain and you need to forward the incoming HTTP Cookie header to this endpoint:  ```js pseudo-code example router.get(\'/recovery\', async function (req, res) { const flow = await client.getVerificationFlow(req.header(\'cookie\'), req.query[\'flow\'])  res.render(\'verification\', flow) }) ```  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
     * @summary Get Verification Flow
     * @param {string} id The Flow ID  The value for this parameter comes from &#x60;request&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
     * @param {string} [cookie] HTTP Cookies  When using the SDK on the server side you must include the HTTP Cookie Header originally sent to your HTTP handler here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public getVerificationFlow(id: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).getVerificationFlow(id, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint logs out an identity in a self-service manner.  If the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other) to the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.  If the `Accept` HTTP header is set to `application/json`, a 204 No Content response will be sent on successful logout instead.  This endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...). For API clients you can call the `/self-service/logout/api` URL directly with the Ory Session Token.  More information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).
     * @summary Update Logout Flow
     * @param {string} [token] A Valid Logout Token  If you do not have a logout token because you only have a session cookie, call &#x60;/self-service/logout/browser&#x60; to generate a URL for this endpoint.
     * @param {string} [returnTo] The URL to return to after the logout was completed.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public updateLogoutFlow(token?: string, returnTo?: string, cookie?: string, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).updateLogoutFlow(token, returnTo, cookie, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a recovery flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid. and a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended. `sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a recovery link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with a new Recovery Flow ID which contains an error message that the recovery link was invalid.  More information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).
     * @summary Update Recovery Flow
     * @param {string} flow The Recovery Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/recovery?flow&#x3D;abcde&#x60;).
     * @param {string} [token] Recovery Token  The recovery token which completes the recovery request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public updateRecoveryFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).updateRecoveryFlow(flow, token, cookie, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to complete a settings flow by sending an identity\'s updated password. This endpoint behaves differently for API and browser flows.  API-initiated flows expect `application/json` to be sent in the body and respond with HTTP 200 and an application/json body with the session token on success; HTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set; HTTP 400 on form validation errors. HTTP 401 when the endpoint is called without a valid session token. HTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low. Implies that the user needs to re-authenticate.  Browser flows without HTTP Header `Accept` or with `Accept: text/_*` respond with a HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded; a HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise. a HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session\'s AAL is too low.  Browser flows with HTTP Header `Accept: application/json` respond with HTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success; HTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set; HTTP 401 when the endpoint is called without a valid session cookie. HTTP 403 when the page is accessed without a session cookie or the session\'s AAL is too low. HTTP 400 on form validation errors.  Depending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator Assurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn credentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user to sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.  If this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the case of an error, the `error.id` of the JSON response body can be one of:  `session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect the identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`, or initiate a refresh login flow otherwise. `security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred. `session_inactive`: No Ory Session was found - sign in a user first. `security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other identity logged in instead. `security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration! `browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL. Most likely used in Social Sign In flows.  More information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).
     * @summary Complete Settings Flow
     * @param {string} flow The Settings Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/settings?flow&#x3D;abcde&#x60;).
     * @param {string} [xSessionToken] The Session Token of the Identity performing the settings flow.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public updateSettingsFlow(flow: string, xSessionToken?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).updateSettingsFlow(flow, xSessionToken, cookie, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to complete a verification flow. This endpoint behaves differently for API and browser flows and has several states:  `choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent and works with API- and Browser-initiated flows. For API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid and a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired). For Browser clients without HTTP Header `Accept` or with `Accept: text/_*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended. `sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It works for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state. `passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\") does not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL (if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with a new Verification Flow ID which contains an error message that the verification link was invalid.  More information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).
     * @summary Complete Verification Flow
     * @param {string} flow The Verification Flow ID  The value for this parameter comes from &#x60;flow&#x60; URL Query parameter sent to your application (e.g. &#x60;/verification?flow&#x3D;abcde&#x60;).
     * @param {string} [token] Verification Token  The verification token which completes the verification request. If the token is invalid (e.g. expired) an error will be shown to the end-user.  This parameter is usually set in a link and not used by any direct API call.
     * @param {string} [cookie] HTTP Cookies  When using the SDK in a browser app, on the server side you must include the HTTP Cookie Header sent by the client to your server here. This ensures that CSRF and session cookies are respected.
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendApi
     */
    public updateVerificationFlow(flow: string, token?: string, cookie?: string, body?: object, options?: RawAxiosRequestConfig) {
        return FrontendApiFp(this.configuration).updateVerificationFlow(flow, token, cookie, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GuestApi - axios parameter creator
 * @export
 */
export const GuestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getAllPhotos', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}/photos`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce: async (eventId: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventByEventId', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewsbyId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNewsbyId', 'id', id)
            const localVarPath = `/news/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto: async (rewildingId: string, photoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getPhoto', 'rewildingId', rewildingId)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhoto', 'photoId', photoId)
            const localVarPath = `/rewilding/{rewildingId}/photos/{photoId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)))
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel: async (feelings?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-feelings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feelings !== undefined) {
                localVarQueryParameter['feelings'] = feelings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserBadges', 'userId', userId)
            const localVarPath = `/user/{userId}/badges`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NearbySearch
         * @param {string} [location] 
         * @param {string} [radius] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {string} [keyword] 
         * @param {string} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapsApiPlaceNearbysearchJsonGet: async (location?: string, radius?: string, key?: string, language?: string, keyword?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maps/api/place/nearbysearch/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 文字搜尋
         * @param {string} [query] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {MapsApiPlaceTextsearchJsonGetTypeEnum} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {string} [xGoogFieldMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapsApiPlaceTextsearchJsonGet: async (query?: string, key?: string, language?: string, type?: MapsApiPlaceTextsearchJsonGetTypeEnum, xGoogFieldMask?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maps/api/place/textsearch/json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (xGoogFieldMask != null) {
                localVarHeaderParameter['X-Goog-FieldMask'] = String(xGoogFieldMask);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSsoRegister: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuestApi - functional programming interface
 * @export
 */
export const GuestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuestApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildingPhotos>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPhotos(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getAllPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAnnounce(eventId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMessageBoard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMessageBoard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventReferenceLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventReferenceLink(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewsbyId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<News>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewsbyId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getNewsbyId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoto(rewildingId, photoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankFeel(feelings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getRankFeel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankRewild(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankRewild(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getRankRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBadges(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBadges(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getUserBadges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorldStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWorldStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorldStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.getUserWorldStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary NearbySearch
         * @param {string} [location] 
         * @param {string} [radius] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {string} [keyword] 
         * @param {string} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mapsApiPlaceNearbysearchJsonGet(location?: string, radius?: string, key?: string, language?: string, keyword?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mapsApiPlaceNearbysearchJsonGet(location, radius, key, language, keyword, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.mapsApiPlaceNearbysearchJsonGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 文字搜尋
         * @param {string} [query] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {MapsApiPlaceTextsearchJsonGetTypeEnum} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {string} [xGoogFieldMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mapsApiPlaceTextsearchJsonGet(query?: string, key?: string, language?: string, type?: MapsApiPlaceTextsearchJsonGetTypeEnum, xGoogFieldMask?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mapsApiPlaceTextsearchJsonGet(query, key, language, type, xGoogFieldMask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.mapsApiPlaceTextsearchJsonGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSsoRegister(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuestApi.startSsoRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuestApi - factory interface
 * @export
 */
export const GuestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuestApiFp(configuration)
    return {
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildingPhotos>> {
            return localVarFp.getAllPhotos(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.getEventAnnounce(eventId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.getEventByEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventMessageBoard>> {
            return localVarFp.getEventMessageBoard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventReferenceLinks>> {
            return localVarFp.getEventReferenceLink(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.getEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewsbyId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<News> {
            return localVarFp.getNewsbyId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPhoto(rewildingId, photoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankFeel(feelings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild(options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankRewild(options).then((request) => request(axios, basePath));
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserBadges(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserWorldStat200Response> {
            return localVarFp.getUserWorldStat(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NearbySearch
         * @param {string} [location] 
         * @param {string} [radius] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {string} [keyword] 
         * @param {string} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapsApiPlaceNearbysearchJsonGet(location?: string, radius?: string, key?: string, language?: string, keyword?: string, type?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.mapsApiPlaceNearbysearchJsonGet(location, radius, key, language, keyword, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 文字搜尋
         * @param {string} [query] 
         * @param {string} [key] 
         * @param {string} [language] 
         * @param {MapsApiPlaceTextsearchJsonGetTypeEnum} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
         * @param {string} [xGoogFieldMask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapsApiPlaceTextsearchJsonGet(query?: string, key?: string, language?: string, type?: MapsApiPlaceTextsearchJsonGetTypeEnum, xGoogFieldMask?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.mapsApiPlaceTextsearchJsonGet(query, key, language, type, xGoogFieldMask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startSsoRegister(returnTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuestApi - object-oriented interface
 * @export
 * @class GuestApi
 * @extends {BaseAPI}
 */
export class GuestApi extends BaseAPI {
    /**
     * Retrieve all photos tied to a rewildings
     * @summary Retrieve all photos tied to a rewilding
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getAllPhotos(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s announcement
     * @summary Retrieve Event Announcement
     * @param {string} eventId String ID of the event
     * @param {string} [category] For filter category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventAnnounce(eventId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read an Event
     * @summary Read Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventByEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventByEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Retrieve Event Message Board
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventMessageBoard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Retrieve Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventReferenceLink(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s schedule
     * @summary Retrieve Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Read News
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getNewsbyId(id: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getNewsbyId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a photo
     * @summary Read a photo
     * @param {string} rewildingId String ID of rewilding
     * @param {string} photoId String ID of photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getPhoto(rewildingId, photoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Feelings
     * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getRankFeel(feelings?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getRankFeel(feelings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getRankRewild(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getRankRewild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 預期會回傳指定會員的所有公開徽章
     * @summary User Badges
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getUserBadges(userId: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getUserBadges(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve World Statistics
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public getUserWorldStat(options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).getUserWorldStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NearbySearch
     * @param {string} [location] 
     * @param {string} [radius] 
     * @param {string} [key] 
     * @param {string} [language] 
     * @param {string} [keyword] 
     * @param {string} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public mapsApiPlaceNearbysearchJsonGet(location?: string, radius?: string, key?: string, language?: string, keyword?: string, type?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).mapsApiPlaceNearbysearchJsonGet(location, radius, key, language, keyword, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 文字搜尋
     * @param {string} [query] 
     * @param {string} [key] 
     * @param {string} [language] 
     * @param {MapsApiPlaceTextsearchJsonGetTypeEnum} [type] https://developers.google.com/maps/documentation/places/web-service/supported_types?hl&#x3D;zh-tw
     * @param {string} [xGoogFieldMask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public mapsApiPlaceTextsearchJsonGet(query?: string, key?: string, language?: string, type?: MapsApiPlaceTextsearchJsonGetTypeEnum, xGoogFieldMask?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).mapsApiPlaceTextsearchJsonGet(query, key, language, type, xGoogFieldMask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 開始SSO註冊
     * @param {string} [returnTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuestApi
     */
    public startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig) {
        return GuestApiFp(this.configuration).startSsoRegister(returnTo, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MapsApiPlaceTextsearchJsonGetTypeEnum = {
    Campground: 'campground',
    TouristAttraction: 'tourist_attraction'
} as const;
export type MapsApiPlaceTextsearchJsonGetTypeEnum = typeof MapsApiPlaceTextsearchJsonGetTypeEnum[keyof typeof MapsApiPlaceTextsearchJsonGetTypeEnum];


/**
 * NoRedirectApi - axios parameter creator
 * @export
 */
export const NoRedirectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary SSO註冊使用者完成
         * @param {string} [state] 
         * @param {string} [xUserAccount] 
         * @param {string} [xUserId] 
         * @param {string} [xUserEmail] 
         * @param {string} [xUserName] 
         * @param {string} [xUserLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishSsoRegister: async (state?: string, xUserAccount?: string, xUserId?: string, xUserEmail?: string, xUserName?: string, xUserLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso/register/finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            if (xUserAccount != null) {
                localVarHeaderParameter['X-User-Account'] = String(xUserAccount);
            }
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            if (xUserEmail != null) {
                localVarHeaderParameter['X-User-Email'] = String(xUserEmail);
            }
            if (xUserName != null) {
                localVarHeaderParameter['X-User-Name'] = String(xUserName);
            }
            if (xUserLanguage != null) {
                localVarHeaderParameter['X-User-Language'] = String(xUserLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSsoRegister: async (returnTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (returnTo !== undefined) {
                localVarQueryParameter['return_to'] = returnTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NoRedirectApi - functional programming interface
 * @export
 */
export const NoRedirectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NoRedirectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary SSO註冊使用者完成
         * @param {string} [state] 
         * @param {string} [xUserAccount] 
         * @param {string} [xUserId] 
         * @param {string} [xUserEmail] 
         * @param {string} [xUserName] 
         * @param {string} [xUserLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finishSsoRegister(state?: string, xUserAccount?: string, xUserId?: string, xUserEmail?: string, xUserName?: string, xUserLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finishSsoRegister(state, xUserAccount, xUserId, xUserEmail, xUserName, xUserLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoRedirectApi.finishSsoRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSsoRegister(returnTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NoRedirectApi.startSsoRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NoRedirectApi - factory interface
 * @export
 */
export const NoRedirectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NoRedirectApiFp(configuration)
    return {
        /**
         * 
         * @summary SSO註冊使用者完成
         * @param {string} [state] 
         * @param {string} [xUserAccount] 
         * @param {string} [xUserId] 
         * @param {string} [xUserEmail] 
         * @param {string} [xUserName] 
         * @param {string} [xUserLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishSsoRegister(state?: string, xUserAccount?: string, xUserId?: string, xUserEmail?: string, xUserName?: string, xUserLanguage?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.finishSsoRegister(state, xUserAccount, xUserId, xUserEmail, xUserName, xUserLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 開始SSO註冊
         * @param {string} [returnTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startSsoRegister(returnTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NoRedirectApi - object-oriented interface
 * @export
 * @class NoRedirectApi
 * @extends {BaseAPI}
 */
export class NoRedirectApi extends BaseAPI {
    /**
     * 
     * @summary SSO註冊使用者完成
     * @param {string} [state] 
     * @param {string} [xUserAccount] 
     * @param {string} [xUserId] 
     * @param {string} [xUserEmail] 
     * @param {string} [xUserName] 
     * @param {string} [xUserLanguage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoRedirectApi
     */
    public finishSsoRegister(state?: string, xUserAccount?: string, xUserId?: string, xUserEmail?: string, xUserName?: string, xUserLanguage?: string, options?: RawAxiosRequestConfig) {
        return NoRedirectApiFp(this.configuration).finishSsoRegister(state, xUserAccount, xUserId, xUserEmail, xUserName, xUserLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 開始SSO註冊
     * @param {string} [returnTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NoRedirectApi
     */
    public startSsoRegister(returnTo?: string, options?: RawAxiosRequestConfig) {
        return NoRedirectApiFp(this.configuration).startSsoRegister(returnTo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OApi - axios parameter creator
 * @export
 */
export const OApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById: async (requestUserFriend?: RequestUserFriend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFriend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OApi - functional programming interface
 * @export
 */
export const OApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agreeUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OApi.agreeUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserFriendById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFriendById(requestUserFriend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OApi.createUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OApi.deleteUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OApi - factory interface
 * @export
 */
export const OApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserFriendById200Response> {
            return localVarFp.createUserFriendById(requestUserFriend, options).then((request) => request(axios, basePath));
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OApi - object-oriented interface
 * @export
 * @class OApi
 * @extends {BaseAPI}
 */
export class OApi extends BaseAPI {
    /**
     * user_friend_status should be set to 1 upon successful API completion.
     * @summary Agree User Friend 
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OApi
     */
    public agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return OApiFp(this.configuration).agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
     * @summary Add User Friend
     * @param {RequestUserFriend} [requestUserFriend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OApi
     */
    public createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig) {
        return OApiFp(this.configuration).createUserFriendById(requestUserFriend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * user_friend_status should be set to 2 upon successful API completion.
     * @summary Cancel User Friend
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OApi
     */
    public deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return OApiFp(this.configuration).deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O1Api - axios parameter creator
 * @export
 */
export const O1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends: async (userId: string, name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOtherUserFriends', 'userId', userId)
            const localVarPath = `/user/{userId}/friends`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O1Api - functional programming interface
 * @export
 */
export const O1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOtherUserFriends(userId, name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1Api.getOtherUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1Api.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O1Api - factory interface
 * @export
 */
export const O1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O1ApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getOtherUserFriends(userId, name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O1Api - object-oriented interface
 * @export
 * @class O1Api
 * @extends {BaseAPI}
 */
export class O1Api extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Retrieve Other User Friends
     * @param {string} userId 
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1Api
     */
    public getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return O1ApiFp(this.configuration).getOtherUserFriends(userId, name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1Api
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return O1ApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O11Api - axios parameter creator
 * @export
 */
export const O11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O11Api - functional programming interface
 * @export
 */
export const O11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O11ApiAxiosParamCreator(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O11Api.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O11Api - factory interface
 * @export
 */
export const O11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O11ApiFp(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O11Api - object-oriented interface
 * @export
 * @class O11Api
 * @extends {BaseAPI}
 */
export class O11Api extends BaseAPI {
    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O11Api
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return O11ApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O111Api - axios parameter creator
 * @export
 */
export const O111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAchievement', 'userId', userId)
            const localVarPath = `/user/{userId}/achievement`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O111Api - functional programming interface
 * @export
 */
export const O111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievement(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievement(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O111Api.getAchievement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O111Api - factory interface
 * @export
 */
export const O111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O111ApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getAchievement(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O111Api - object-oriented interface
 * @export
 * @class O111Api
 * @extends {BaseAPI}
 */
export class O111Api extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary User Achievement
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O111Api
     */
    public getAchievement(userId: string, options?: RawAxiosRequestConfig) {
        return O111ApiFp(this.configuration).getAchievement(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O11aApi - axios parameter creator
 * @export
 */
export const O11aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O11aApi - functional programming interface
 * @export
 */
export const O11aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O11aApiAxiosParamCreator(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O11aApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O11aApi - factory interface
 * @export
 */
export const O11aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O11aApiFp(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O11aApi - object-oriented interface
 * @export
 * @class O11aApi
 * @extends {BaseAPI}
 */
export class O11aApi extends BaseAPI {
    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O11aApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return O11aApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O11bApi - axios parameter creator
 * @export
 */
export const O11bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O11bApi - functional programming interface
 * @export
 */
export const O11bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O11bApiAxiosParamCreator(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O11bApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O11bApi - factory interface
 * @export
 */
export const O11bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O11bApiFp(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O11bApi - object-oriented interface
 * @export
 * @class O11bApi
 * @extends {BaseAPI}
 */
export class O11bApi extends BaseAPI {
    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O11bApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return O11bApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O12Api - axios parameter creator
 * @export
 */
export const O12ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId: async (userId: string, past?: boolean, countryCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserEventbyId', 'userId', userId)
            const localVarPath = `/user/{userId}/events`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O12Api - functional programming interface
 * @export
 */
export const O12ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O12ApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyId(userId, past, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O12Api.getUserEventbyId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O12Api - factory interface
 * @export
 */
export const O12ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O12ApiFp(configuration)
    return {
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyId(userId, past, countryCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O12Api - object-oriented interface
 * @export
 * @class O12Api
 * @extends {BaseAPI}
 */
export class O12Api extends BaseAPI {
    /**
     * Retrieve other users events
     * @summary Other User Event
     * @param {string} userId 
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O12Api
     */
    public getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig) {
        return O12ApiFp(this.configuration).getUserEventbyId(userId, past, countryCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O12aApi - axios parameter creator
 * @export
 */
export const O12aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAchievement', 'userId', userId)
            const localVarPath = `/user/{userId}/achievement`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O12aApi - functional programming interface
 * @export
 */
export const O12aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O12aApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievement(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievement(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O12aApi.getAchievement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O12aApi - factory interface
 * @export
 */
export const O12aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O12aApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getAchievement(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O12aApi - object-oriented interface
 * @export
 * @class O12aApi
 * @extends {BaseAPI}
 */
export class O12aApi extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary User Achievement
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O12aApi
     */
    public getAchievement(userId: string, options?: RawAxiosRequestConfig) {
        return O12aApiFp(this.configuration).getAchievement(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O1bApi - axios parameter creator
 * @export
 */
export const O1bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O1bApi - functional programming interface
 * @export
 */
export const O1bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O1bApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1bApi.deleteUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O1bApi - factory interface
 * @export
 */
export const O1bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O1bApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O1bApi - object-oriented interface
 * @export
 * @class O1bApi
 * @extends {BaseAPI}
 */
export class O1bApi extends BaseAPI {
    /**
     * user_friend_status should be set to 2 upon successful API completion.
     * @summary Cancel User Friend
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1bApi
     */
    public deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return O1bApiFp(this.configuration).deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O1cApi - axios parameter creator
 * @export
 */
export const O1cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O1cApi - functional programming interface
 * @export
 */
export const O1cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O1cApiAxiosParamCreator(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1cApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O1cApi - factory interface
 * @export
 */
export const O1cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O1cApiFp(configuration)
    return {
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O1cApi - object-oriented interface
 * @export
 * @class O1cApi
 * @extends {BaseAPI}
 */
export class O1cApi extends BaseAPI {
    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1cApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return O1cApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O1dApi - axios parameter creator
 * @export
 */
export const O1dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O1dApi - functional programming interface
 * @export
 */
export const O1dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O1dApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1dApi.deleteUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O1dApi - factory interface
 * @export
 */
export const O1dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O1dApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O1dApi - object-oriented interface
 * @export
 * @class O1dApi
 * @extends {BaseAPI}
 */
export class O1dApi extends BaseAPI {
    /**
     * user_friend_status should be set to 2 upon successful API completion.
     * @summary Cancel User Friend
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1dApi
     */
    public deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return O1dApiFp(this.configuration).deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * O1eApi - axios parameter creator
 * @export
 */
export const O1eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * O1eApi - functional programming interface
 * @export
 */
export const O1eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = O1eApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['O1eApi.deleteUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * O1eApi - factory interface
 * @export
 */
export const O1eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = O1eApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * O1eApi - object-oriented interface
 * @export
 * @class O1eApi
 * @extends {BaseAPI}
 */
export class O1eApi extends BaseAPI {
    /**
     * user_friend_status should be set to 2 upon successful API completion.
     * @summary Cancel User Friend
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof O1eApi
     */
    public deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return O1eApiFp(this.configuration).deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OOSAREWILDSERVICEApi - axios parameter creator
 * @export
 */
export const OOSAREWILDSERVICEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList: async (pocketListId: string, requestPocketListItem?: RequestPocketListItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('addToPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat: async (eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('changeEventInvitationStat', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp: async (eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabExp', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/experience`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogExperience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting: async (eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAccounting', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce: async (eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventAnnouncementEventAnnouncementInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant: async (eventId: string, requestEventParticipant?: RequestEventParticipant, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventParticipant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule: async (eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventScheduleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard: async (eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNews: async (requestNews?: RequestNews, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestNews, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink: async (eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventReferenceLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
    
            if (rewildingPocketList !== undefined) { 
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList as any);
            }
    
            if (rewildingReferenceInformation !== undefined) { 
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation as any);
            }
    
            if (rewildingType !== undefined) { 
                localVarFormParams.append('rewilding_type', rewildingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEvent', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAccounting: async (eventId: string, accountingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('deleteEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventParticipant: async (eventId: string, participantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventParticipant', 'eventId', eventId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('deleteEventParticipant', 'participantId', participantId)
            const localVarPath = `/event/{eventId}/participants/{participantId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"participantId"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('deleteMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Delete News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNews: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNews', 'id', id)
            const localVarPath = `/news/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem: async (pocketListId: string, pocketListItemsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem: async (pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePocketListItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('deleteReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('deleteReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('deleteRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdDelete: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdDelete', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdGet: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdGet', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdPut: async (eventId: string, scheduleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdPut', 'eventId', eventId)
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('eventEventIdScheduleScheduleIdPut', 'scheduleId', scheduleId)
            const localVarPath = `/event/{eventId}/schedule/{scheduleId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAchievement', 'userId', userId)
            const localVarPath = `/user/{userId}/achievement`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations: async (applied?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getAllPhotos', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}/photos`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCollaborativeAlbumLinks', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs: async (rewildingId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rewildingId !== undefined) {
                localVarQueryParameter['rewilding_id'] = rewildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage: async (imagename: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagename' is not null or undefined
            assertParamExists('getCoverImage', 'imagename', imagename)
            const localVarPath = `/event/cover/{imagename}`
                .replace(`{${"imagename"}}`, encodeURIComponent(String(imagename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccounting: async (eventId: string, accountingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('getEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAccountings', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/accounting`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce: async (eventId: string, category?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventAnnounce', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/announcement`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventByEventId', 'eventId', eventId)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventMessageBoard', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/message-board`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventReferenceLink', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/reference-links`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventSchedule', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/schedule`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('getMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewsbyId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNewsbyId', 'id', id)
            const localVarPath = `/news/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends: async (userId: string, name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOtherUserFriends', 'userId', userId)
            const localVarPath = `/user/{userId}/friends`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto: async (rewildingId: string, photoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getPhoto', 'rewildingId', rewildingId)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhoto', 'photoId', photoId)
            const localVarPath = `/rewilding/{rewildingId}/photos/{photoId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)))
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItem: async (pocketListId: string, pocketListItemsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('getPocketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItems', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPolaroids', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel: async (feelings?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-feelings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feelings !== undefined) {
                localVarQueryParameter['feelings'] = feelings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('getReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRewildingRegister: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo: async (requestLinkQuery?: RequestLinkQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/link-query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestLinkQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserBadges', 'userId', userId)
            const localVarPath = `/user/{userId}/badges`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId: async (userId: string, past?: boolean, countryCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserEventbyId', 'userId', userId)
            const localVarPath = `/user/{userId}/events`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem: async (pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('movePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdateBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessageBoard: async (eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('pinMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('pinMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}/pin`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventMessageBoardPin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle: async (placeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('rewildGoogle', 'placeId', placeId)
            const localVarPath = `/rewilding/places/{place_id}`
                .replace(`{${"place_id"}}`, encodeURIComponent(String(placeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText: async (keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (rectangleLowLat !== undefined) {
                localVarQueryParameter['rectangle_low_lat'] = rectangleLowLat;
            }

            if (rectangleLowLng !== undefined) {
                localVarQueryParameter['rectangle_low_lng'] = rectangleLowLng;
            }

            if (rectangleHightLat !== undefined) {
                localVarQueryParameter['rectangle_hight_lat'] = rectangleHightLat;
            }

            if (rectangleHightLng !== undefined) {
                localVarQueryParameter['rectangle_hight_lng'] = rectangleHightLng;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rewildingRegisterReferencesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('updateEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('updateEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('updateEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('updateEvent', 'eventsName', eventsName)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAccounting: async (eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventAccounting', 'eventId', eventId)
            // verify required parameter 'accountingId' is not null or undefined
            assertParamExists('updateEventAccounting', 'accountingId', accountingId)
            const localVarPath = `/event/{eventId}/accounting/{accountingId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"accountingId"}}`, encodeURIComponent(String(accountingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAccounting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation: async (eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitation', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/invitation`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationMessageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin: async (eventId: string, requestEventJoin?: RequestEventJoin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEventInvitationJoin', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/join`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventJoin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageBoard: async (eventId: string, messageBoardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateMessageBoard', 'eventId', eventId)
            // verify required parameter 'messageBoardId' is not null or undefined
            assertParamExists('updateMessageBoard', 'messageBoardId', messageBoardId)
            const localVarPath = `/event/{eventId}/message-board/{messageBoardId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"messageBoardId"}}`, encodeURIComponent(String(messageBoardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Update News
         * @param {string} id 
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNews: async (id: string, requestNews?: RequestNews, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNews', 'id', id)
            const localVarPath = `/news/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestNews, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem: async (pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferenceLink: async (eventId: string, referenceLinkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateReferenceLink', 'eventId', eventId)
            // verify required parameter 'referenceLinkId' is not null or undefined
            assertParamExists('updateReferenceLink', 'referenceLinkId', referenceLinkId)
            const localVarPath = `/event/{eventId}/reference-links/{referenceLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"referenceLinkId"}}`, encodeURIComponent(String(referenceLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OOSAREWILDSERVICEApi - functional programming interface
 * @export
 */
export const OOSAREWILDSERVICEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OOSAREWILDSERVICEApiAxiosParamCreator(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToPocketList(pocketListId, requestPocketListItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.addToPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEventInvitationStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.changeEventInvitationStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabExp(eventId, requestCollaborativeLogExperience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createCollabExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAccounting(eventId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateEventParticipant200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventParticipant(eventId, requestEventParticipant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventSchedule(eventId, createEventScheduleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageBoard(eventId, requestEventMessageBoard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNews(requestNews, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinksSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReferenceLink(eventId, requestEventReferenceLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewilding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.createRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsDeleted>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventAccounting(eventId, accountingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventParticipant(eventId, participantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Delete News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNews(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNews(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePicketListItem(pocketListId, pocketListItemsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deletePicketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deletePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketListItem(pocketListId, deletePocketListItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deletePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.deleteRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.eventEventIdScheduleScheduleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchedules>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.eventEventIdScheduleScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSchedules>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.eventEventIdScheduleScheduleIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievement(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievement(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getAchievement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements_1(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getAchievements_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventsInvitations(applied, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getAllEventsInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildingPhotos>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPhotos(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getAllPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAlbumLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeAlbumLinks(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getCollaborativeAlbumLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeLogs(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getCollaborativeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoverImage(imagename: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoverImage(imagename, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getCoverImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAccountingSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccounting(eventId, accountingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAccounting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAccountings(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventAccountings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAnnouncement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventAnnounce(eventId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventAnnounce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventByEventId(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventByEventId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventMessageBoard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventMessageBoard(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventReferenceLinks>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventReferenceLink(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<EventScheduleBulkItemTime>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventSchedule(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEventSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getNews(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<News>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNews(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewsbyId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<News>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewsbyId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getNewsbyId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOtherUserFriends(userId, name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getOtherUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoto(rewildingId, photoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItem(pocketListId, pocketListItemsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItems(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPocketListItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolaroids(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPolaroids200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolaroids(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getPolaroids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankFeel(feelings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRankFeel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankRewild(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankRewild(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRankRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRewildingRegister(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewilding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewildingRegister(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRewildingRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrlInfo(requestLinkQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUrlInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBadges(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBadges(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserBadges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyId(userId, past, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserEventbyId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorldStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWorldStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorldStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.getUserWorldStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.movePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.pinMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildGoogle(placeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.rewildGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildSearchText200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.rewildSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildingRegisterReferencesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.rewildingRegisterReferencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAccountingSingle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventAccounting(eventId, accountingId, requestEventAccounting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateEventAccounting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventInvitationJoin(eventId, requestEventJoin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateEventInvitationJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventMessageBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessageBoard(eventId, messageBoardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateMessageBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Update News
         * @param {string} id 
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNews(id: string, requestNews?: RequestNews, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<News>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNews(id, requestNews, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updatePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventReferenceLinks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReferenceLink(eventId, referenceLinkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAREWILDSERVICEApi.updateReferenceLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OOSAREWILDSERVICEApi - factory interface
 * @export
 */
export const OOSAREWILDSERVICEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OOSAREWILDSERVICEApiFp(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): AxiosPromise<PocketListItems> {
            return localVarFp.addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEventInvitationStat200Response> {
            return localVarFp.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an entry on event\'s accounting
         * @summary Create Event Accounting
         * @param {string} eventId String ID of the event
         * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an entry on event\'s announcement 
         * @summary Create Event Announcement
         * @param {string} eventId String ID of the event
         * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a participant to event
         * @summary Create Event Participant
         * @param {string} eventId String ID of the event
         * @param {RequestEventParticipant} [requestEventParticipant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreateEventParticipant200ResponseInner>> {
            return localVarFp.createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event\'s schedule
         * @summary Create Event Schedule
         * @param {string} eventId String ID of the event
         * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
         * @summary Create Event Message Board
         * @param {string} eventId String ID of the event
         * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Create News
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig): AxiosPromise<CreateNews200Response> {
            return localVarFp.createNews(requestNews, options).then((request) => request(axios, basePath));
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an event\'s reference links
         * @summary Create Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinksSimple> {
            return localVarFp.createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Rewilding> {
            return localVarFp.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event
         * @summary Delete Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventsDeleted> {
            return localVarFp.deleteEvent(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entry on event\'s accounting
         * @summary Delete Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId String ID of the accounting record
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventAccounting(eventId, accountingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a participant from an event
         * @summary Delete Event Participant
         * @param {string} eventId String ID of the event
         * @param {string} participantId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventParticipant(eventId, participantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entry on event\'s message board
         * @summary Delete message board entry
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId String ID of the message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Delete News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNews(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteNews(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s reference links
         * @summary Delete Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId String ID of the reference link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Delete Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Read Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventSchedules> {
            return localVarFp.eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an event\'s schedule
         * @summary Update Event Schedule
         * @param {string} eventId String ID of the event
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventSchedules> {
            return localVarFp.eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary User Achievement
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievement(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getAchievement(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements_1(achievementType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>> {
            return localVarFp.getAllEventsInvitations(applied, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildingPhotos>> {
            return localVarFp.getAllPhotos(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAlbumLink>> {
            return localVarFp.getCollaborativeAlbumLinks(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getCollaborativeLogs(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage(imagename: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCoverImage(imagename, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Read Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventAccountingSingle> {
            return localVarFp.getEventAccounting(eventId, accountingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Retrieve Event Accounting
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAccountings(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAccounting>> {
            return localVarFp.getEventAccountings(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s announcement
         * @summary Retrieve Event Announcement
         * @param {string} eventId String ID of the event
         * @param {string} [category] For filter category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAnnouncement>> {
            return localVarFp.getEventAnnounce(eventId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * Read an Event
         * @summary Read Event
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventByEventId(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.getEventByEventId(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Retrieve Event Message Board
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventMessageBoard>> {
            return localVarFp.getEventMessageBoard(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Retrieve Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventReferenceLinks>> {
            return localVarFp.getEventReferenceLink(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s schedule
         * @summary Retrieve Event Schedule
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSchedule(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<EventScheduleBulkItemTime>>> {
            return localVarFp.getEventSchedule(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Read Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.getMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews(options?: RawAxiosRequestConfig): AxiosPromise<Array<News>> {
            return localVarFp.getNews(options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Read News
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewsbyId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<News> {
            return localVarFp.getNewsbyId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getOtherUserFriends(userId, name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPhoto(rewildingId, photoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.getPocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItem200Response> {
            return localVarFp.getPocketListItem(pocketListId, pocketListItemsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInner>> {
            return localVarFp.getPocketListItems(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPolaroids200ResponseInner>> {
            return localVarFp.getPolaroids(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankFeel(feelings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild(options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankRewild(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Read Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinks> {
            return localVarFp.getReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.getReferences(options).then((request) => request(axios, basePath));
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRewildingRegister(options?: RawAxiosRequestConfig): AxiosPromise<Rewilding> {
            return localVarFp.getRewildingRegister(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Link Query
         * @param {RequestLinkQuery} [requestLinkQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig): AxiosPromise<LinkQuery> {
            return localVarFp.getUrlInfo(requestLinkQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserBadges(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyId(userId, past, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserStat200Response> {
            return localVarFp.getUserStat(options).then((request) => request(axios, basePath));
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserWorldStat200Response> {
            return localVarFp.getUserWorldStat(options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Pin Event Message Board 
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail> {
            return localVarFp.rewildGoogle(placeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildSearchText200ResponseInner>> {
            return localVarFp.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.rewildingRegisterReferencesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
         * @summary Update Event Accounting
         * @param {string} eventId String ID of the event
         * @param {string} accountingId 
         * @param {RequestEventAccounting} [requestEventAccounting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig): AxiosPromise<EventAccountingSingle> {
            return localVarFp.updateEventAccounting(eventId, accountingId, requestEventAccounting, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update invitation message
         * @summary Update Event Invitation Text
         * @param {string} eventId String ID of the event
         * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to Join Event without invitation
         * @summary Send Join Event Request
         * @param {string} eventId String ID of the event
         * @param {RequestEventJoin} [requestEventJoin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s message board
         * @summary Update Event Message Board
         * @param {string} eventId String ID of the event
         * @param {string} messageBoardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventMessageBoard> {
            return localVarFp.updateMessageBoard(eventId, messageBoardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Update News
         * @param {string} id 
         * @param {RequestNews} [requestNews] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNews(id: string, requestNews?: RequestNews, options?: RawAxiosRequestConfig): AxiosPromise<News> {
            return localVarFp.updateNews(id, requestNews, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s reference links
         * @summary Update Event Reference Links
         * @param {string} eventId String ID of the event
         * @param {string} referenceLinkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig): AxiosPromise<EventReferenceLinks> {
            return localVarFp.updateReferenceLink(eventId, referenceLinkId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OOSAREWILDSERVICEApi - object-oriented interface
 * @export
 * @class OOSAREWILDSERVICEApi
 * @extends {BaseAPI}
 */
export class OOSAREWILDSERVICEApi extends BaseAPI {
    /**
     * Add to pocket list
     * @summary Add to pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListItem} [requestPocketListItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change event invitation status
     * @summary Change event invitation status
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {boolean} [applied] set true if its a join request
     * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Experience
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an entry on event\'s accounting
     * @summary Create Event Accounting
     * @param {string} eventId String ID of the event
     * @param {Array<RequestEventAccounting>} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createEventAccounting(eventId: string, requestEventAccounting?: Array<RequestEventAccounting>, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createEventAccounting(eventId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an entry on event\'s announcement 
     * @summary Create Event Announcement
     * @param {string} eventId String ID of the event
     * @param {Array<EventAnnouncementEventAnnouncementInner>} [eventAnnouncementEventAnnouncementInner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createEventAnnounce(eventId: string, eventAnnouncementEventAnnouncementInner?: Array<EventAnnouncementEventAnnouncementInner>, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createEventAnnounce(eventId, eventAnnouncementEventAnnouncementInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a participant to event
     * @summary Create Event Participant
     * @param {string} eventId String ID of the event
     * @param {RequestEventParticipant} [requestEventParticipant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createEventParticipant(eventId: string, requestEventParticipant?: RequestEventParticipant, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createEventParticipant(eventId, requestEventParticipant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event\'s schedule
     * @summary Create Event Schedule
     * @param {string} eventId String ID of the event
     * @param {CreateEventScheduleRequest} [createEventScheduleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createEventSchedule(eventId: string, createEventScheduleRequest?: CreateEventScheduleRequest, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createEventSchedule(eventId, createEventScheduleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an entry on event\'s message board<br/>The following key may not show as it has no value: <br/>event_message_board_status<br/>event_message_board_category<br/> event_message_board_announcement 
     * @summary Create Event Message Board
     * @param {string} eventId String ID of the event
     * @param {RequestEventMessageBoard} [requestEventMessageBoard] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createMessageBoard(eventId: string, requestEventMessageBoard?: RequestEventMessageBoard, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createMessageBoard(eventId, requestEventMessageBoard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Create News
     * @param {RequestNews} [requestNews] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createNews(requestNews?: RequestNews, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createNews(requestNews, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an event\'s reference links
     * @summary Create Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {RequestEventReferenceLinks} [requestEventReferenceLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createReferenceLink(eventId: string, requestEventReferenceLinks?: RequestEventReferenceLinks, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createReferenceLink(eventId, requestEventReferenceLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create rewilding register
     * @summary Create rewilding register
     * @param {boolean} [rewildingApplyOfficial] 
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {string} [rewildingPocketList] 
     * @param {string} [rewildingReferenceInformation] 
     * @param {string} [rewildingType] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event
     * @summary Delete Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteEvent(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteEvent(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entry on event\'s accounting
     * @summary Delete Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId String ID of the accounting record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteEventAccounting(eventId, accountingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a participant from an event
     * @summary Delete Event Participant
     * @param {string} eventId String ID of the event
     * @param {string} participantId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteEventParticipant(eventId: string, participantId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteEventParticipant(eventId, participantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Delete Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entry on event\'s message board
     * @summary Delete message board entry
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId String ID of the message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Delete News
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteNews(id: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteNews(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list
     * @summary Delete pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deletePocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s reference links
     * @summary Delete Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId String ID of the reference link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Delete Rewilding
     * @param {string} rewildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).deleteRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Delete Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public eventEventIdScheduleScheduleIdDelete(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).eventEventIdScheduleScheduleIdDelete(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Read Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public eventEventIdScheduleScheduleIdGet(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).eventEventIdScheduleScheduleIdGet(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an event\'s schedule
     * @summary Update Event Schedule
     * @param {string} eventId String ID of the event
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public eventEventIdScheduleScheduleIdPut(eventId: string, scheduleId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).eventEventIdScheduleScheduleIdPut(eventId, scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary User Achievement
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getAchievement(userId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getAchievement(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getAchievements_1(achievementType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all event invitations
     * @summary Retrieve all event invitations
     * @param {boolean} [applied] Pass true to retrieve applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getAllEventsInvitations(applied, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all photos tied to a rewildings
     * @summary Retrieve all photos tied to a rewilding
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getAllPhotos(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Retrieve Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getCollaborativeAlbumLinks(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve events that has ended
     * @summary Event Collaborate
     * @param {string} [rewildingId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getCollaborativeLogs(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Cover Image
     * @param {string} imagename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getCoverImage(imagename: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getCoverImage(imagename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Read Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventAccounting(eventId: string, accountingId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventAccounting(eventId, accountingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Retrieve Event Accounting
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventAccountings(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventAccountings(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s announcement
     * @summary Retrieve Event Announcement
     * @param {string} eventId String ID of the event
     * @param {string} [category] For filter category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventAnnounce(eventId: string, category?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventAnnounce(eventId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read an Event
     * @summary Read Event
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventByEventId(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventByEventId(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Retrieve Event Message Board
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventMessageBoard(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventMessageBoard(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Retrieve Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventReferenceLink(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventReferenceLink(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s schedule
     * @summary Retrieve Event Schedule
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEventSchedule(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEventSchedule(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Read Event Message Board
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Retrieve News
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getNews(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getNews(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Read News
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getNewsbyId(id: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getNewsbyId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Retrieve Other User Friends
     * @param {string} userId 
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getOtherUserFriends(userId, name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a photo
     * @summary Read a photo
     * @param {string} rewildingId String ID of rewilding
     * @param {string} photoId String ID of photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPhoto(rewildingId, photoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Read pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list item by ID
     * @summary Get pocket list item by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPocketListItem(pocketListId, pocketListItemsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
     * @summary Get pocket list items by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPocketListItems(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve event polaroid
     * @summary Retrieve Polaroid
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getPolaroids(eventId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getPolaroids(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Feelings
     * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRankFeel(feelings?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRankFeel(feelings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRankRewild(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRankRewild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Read Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getReferences(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getReferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding register (使用者自建野放點清單)
     * @summary Retrieve rewilding register
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRewildingRegister(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRewildingRegister(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Link Query
     * @param {RequestLinkQuery} [requestLinkQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUrlInfo(requestLinkQuery?: RequestLinkQuery, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUrlInfo(requestLinkQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 預期會回傳指定會員的所有公開徽章
     * @summary User Badges
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserBadges(userId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserBadges(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve other users events
     * @summary Other User Event
     * @param {string} userId 
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserEventbyId(userId, past, countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserStat(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get my statistics
     * @summary Auth Statistics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserStatistics(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve World Statistics
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public getUserWorldStat(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).getUserWorldStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Pin Event Message Board 
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {RequestEventMessageBoardPin} [requestEventMessageBoardPin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public pinMessageBoard(eventId: string, messageBoardId: string, requestEventMessageBoardPin?: RequestEventMessageBoardPin, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).pinMessageBoard(eventId, messageBoardId, requestEventMessageBoardPin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
     * @summary 從google detail取得野放點資訊
     * @param {string} placeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public rewildGoogle(placeId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).rewildGoogle(placeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
     * @summary 野放點關鍵字搜尋
     * @param {string} [keyword] 
     * @param {string} [rectangleLowLat] 
     * @param {string} [rectangleLowLng] 
     * @param {number} [rectangleHightLat] 
     * @param {number} [rectangleHightLng] 
     * @param {RewildSearchTextLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
     * @summary Rewilding register
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).rewildingRegisterReferencesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event
     * @summary Update Event
     * @param {string} eventId 
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s accounting<br/>The following key may not show as it has no value: <br/>event_accounting_updated_at 
     * @summary Update Event Accounting
     * @param {string} eventId String ID of the event
     * @param {string} accountingId 
     * @param {RequestEventAccounting} [requestEventAccounting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateEventAccounting(eventId: string, accountingId: string, requestEventAccounting?: RequestEventAccounting, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateEventAccounting(eventId, accountingId, requestEventAccounting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update invitation message
     * @summary Update Event Invitation Text
     * @param {string} eventId String ID of the event
     * @param {RequestEventInvitationMessageUpdate} [requestEventInvitationMessageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateEventInvitation(eventId: string, requestEventInvitationMessageUpdate?: RequestEventInvitationMessageUpdate, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateEventInvitation(eventId, requestEventInvitationMessageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to Join Event without invitation
     * @summary Send Join Event Request
     * @param {string} eventId String ID of the event
     * @param {RequestEventJoin} [requestEventJoin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateEventInvitationJoin(eventId: string, requestEventJoin?: RequestEventJoin, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateEventInvitationJoin(eventId, requestEventJoin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s message board
     * @summary Update Event Message Board
     * @param {string} eventId String ID of the event
     * @param {string} messageBoardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateMessageBoard(eventId: string, messageBoardId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateMessageBoard(eventId, messageBoardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Update News
     * @param {string} id 
     * @param {RequestNews} [requestNews] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateNews(id: string, requestNews?: RequestNews, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateNews(id, requestNews, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s reference links
     * @summary Update Event Reference Links
     * @param {string} eventId String ID of the event
     * @param {string} referenceLinkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAREWILDSERVICEApi
     */
    public updateReferenceLink(eventId: string, referenceLinkId: string, options?: RawAxiosRequestConfig) {
        return OOSAREWILDSERVICEApiFp(this.configuration).updateReferenceLink(eventId, referenceLinkId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];
/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];
/**
 * @export
 */
export const RewildSearchTextLanguageEnum = {
    ZhTw: 'zh-TW',
    En: 'en'
} as const;
export type RewildSearchTextLanguageEnum = typeof RewildSearchTextLanguageEnum[keyof typeof RewildSearchTextLanguageEnum];
/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * OOSAUSERSERVICEApi - axios parameter creator
 * @export
 */
export const OOSAUSERSERVICEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByApple: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/apple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail: async (requestUserLoginEmail?: RequestUserLoginEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserLoginEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle: async (requestGoogleAuth?: RequestGoogleAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGoogleAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oosa-daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing: async (requestUserFollowing?: RequestUserFollowing, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFollowing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUserFollowing: async (userFollowingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFollowingId' is not null or undefined
            assertParamExists('deleteUserFollowing', 'userFollowingId', userFollowingId)
            const localVarPath = `/user-following/{userFollowingId}`
                .replace(`{${"userFollowingId"}}`, encodeURIComponent(String(userFollowingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister: async (requestUserRegisterEmail?: RequestUserRegisterEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserRegisterEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword: async (requestForgetPassword?: RequestForgetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine: async (code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge: async (single?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/badges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (single !== undefined) {
                localVarQueryParameter['single'] = single;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowingId: async (userFollowingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFollowingId' is not null or undefined
            assertParamExists('getUserFollowingId', 'userFollowingId', userFollowingId)
            const localVarPath = `/user-following/{userFollowingId}`
                .replace(`{${"userFollowingId"}}`, encodeURIComponent(String(userFollowingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFriends_1: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault: async (requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateAvatar, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture: async (usersAvatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (usersAvatar !== undefined) { 
                localVarFormParams.append('users_avatar', usersAvatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet: async (requestAuthUpdateSetting?: RequestAuthUpdateSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_2: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/take-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OOSAUSERSERVICEApi - functional programming interface
 * @export
 */
export const OOSAUSERSERVICEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OOSAUSERSERVICEApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByApple(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByApple(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.authByApple']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByEmail(requestUserLoginEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.authByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByGoogle(requestGoogleAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.authByGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserDailyVideo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserDailyVideo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.checkUserDailyVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFollowing(requestUserFollowing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.createUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFollowing(userFollowingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.deleteUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailRegister(requestUserRegisterEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.emailRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(requestForgetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthByLine(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getAuthByLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getAuthInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadge(single?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBadges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadge(single, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getBadge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFollowings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowing(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFollowings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowingId(userFollowingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getUserFollowingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends_1(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getUserFriends_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNotifications>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUseDefault(requestAuthUpdateAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updateAvatarUseDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUsePicture(usersAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updateAvatarUsePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSet(requestAuthUpdateSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updateUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser_2(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser_2(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OOSAUSERSERVICEApi.updateUser_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OOSAUSERSERVICEApi - factory interface
 * @export
 */
export const OOSAUSERSERVICEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OOSAUSERSERVICEApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Apple
         * @summary Auth Apple
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByApple(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByApple(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByEmail(requestUserLoginEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByGoogle(requestGoogleAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo(options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.checkUserDailyVideo(options).then((request) => request(axios, basePath));
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createUserFollowing(requestUserFollowing, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFollowing(userFollowingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.emailRegister(requestUserRegisterEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPassword(requestForgetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.getAuthByLine(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getAuthInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge(single?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UserBadges> {
            return localVarFp.getBadge(single, options).then((request) => request(axios, basePath));
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserFollowings>> {
            return localVarFp.getUserFollowing(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserFollowings> {
            return localVarFp.getUserFollowingId(userFollowingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.getUserFriends_1(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserNotifications>> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUsePicture(usersAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserSet(requestAuthUpdateSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_2(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser_2(updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OOSAUSERSERVICEApi - object-oriented interface
 * @export
 * @class OOSAUSERSERVICEApi
 * @extends {BaseAPI}
 */
export class OOSAUSERSERVICEApi extends BaseAPI {
    /**
     * Use this endpoint to login/register using Apple
     * @summary Auth Apple
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public authByApple(options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).authByApple(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login using email
     * @summary Auth Email
     * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).authByEmail(requestUserLoginEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using google
     * @summary Auth Google
     * @param {RequestGoogleAuth} [requestGoogleAuth] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).authByGoogle(requestGoogleAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
     * @summary OOSA User Daily Video Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public checkUserDailyVideo(options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).checkUserDailyVideo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create user following request testt
     * @summary Create User Following
     * @param {RequestUserFollowing} [requestUserFollowing] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).createUserFollowing(requestUserFollowing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user following 
     * @summary Delete User Following
     * @param {string} userFollowingId String ID of the user following
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).deleteUserFollowing(userFollowingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to register using email
     * @summary Email - Register
     * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).emailRegister(requestUserRegisterEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forget Password Request
     * @summary Forget Password
     * @param {RequestForgetPassword} [requestForgetPassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).forgetPassword(requestForgetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Line
     * @summary Auth Line
     * @param {string} [code] Code passed to line
     * @param {string} [state] State passed to line
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getAuthByLine(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
     * @summary Read Authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getAuthInfo(options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getAuthInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve badges earned by user
     * @summary Retrieve Badge
     * @param {boolean} [single] Single acquire
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getBadge(single?: boolean, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getBadge(single, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get other user following friends
     * @summary Retrieve User Following
     * @param {string} [userId] current user\&#39;s id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getUserFollowing(userId?: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getUserFollowing(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user following
     * @summary Read User Following
     * @param {string} userFollowingId String ID of the user following
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getUserFollowingId(userFollowingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s friends Sort by breathing status first, then by name.
     * @summary My Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getUserFriends_1(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve notifications
     * @summary Retrieve User Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public getUserNotifications(options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user avatar
     * @summary Update User Avatar
     * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile picture
     * @summary Update User Profile Picture
     * @param {File} [usersAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updateAvatarUsePicture(usersAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings<br/>1 - True (On)<br />0 - False (Off)
     * @summary Update User Setting
     * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updateUserSet(requestAuthUpdateSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User Take Me
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OOSAUSERSERVICEApi
     */
    public updateUser_2(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return OOSAUSERSERVICEApiFp(this.configuration).updateUser_2(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PocketListApi - axios parameter creator
 * @export
 */
export const PocketListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList: async (pocketListId: string, requestPocketListItem?: RequestPocketListItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('addToPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList: async (requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem: async (pocketListId: string, pocketListItemsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem: async (pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePocketListItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItem: async (pocketListId: string, pocketListItemsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('getPocketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItems', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem: async (pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('movePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdateBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem: async (pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PocketListApi - functional programming interface
 * @export
 */
export const PocketListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PocketListApiAxiosParamCreator(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToPocketList(pocketListId, requestPocketListItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.addToPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPocketList(requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.createPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePicketListItem(pocketListId, pocketListItemsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.deletePicketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.deletePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketListItem(pocketListId, deletePocketListItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.deletePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.getPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItem(pocketListId, pocketListItemsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.getPocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItems(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.getPocketListItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.movePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PocketListApi.updatePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PocketListApi - factory interface
 * @export
 */
export const PocketListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PocketListApiFp(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): AxiosPromise<PocketListItems> {
            return localVarFp.addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Create pocket list
         * @summary Create new pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.createPocketList(requestPocketList, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Read pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.getPocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list item by ID
         * @summary Get pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItem200Response> {
            return localVarFp.getPocketListItem(pocketListId, pocketListItemsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInner>> {
            return localVarFp.getPocketListItems(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PocketListApi - object-oriented interface
 * @export
 * @class PocketListApi
 * @extends {BaseAPI}
 */
export class PocketListApi extends BaseAPI {
    /**
     * Add to pocket list
     * @summary Add to pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListItem} [requestPocketListItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create pocket list
     * @summary Create new pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public createPocketList(requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).createPocketList(requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list
     * @summary Delete pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).deletePocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Read pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public getPocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).getPocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list item by ID
     * @summary Get pocket list item by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public getPocketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).getPocketListItem(pocketListId, pocketListItemsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
     * @summary Get pocket list items by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).getPocketListItems(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PocketListApi
     */
    public updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig) {
        return PocketListApiFp(this.configuration).updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * R1Api - axios parameter creator
 * @export
 */
export const R1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle: async (placeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('rewildGoogle', 'placeId', placeId)
            const localVarPath = `/rewilding/places/{place_id}`
                .replace(`{${"place_id"}}`, encodeURIComponent(String(placeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * R1Api - functional programming interface
 * @export
 */
export const R1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = R1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['R1Api.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildGoogle(placeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['R1Api.rewildGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * R1Api - factory interface
 * @export
 */
export const R1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = R1ApiFp(configuration)
    return {
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail> {
            return localVarFp.rewildGoogle(placeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * R1Api - object-oriented interface
 * @export
 * @class R1Api
 * @extends {BaseAPI}
 */
export class R1Api extends BaseAPI {
    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof R1Api
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return R1ApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
     * @summary 從google detail取得野放點資訊
     * @param {string} placeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof R1Api
     */
    public rewildGoogle(placeId: string, options?: RawAxiosRequestConfig) {
        return R1ApiFp(this.configuration).rewildGoogle(placeId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * R1dApi - axios parameter creator
 * @export
 */
export const R1dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList: async (pocketListId: string, requestPocketListItem?: RequestPocketListItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('addToPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * R1dApi - functional programming interface
 * @export
 */
export const R1dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = R1dApiAxiosParamCreator(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToPocketList(pocketListId, requestPocketListItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['R1dApi.addToPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * R1dApi - factory interface
 * @export
 */
export const R1dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = R1dApiFp(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): AxiosPromise<PocketListItems> {
            return localVarFp.addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * R1dApi - object-oriented interface
 * @export
 * @class R1dApi
 * @extends {BaseAPI}
 */
export class R1dApi extends BaseAPI {
    /**
     * Add to pocket list
     * @summary Add to pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListItem} [requestPocketListItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof R1dApi
     */
    public addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig) {
        return R1dApiFp(this.configuration).addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * R1eApi - axios parameter creator
 * @export
 */
export const R1eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList: async (pocketListId: string, requestPocketListItem?: RequestPocketListItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('addToPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * R1eApi - functional programming interface
 * @export
 */
export const R1eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = R1eApiAxiosParamCreator(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToPocketList(pocketListId, requestPocketListItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['R1eApi.addToPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * R1eApi - factory interface
 * @export
 */
export const R1eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = R1eApiFp(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): AxiosPromise<PocketListItems> {
            return localVarFp.addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * R1eApi - object-oriented interface
 * @export
 * @class R1eApi
 * @extends {BaseAPI}
 */
export class R1eApi extends BaseAPI {
    /**
     * Add to pocket list
     * @summary Add to pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListItem} [requestPocketListItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof R1eApi
     */
    public addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig) {
        return R1eApiFp(this.configuration).addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * R1gApi - axios parameter creator
 * @export
 */
export const R1gApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * R1gApi - functional programming interface
 * @export
 */
export const R1gApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = R1gApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['R1gApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * R1gApi - factory interface
 * @export
 */
export const R1gApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = R1gApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * R1gApi - object-oriented interface
 * @export
 * @class R1gApi
 * @extends {BaseAPI}
 */
export class R1gApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof R1gApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return R1gApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RRSDetailsApi - axios parameter creator
 * @export
 */
export const RRSDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList: async (pocketListId: string, requestPocketListItem?: RequestPocketListItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('addToPocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateEvent', 'eventId', eventId)
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('updateEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('updateEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('updateEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('updateEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('updateEvent', 'eventsName', eventsName)
            const localVarPath = `/event/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RRSDetailsApi - functional programming interface
 * @export
 */
export const RRSDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RRSDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketListItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addToPocketList(pocketListId, requestPocketListItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RRSDetailsApi.addToPocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RRSDetailsApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RRSDetailsApi.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RRSDetailsApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RRSDetailsApi - factory interface
 * @export
 */
export const RRSDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RRSDetailsApiFp(configuration)
    return {
        /**
         * Add to pocket list
         * @summary Add to pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListItem} [requestPocketListItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig): AxiosPromise<PocketListItems> {
            return localVarFp.addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an event
         * @summary Update Event
         * @param {string} eventId 
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RRSDetailsApi - object-oriented interface
 * @export
 * @class RRSDetailsApi
 * @extends {BaseAPI}
 */
export class RRSDetailsApi extends BaseAPI {
    /**
     * Add to pocket list
     * @summary Add to pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListItem} [requestPocketListItem] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RRSDetailsApi
     */
    public addToPocketList(pocketListId: string, requestPocketListItem?: RequestPocketListItem, options?: RawAxiosRequestConfig) {
        return RRSDetailsApiFp(this.configuration).addToPocketList(pocketListId, requestPocketListItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RRSDetailsApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return RRSDetailsApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RRSDetailsApi
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return RRSDetailsApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an event
     * @summary Update Event
     * @param {string} eventId 
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RRSDetailsApi
     */
    public updateEvent(eventId: string, eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return RRSDetailsApiFp(this.configuration).updateEvent(eventId, eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegisterAndSignInApi - axios parameter creator
 * @export
 */
export const RegisterAndSignInApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail: async (requestUserLoginEmail?: RequestUserLoginEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserLoginEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle: async (requestGoogleAuth?: RequestGoogleAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGoogleAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister: async (requestUserRegisterEmail?: RequestUserRegisterEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserRegisterEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine: async (code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegisterAndSignInApi - functional programming interface
 * @export
 */
export const RegisterAndSignInApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegisterAndSignInApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByEmail(requestUserLoginEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegisterAndSignInApi.authByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByGoogle(requestGoogleAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegisterAndSignInApi.authByGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailRegister(requestUserRegisterEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegisterAndSignInApi.emailRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthByLine(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RegisterAndSignInApi.getAuthByLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RegisterAndSignInApi - factory interface
 * @export
 */
export const RegisterAndSignInApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegisterAndSignInApiFp(configuration)
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByEmail(requestUserLoginEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByGoogle(requestGoogleAuth, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.emailRegister(requestUserRegisterEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.getAuthByLine(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegisterAndSignInApi - object-oriented interface
 * @export
 * @class RegisterAndSignInApi
 * @extends {BaseAPI}
 */
export class RegisterAndSignInApi extends BaseAPI {
    /**
     * Use this endpoint to login using email
     * @summary Auth Email
     * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterAndSignInApi
     */
    public authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig) {
        return RegisterAndSignInApiFp(this.configuration).authByEmail(requestUserLoginEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using google
     * @summary Auth Google
     * @param {RequestGoogleAuth} [requestGoogleAuth] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RegisterAndSignInApi
     */
    public authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig) {
        return RegisterAndSignInApiFp(this.configuration).authByGoogle(requestGoogleAuth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to register using email
     * @summary Email - Register
     * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RegisterAndSignInApi
     */
    public emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig) {
        return RegisterAndSignInApiFp(this.configuration).emailRegister(requestUserRegisterEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Line
     * @summary Auth Line
     * @param {string} [code] Code passed to line
     * @param {string} [state] State passed to line
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RegisterAndSignInApi
     */
    public getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return RegisterAndSignInApiFp(this.configuration).getAuthByLine(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewildingApi - axios parameter creator
 * @export
 */
export const RewildingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('deleteRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getAllPhotos', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}/photos`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto: async (rewildingId: string, photoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getPhoto', 'rewildingId', rewildingId)
            // verify required parameter 'photoId' is not null or undefined
            assertParamExists('getPhoto', 'photoId', photoId)
            const localVarPath = `/rewilding/{rewildingId}/photos/{photoId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)))
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewildingApi - functional programming interface
 * @export
 */
export const RewildingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewildingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingApi.deleteRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildingPhotos>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPhotos(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingApi.getAllPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhoto(rewildingId, photoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingApi.getPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewildingApi - factory interface
 * @export
 */
export const RewildingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewildingApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all photos tied to a rewildings
         * @summary Retrieve all photos tied to a rewilding
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildingPhotos>> {
            return localVarFp.getAllPhotos(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a photo
         * @summary Read a photo
         * @param {string} rewildingId String ID of rewilding
         * @param {string} photoId String ID of photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPhoto(rewildingId, photoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewildingApi - object-oriented interface
 * @export
 * @class RewildingApi
 * @extends {BaseAPI}
 */
export class RewildingApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return RewildingApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Delete Rewilding
     * @param {string} rewildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingApi
     */
    public deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return RewildingApiFp(this.configuration).deleteRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all photos tied to a rewildings
     * @summary Retrieve all photos tied to a rewilding
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingApi
     */
    public getAllPhotos(rewildingId: string, options?: RawAxiosRequestConfig) {
        return RewildingApiFp(this.configuration).getAllPhotos(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a photo
     * @summary Read a photo
     * @param {string} rewildingId String ID of rewilding
     * @param {string} photoId String ID of photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingApi
     */
    public getPhoto(rewildingId: string, photoId: string, options?: RawAxiosRequestConfig) {
        return RewildingApiFp(this.configuration).getPhoto(rewildingId, photoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return RewildingApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewildingRegisterApi - axios parameter creator
 * @export
 */
export const RewildingRegisterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
    
            if (rewildingPocketList !== undefined) { 
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList as any);
            }
    
            if (rewildingReferenceInformation !== undefined) { 
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation as any);
            }
    
            if (rewildingType !== undefined) { 
                localVarFormParams.append('rewilding_type', rewildingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRewildingRegister: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rewildingRegisterReferencesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewildingRegisterApi - functional programming interface
 * @export
 */
export const RewildingRegisterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewildingRegisterApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewilding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingRegisterApi.createRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingRegisterApi.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRewildingRegister(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewilding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewildingRegister(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingRegisterApi.getRewildingRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildingRegisterReferencesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingRegisterApi.rewildingRegisterReferencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewildingRegisterApi - factory interface
 * @export
 */
export const RewildingRegisterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewildingRegisterApiFp(configuration)
    return {
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Rewilding> {
            return localVarFp.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding register (使用者自建野放點清單)
         * @summary Retrieve rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRewildingRegister(options?: RawAxiosRequestConfig): AxiosPromise<Rewilding> {
            return localVarFp.getRewildingRegister(options).then((request) => request(axios, basePath));
        },
        /**
         * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
         * @summary Rewilding register
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.rewildingRegisterReferencesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewildingRegisterApi - object-oriented interface
 * @export
 * @class RewildingRegisterApi
 * @extends {BaseAPI}
 */
export class RewildingRegisterApi extends BaseAPI {
    /**
     * Create rewilding register
     * @summary Create rewilding register
     * @param {boolean} [rewildingApplyOfficial] 
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {string} [rewildingPocketList] 
     * @param {string} [rewildingReferenceInformation] 
     * @param {string} [rewildingType] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RewildingRegisterApi
     */
    public createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig) {
        return RewildingRegisterApiFp(this.configuration).createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingRegisterApi
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return RewildingRegisterApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding register (使用者自建野放點清單)
     * @summary Retrieve rewilding register
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RewildingRegisterApi
     */
    public getRewildingRegister(options?: RawAxiosRequestConfig) {
        return RewildingRegisterApiFp(this.configuration).getRewildingRegister(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rewilding register options. Replace by https://app.apidog.com/link/project/607604/apis/api-9003159
     * @summary Rewilding register
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RewildingRegisterApi
     */
    public rewildingRegisterReferencesGet(options?: RawAxiosRequestConfig) {
        return RewildingRegisterApiFp(this.configuration).rewildingRegisterReferencesGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewildingSearchApi - axios parameter creator
 * @export
 */
export const RewildingSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle: async (placeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('rewildGoogle', 'placeId', placeId)
            const localVarPath = `/rewilding/places/{place_id}`
                .replace(`{${"place_id"}}`, encodeURIComponent(String(placeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText: async (keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (rectangleLowLat !== undefined) {
                localVarQueryParameter['rectangle_low_lat'] = rectangleLowLat;
            }

            if (rectangleLowLng !== undefined) {
                localVarQueryParameter['rectangle_low_lng'] = rectangleLowLng;
            }

            if (rectangleHightLat !== undefined) {
                localVarQueryParameter['rectangle_hight_lat'] = rectangleHightLat;
            }

            if (rectangleHightLng !== undefined) {
                localVarQueryParameter['rectangle_hight_lng'] = rectangleHightLng;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewildingSearchApi - functional programming interface
 * @export
 */
export const RewildingSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewildingSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingSearchApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildGoogle(placeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingSearchApi.rewildGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingSearchApi.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildSearchText200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingSearchApi.rewildSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewildingSearchApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewildingSearchApi - factory interface
 * @export
 */
export const RewildingSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewildingSearchApiFp(configuration)
    return {
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail> {
            return localVarFp.rewildGoogle(placeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildSearchText200ResponseInner>> {
            return localVarFp.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewildingSearchApi - object-oriented interface
 * @export
 * @class RewildingSearchApi
 * @extends {BaseAPI}
 */
export class RewildingSearchApi extends BaseAPI {
    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingSearchApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return RewildingSearchApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
     * @summary 從google detail取得野放點資訊
     * @param {string} placeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingSearchApi
     */
    public rewildGoogle(placeId: string, options?: RawAxiosRequestConfig) {
        return RewildingSearchApiFp(this.configuration).rewildGoogle(placeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingSearchApi
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return RewildingSearchApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
     * @summary 野放點關鍵字搜尋
     * @param {string} [keyword] 
     * @param {string} [rectangleLowLat] 
     * @param {string} [rectangleLowLng] 
     * @param {number} [rectangleHightLat] 
     * @param {number} [rectangleHightLng] 
     * @param {RewildSearchTextLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewildingSearchApi
     */
    public rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig) {
        return RewildingSearchApiFp(this.configuration).rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RewildingSearchApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return RewildingSearchApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];
/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];
/**
 * @export
 */
export const RewildSearchTextLanguageEnum = {
    ZhTw: 'zh-TW',
    En: 'en'
} as const;
export type RewildSearchTextLanguageEnum = typeof RewildSearchTextLanguageEnum[keyof typeof RewildSearchTextLanguageEnum];
/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * S11Api - axios parameter creator
 * @export
 */
export const S11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister: async (requestUserRegisterEmail?: RequestUserRegisterEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserRegisterEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S11Api - functional programming interface
 * @export
 */
export const S11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S11ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailRegister(requestUserRegisterEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S11Api.emailRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S11Api - factory interface
 * @export
 */
export const S11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S11ApiFp(configuration)
    return {
        /**
         * Use this endpoint to register using email
         * @summary Email - Register
         * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.emailRegister(requestUserRegisterEmail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S11Api - object-oriented interface
 * @export
 * @class S11Api
 * @extends {BaseAPI}
 */
export class S11Api extends BaseAPI {
    /**
     * Use this endpoint to register using email
     * @summary Email - Register
     * @param {RequestUserRegisterEmail} [requestUserRegisterEmail] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S11Api
     */
    public emailRegister(requestUserRegisterEmail?: RequestUserRegisterEmail, options?: RawAxiosRequestConfig) {
        return S11ApiFp(this.configuration).emailRegister(requestUserRegisterEmail, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S111Api - axios parameter creator
 * @export
 */
export const S111ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle: async (requestGoogleAuth?: RequestGoogleAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGoogleAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S111Api - functional programming interface
 * @export
 */
export const S111ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S111ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByGoogle(requestGoogleAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S111Api.authByGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S111Api - factory interface
 * @export
 */
export const S111ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S111ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByGoogle(requestGoogleAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S111Api - object-oriented interface
 * @export
 * @class S111Api
 * @extends {BaseAPI}
 */
export class S111Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using google
     * @summary Auth Google
     * @param {RequestGoogleAuth} [requestGoogleAuth] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S111Api
     */
    public authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig) {
        return S111ApiFp(this.configuration).authByGoogle(requestGoogleAuth, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S112Api - axios parameter creator
 * @export
 */
export const S112ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine: async (code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S112Api - functional programming interface
 * @export
 */
export const S112ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S112ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthByLine(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S112Api.getAuthByLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S112Api - factory interface
 * @export
 */
export const S112ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S112ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.getAuthByLine(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S112Api - object-oriented interface
 * @export
 * @class S112Api
 * @extends {BaseAPI}
 */
export class S112Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using Line
     * @summary Auth Line
     * @param {string} [code] Code passed to line
     * @param {string} [state] State passed to line
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S112Api
     */
    public getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return S112ApiFp(this.configuration).getAuthByLine(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S113Api - axios parameter creator
 * @export
 */
export const S113ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S113Api - functional programming interface
 * @export
 */
export const S113ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S113ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S113Api.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S113Api - factory interface
 * @export
 */
export const S113ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S113ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S113Api - object-oriented interface
 * @export
 * @class S113Api
 * @extends {BaseAPI}
 */
export class S113Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S113Api
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return S113ApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S12Api - axios parameter creator
 * @export
 */
export const S12ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle: async (requestGoogleAuth?: RequestGoogleAuth, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestGoogleAuth, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S12Api - functional programming interface
 * @export
 */
export const S12ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S12ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByGoogle(requestGoogleAuth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S12Api.authByGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S12Api - factory interface
 * @export
 */
export const S12ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S12ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using google
         * @summary Auth Google
         * @param {RequestGoogleAuth} [requestGoogleAuth] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByGoogle(requestGoogleAuth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S12Api - object-oriented interface
 * @export
 * @class S12Api
 * @extends {BaseAPI}
 */
export class S12Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using google
     * @summary Auth Google
     * @param {RequestGoogleAuth} [requestGoogleAuth] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S12Api
     */
    public authByGoogle(requestGoogleAuth?: RequestGoogleAuth, options?: RawAxiosRequestConfig) {
        return S12ApiFp(this.configuration).authByGoogle(requestGoogleAuth, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S121Api - axios parameter creator
 * @export
 */
export const S121ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine: async (code?: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/line`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S121Api - functional programming interface
 * @export
 */
export const S121ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S121ApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthByLine(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S121Api.getAuthByLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S121Api - factory interface
 * @export
 */
export const S121ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S121ApiFp(configuration)
    return {
        /**
         * Use this endpoint to login/register using Line
         * @summary Auth Line
         * @param {string} [code] Code passed to line
         * @param {string} [state] State passed to line
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.getAuthByLine(code, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S121Api - object-oriented interface
 * @export
 * @class S121Api
 * @extends {BaseAPI}
 */
export class S121Api extends BaseAPI {
    /**
     * Use this endpoint to login/register using Line
     * @summary Auth Line
     * @param {string} [code] Code passed to line
     * @param {string} [state] State passed to line
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S121Api
     */
    public getAuthByLine(code?: string, state?: string, options?: RawAxiosRequestConfig) {
        return S121ApiFp(this.configuration).getAuthByLine(code, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S121aApi - axios parameter creator
 * @export
 */
export const S121aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail: async (requestUserLoginEmail?: RequestUserLoginEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserLoginEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/facebook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S121aApi - functional programming interface
 * @export
 */
export const S121aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S121aApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByEmail(requestUserLoginEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S121aApi.authByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authByFacebook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authByFacebook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['S121aApi.authByFacebook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * S121aApi - factory interface
 * @export
 */
export const S121aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S121aApiFp(configuration)
    return {
        /**
         * Use this endpoint to login using email
         * @summary Auth Email
         * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByEmail(requestUserLoginEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to login/register using Facebook
         * @summary Auth Facebook
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authByFacebook(options?: RawAxiosRequestConfig): AxiosPromise<UserLogin> {
            return localVarFp.authByFacebook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S121aApi - object-oriented interface
 * @export
 * @class S121aApi
 * @extends {BaseAPI}
 */
export class S121aApi extends BaseAPI {
    /**
     * Use this endpoint to login using email
     * @summary Auth Email
     * @param {RequestUserLoginEmail} [requestUserLoginEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S121aApi
     */
    public authByEmail(requestUserLoginEmail?: RequestUserLoginEmail, options?: RawAxiosRequestConfig) {
        return S121aApiFp(this.configuration).authByEmail(requestUserLoginEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to login/register using Facebook
     * @summary Auth Facebook
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof S121aApi
     */
    public authByFacebook(options?: RawAxiosRequestConfig) {
        return S121aApiFp(this.configuration).authByFacebook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * T1DiscoverApi - axios parameter creator
 * @export
 */
export const T1DiscoverApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
                if (rewildingPocketList) {
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList.join(COLLECTION_FORMATS.csv));
            }

                if (rewildingReferenceInformation) {
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding: async (rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (rewildingApplyOfficial !== undefined) { 
                localVarFormParams.append('rewilding_apply_official', String(rewildingApplyOfficial) as any);
            }
    
            if (rewildingLat !== undefined) { 
                localVarFormParams.append('rewilding_lat', rewildingLat as any);
            }
    
            if (rewildingLng !== undefined) { 
                localVarFormParams.append('rewilding_lng', rewildingLng as any);
            }
    
            if (rewildingName !== undefined) { 
                localVarFormParams.append('rewilding_name', rewildingName as any);
            }
    
            if (rewildingPhoto !== undefined) { 
                localVarFormParams.append('rewilding_photo[]', rewildingPhoto as any);
            }
    
            if (rewildingPocketList !== undefined) { 
                localVarFormParams.append('rewilding_pocket_list', rewildingPocketList as any);
            }
    
            if (rewildingReferenceInformation !== undefined) { 
                localVarFormParams.append('rewilding_reference_information', rewildingReferenceInformation as any);
            }
    
            if (rewildingType !== undefined) { 
                localVarFormParams.append('rewilding_type', rewildingType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem: async (pocketListId: string, pocketListItemsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('deletePicketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem: async (pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('deletePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePocketListItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('deleteRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventPeriodBegin !== undefined) {
                localVarQueryParameter['event_period_begin'] = eventPeriodBegin;
            }

            if (eventPeriodEnd !== undefined) {
                localVarQueryParameter['event_period_end'] = eventPeriodEnd;
            }

            if (eventRewilding !== undefined) {
                localVarQueryParameter['event_rewilding'] = eventRewilding;
            }

            if (eventPast !== undefined) {
                localVarQueryParameter['event_past'] = eventPast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems: async (pocketListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('getPocketListItems', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('getRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem: async (pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('movePocketListItem', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}/items`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdateBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle: async (placeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('rewildGoogle', 'placeId', placeId)
            const localVarPath = `/rewilding/places/{place_id}`
                .replace(`{${"place_id"}}`, encodeURIComponent(String(placeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText: async (keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (rectangleLowLat !== undefined) {
                localVarQueryParameter['rectangle_low_lat'] = rectangleLowLat;
            }

            if (rectangleLowLng !== undefined) {
                localVarQueryParameter['rectangle_low_lng'] = rectangleLowLng;
            }

            if (rectangleHightLat !== undefined) {
                localVarQueryParameter['rectangle_hight_lat'] = rectangleHightLat;
            }

            if (rectangleHightLng !== undefined) {
                localVarQueryParameter['rectangle_hight_lng'] = rectangleHightLng;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList: async (pocketListId: string, requestPocketList?: RequestPocketList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketList', 'pocketListId', pocketListId)
            const localVarPath = `/pocket-list/{pocketListId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem: async (pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pocketListId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListId', pocketListId)
            // verify required parameter 'pocketListItemsId' is not null or undefined
            assertParamExists('updatePocketListItem', 'pocketListItemsId', pocketListItemsId)
            const localVarPath = `/pocket-list/{pocketListId}/items/{pocketListItemsId}`
                .replace(`{${"pocketListId"}}`, encodeURIComponent(String(pocketListId)))
                .replace(`{${"pocketListItemsId"}}`, encodeURIComponent(String(pocketListItemsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestPocketListUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * T1DiscoverApi - functional programming interface
 * @export
 */
export const T1DiscoverApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = T1DiscoverApiAxiosParamCreator(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.createRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rewilding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.createRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePicketListItem(pocketListId, pocketListItemsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.deletePicketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketList(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.deletePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePocketListItem(pocketListId, deletePocketListItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.deletePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.deleteRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements_1(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getAchievements_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketListItems(pocketListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getPocketListItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRewild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.movePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildGoogle(placeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.rewildGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildSearchText200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.rewildSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PocketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketList(pocketListId, requestPocketList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.updatePocketList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T1DiscoverApi.updatePocketListItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * T1DiscoverApi - factory interface
 * @export
 */
export const T1DiscoverApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = T1DiscoverApiFp(configuration)
    return {
        /**
         * Create rewilding spot by user
         * @summary Create rewilding spot
         * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {Array<string>} [rewildingPocketList] 
         * @param {Array<string>} [rewildingReferenceInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<CreateRewild200Response> {
            return localVarFp.createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create rewilding register
         * @summary Create rewilding register
         * @param {boolean} [rewildingApplyOfficial] 
         * @param {number} [rewildingLat] 
         * @param {number} [rewildingLng] 
         * @param {string} [rewildingName] 
         * @param {File} [rewildingPhoto] 
         * @param {string} [rewildingPocketList] 
         * @param {string} [rewildingReferenceInformation] 
         * @param {string} [rewildingType] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Rewilding> {
            return localVarFp.createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list
         * @summary Delete pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketList(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pocket list item by ID
         * @summary Delete pocket list item (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements_1(achievementType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Events
         * @param {string} [eventPeriodBegin] 
         * @param {string} [eventPeriodEnd] 
         * @param {string} [eventRewilding] Rewilding ID
         * @param {string} [eventPast] 為1時獲取過去event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
         * @summary Get pocket list items by ID
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInner>> {
            return localVarFp.getPocketListItems(pocketListId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Read a rewilding spot in database
         * @summary Read a rewilding spot
         * @param {string} rewildingId String ID of rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRewild200Response> {
            return localVarFp.getRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list (BULK)
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
         * @summary 從google detail取得野放點資訊
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildGoogle(placeId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail> {
            return localVarFp.rewildGoogle(placeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildSearchText200ResponseInner>> {
            return localVarFp.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Update existing pocket list
         * @summary Update existing pocket list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {RequestPocketList} [requestPocketList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig): AxiosPromise<PocketList> {
            return localVarFp.updatePocketList(pocketListId, requestPocketList, options).then((request) => request(axios, basePath));
        },
        /**
         * Move pocket list item to another list
         * @summary Move pocket list item to another list
         * @param {string} pocketListId String ID of the user to get pocket list
         * @param {string} pocketListItemsId String ID of the user to get pocket list item
         * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * T1DiscoverApi - object-oriented interface
 * @export
 * @class T1DiscoverApi
 * @extends {BaseAPI}
 */
export class T1DiscoverApi extends BaseAPI {
    /**
     * Create rewilding spot by user
     * @summary Create rewilding spot
     * @param {boolean} [rewildingApplyOfficial] false表示個人野放點(目前都只有個人野放點)
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {Array<string>} [rewildingPocketList] 
     * @param {Array<string>} [rewildingReferenceInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public createRewild(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: Array<string>, rewildingReferenceInformation?: Array<string>, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).createRewild(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create rewilding register
     * @summary Create rewilding register
     * @param {boolean} [rewildingApplyOfficial] 
     * @param {number} [rewildingLat] 
     * @param {number} [rewildingLng] 
     * @param {string} [rewildingName] 
     * @param {File} [rewildingPhoto] 
     * @param {string} [rewildingPocketList] 
     * @param {string} [rewildingReferenceInformation] 
     * @param {string} [rewildingType] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public createRewilding(rewildingApplyOfficial?: boolean, rewildingLat?: number, rewildingLng?: number, rewildingName?: string, rewildingPhoto?: File, rewildingPocketList?: string, rewildingReferenceInformation?: string, rewildingType?: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).createRewilding(rewildingApplyOfficial, rewildingLat, rewildingLng, rewildingName, rewildingPhoto, rewildingPocketList, rewildingReferenceInformation, rewildingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public deletePicketListItem(pocketListId: string, pocketListItemsId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).deletePicketListItem(pocketListId, pocketListItemsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list
     * @summary Delete pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public deletePocketList(pocketListId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).deletePocketList(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pocket list item by ID
     * @summary Delete pocket list item (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {DeletePocketListItemRequest} [deletePocketListItemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public deletePocketListItem(pocketListId: string, deletePocketListItemRequest?: DeletePocketListItemRequest, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).deletePocketListItem(pocketListId, deletePocketListItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Delete Rewilding
     * @param {string} rewildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).deleteRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getAchievements_1(achievementType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Events
     * @param {string} [eventPeriodBegin] 
     * @param {string} [eventPeriodEnd] 
     * @param {string} [eventRewilding] Rewilding ID
     * @param {string} [eventPast] 為1時獲取過去event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getEvents(eventPeriodBegin?: string, eventPeriodEnd?: string, eventRewilding?: string, eventPast?: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getEvents(eventPeriodBegin, eventPeriodEnd, eventRewilding, eventPast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list items by ID<br/><br/>The following key may not show as it has no value: <br/>pocket_list_items_deleted_at<br/>pocket_list_items_created_at 
     * @summary Get pocket list items by ID
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getPocketListItems(pocketListId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getPocketListItems(pocketListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read a rewilding spot in database
     * @summary Read a rewilding spot
     * @param {string} rewildingId String ID of rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list (BULK)
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketListUpdateBulk} [requestPocketListUpdateBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public movePocketListItem(pocketListId: string, requestPocketListUpdateBulk?: RequestPocketListUpdateBulk, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).movePocketListItem(pocketListId, requestPocketListUpdateBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 將google place的資料轉成rewilding的格式，reference_links從google search取得前三個連結資料
     * @summary 從google detail取得野放點資訊
     * @param {string} placeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public rewildGoogle(placeId: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).rewildGoogle(placeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
     * @summary 野放點關鍵字搜尋
     * @param {string} [keyword] 
     * @param {string} [rectangleLowLat] 
     * @param {string} [rectangleLowLng] 
     * @param {number} [rectangleHightLat] 
     * @param {number} [rectangleHightLng] 
     * @param {RewildSearchTextLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update existing pocket list
     * @summary Update existing pocket list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {RequestPocketList} [requestPocketList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public updatePocketList(pocketListId: string, requestPocketList?: RequestPocketList, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).updatePocketList(pocketListId, requestPocketList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move pocket list item to another list
     * @summary Move pocket list item to another list
     * @param {string} pocketListId String ID of the user to get pocket list
     * @param {string} pocketListItemsId String ID of the user to get pocket list item
     * @param {RequestPocketListUpdate} [requestPocketListUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T1DiscoverApi
     */
    public updatePocketListItem(pocketListId: string, pocketListItemsId: string, requestPocketListUpdate?: RequestPocketListUpdate, options?: RawAxiosRequestConfig) {
        return T1DiscoverApiFp(this.configuration).updatePocketListItem(pocketListId, pocketListItemsId, requestPocketListUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];
/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];
/**
 * @export
 */
export const RewildSearchTextLanguageEnum = {
    ZhTw: 'zh-TW',
    En: 'en'
} as const;
export type RewildSearchTextLanguageEnum = typeof RewildSearchTextLanguageEnum[keyof typeof RewildSearchTextLanguageEnum];
/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * T2BasecampApi - axios parameter creator
 * @export
 */
export const T2BasecampApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild: async (rewildingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rewildingId' is not null or undefined
            assertParamExists('deleteRewild', 'rewildingId', rewildingId)
            const localVarPath = `/rewilding/{rewildingId}`
                .replace(`{${"rewildingId"}}`, encodeURIComponent(String(rewildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage: async (imagename: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagename' is not null or undefined
            assertParamExists('getCoverImage', 'imagename', imagename)
            const localVarPath = `/event/cover/{imagename}`
                .replace(`{${"imagename"}}`, encodeURIComponent(String(imagename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pocket-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds: async (owner?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete: async (input?: string, language?: RewildAutoCompleteLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input !== undefined) {
                localVarQueryParameter['input'] = input;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby: async (type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchNearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText: async (keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-searchText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (rectangleLowLat !== undefined) {
                localVarQueryParameter['rectangle_low_lat'] = rectangleLowLat;
            }

            if (rectangleLowLng !== undefined) {
                localVarQueryParameter['rectangle_low_lng'] = rectangleLowLng;
            }

            if (rectangleHightLat !== undefined) {
                localVarQueryParameter['rectangle_hight_lat'] = rectangleHightLat;
            }

            if (rectangleHightLng !== undefined) {
                localVarQueryParameter['rectangle_hight_lng'] = rectangleHightLng;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding: async (lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewilding-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * T2BasecampApi - functional programming interface
 * @export
 */
export const T2BasecampApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = T2BasecampApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRewild(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.deleteRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoverImage(imagename: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoverImage(imagename, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.getCoverImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPocketLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PocketList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPocketLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.getPocketLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingOptions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.getReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRewilds200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewilds(owner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.getRewilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildAutoComplete200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildAutoComplete(input, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.rewildAutoComplete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchNearby(type, lat, lng, radius, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.rewildSearchNearby']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewildSearchText200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.rewildSearchText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewildingSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRewilding(lat, lng, type, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T2BasecampApi.searchRewilding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * T2BasecampApi - factory interface
 * @export
 */
export const T2BasecampApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = T2BasecampApiFp(configuration)
    return {
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Delete Rewilding
         * @param {string} rewildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteRewild(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Cover Image
         * @param {string} imagename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoverImage(imagename: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCoverImage(imagename, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
         * @summary Get pocket list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPocketLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<PocketList>> {
            return localVarFp.getPocketLists(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReferences(options?: RawAxiosRequestConfig): AxiosPromise<RewildingOptions> {
            return localVarFp.getReferences(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
         * @summary Retrieve all rewilding spots
         * @param {boolean} [owner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewilds(owner?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRewilds200ResponseInner>> {
            return localVarFp.getRewilds(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 野放點自動完成
         * @param {string} [input] 關鍵字
         * @param {RewildAutoCompleteLanguageEnum} [language] 語言
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildAutoComplete200ResponseInner>> {
            return localVarFp.rewildAutoComplete(input, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 附近的野放點
         * @param {RewildSearchNearbyTypeEnum} [type] 
         * @param {number} [lat] 
         * @param {number} [lng] 
         * @param {number} [radius] 半徑(單位為公尺)
         * @param {RewildSearchNearbyLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPocketListItems200ResponseInnerPocketListItemsRewildingDetail>> {
            return localVarFp.rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(axios, basePath));
        },
        /**
         * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
         * @summary 野放點關鍵字搜尋
         * @param {string} [keyword] 
         * @param {string} [rectangleLowLat] 
         * @param {string} [rectangleLowLng] 
         * @param {number} [rectangleHightLat] 
         * @param {number} [rectangleHightLng] 
         * @param {RewildSearchTextLanguageEnum} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<RewildSearchText200ResponseInner>> {
            return localVarFp.rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Search rewilding from Google
         * @summary Search rewilding from Google
         * @param {string} [lat] Latitude
         * @param {string} [lng] Longitude
         * @param {SearchRewildingTypeEnum} [type] Activity type
         * @param {string} [search] Search by Text
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<RewildingSearch> {
            return localVarFp.searchRewilding(lat, lng, type, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * T2BasecampApi - object-oriented interface
 * @export
 * @class T2BasecampApi
 * @extends {BaseAPI}
 */
export class T2BasecampApi extends BaseAPI {
    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Delete Rewilding
     * @param {string} rewildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public deleteRewild(rewildingId: string, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).deleteRewild(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Cover Image
     * @param {string} imagename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public getCoverImage(imagename: string, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).getCoverImage(imagename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pocket list<br/>The following key may not show as it has no value: <br/>pocket_lists_deleted_at 
     * @summary Get pocket list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public getPocketLists(options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).getPocketLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public getReferences(options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).getReferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve rewilding spots in database (當使用者加入口袋清單或是創建野放點時，會存入資料庫)
     * @summary Retrieve all rewilding spots
     * @param {boolean} [owner] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public getRewilds(owner?: boolean, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).getRewilds(owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 野放點自動完成
     * @param {string} [input] 關鍵字
     * @param {RewildAutoCompleteLanguageEnum} [language] 語言
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public rewildAutoComplete(input?: string, language?: RewildAutoCompleteLanguageEnum, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).rewildAutoComplete(input, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 附近的野放點
     * @param {RewildSearchNearbyTypeEnum} [type] 
     * @param {number} [lat] 
     * @param {number} [lng] 
     * @param {number} [radius] 半徑(單位為公尺)
     * @param {RewildSearchNearbyLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public rewildSearchNearby(type?: RewildSearchNearbyTypeEnum, lat?: number, lng?: number, radius?: number, language?: RewildSearchNearbyLanguageEnum, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).rewildSearchNearby(type, lat, lng, radius, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 矩形是經緯度可視區域，以兩個 沿著低點和高點對角線。低點標示西南方 矩形的角落，高點代表東北方
     * @summary 野放點關鍵字搜尋
     * @param {string} [keyword] 
     * @param {string} [rectangleLowLat] 
     * @param {string} [rectangleLowLng] 
     * @param {number} [rectangleHightLat] 
     * @param {number} [rectangleHightLng] 
     * @param {RewildSearchTextLanguageEnum} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public rewildSearchText(keyword?: string, rectangleLowLat?: string, rectangleLowLng?: string, rectangleHightLat?: number, rectangleHightLng?: number, language?: RewildSearchTextLanguageEnum, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).rewildSearchText(keyword, rectangleLowLat, rectangleLowLng, rectangleHightLat, rectangleHightLng, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search rewilding from Google
     * @summary Search rewilding from Google
     * @param {string} [lat] Latitude
     * @param {string} [lng] Longitude
     * @param {SearchRewildingTypeEnum} [type] Activity type
     * @param {string} [search] Search by Text
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T2BasecampApi
     */
    public searchRewilding(lat?: string, lng?: string, type?: SearchRewildingTypeEnum, search?: string, options?: RawAxiosRequestConfig) {
        return T2BasecampApiFp(this.configuration).searchRewilding(lat, lng, type, search, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RewildAutoCompleteLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildAutoCompleteLanguageEnum = typeof RewildAutoCompleteLanguageEnum[keyof typeof RewildAutoCompleteLanguageEnum];
/**
 * @export
 */
export const RewildSearchNearbyTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type RewildSearchNearbyTypeEnum = typeof RewildSearchNearbyTypeEnum[keyof typeof RewildSearchNearbyTypeEnum];
/**
 * @export
 */
export const RewildSearchNearbyLanguageEnum = {
    En: 'en',
    ZhTw: 'zh-TW'
} as const;
export type RewildSearchNearbyLanguageEnum = typeof RewildSearchNearbyLanguageEnum[keyof typeof RewildSearchNearbyLanguageEnum];
/**
 * @export
 */
export const RewildSearchTextLanguageEnum = {
    ZhTw: 'zh-TW',
    En: 'en'
} as const;
export type RewildSearchTextLanguageEnum = typeof RewildSearchTextLanguageEnum[keyof typeof RewildSearchTextLanguageEnum];
/**
 * @export
 */
export const SearchRewildingTypeEnum = {
    MountainClimbing: 'mountain_climbing',
    HikingArea: 'hiking_area',
    EcolLandscape: 'ecol_landscape',
    Camping: 'camping',
    Picnic: 'picnic',
    WaterRelated: 'water_related'
} as const;
export type SearchRewildingTypeEnum = typeof SearchRewildingTypeEnum[keyof typeof SearchRewildingTypeEnum];


/**
 * T3AchievementApi - axios parameter creator
 * @export
 */
export const T3AchievementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp: async (eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabExp', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/experience`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogExperience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollabQuestionnaire', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/questionnaire`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink: async (eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createCollaborativeAlbumLink', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsDate' is not null or undefined
            assertParamExists('createEvent', 'eventsDate', eventsDate)
            // verify required parameter 'eventsDateEnd' is not null or undefined
            assertParamExists('createEvent', 'eventsDateEnd', eventsDateEnd)
            // verify required parameter 'eventsDeadline' is not null or undefined
            assertParamExists('createEvent', 'eventsDeadline', eventsDeadline)
            // verify required parameter 'eventsLat' is not null or undefined
            assertParamExists('createEvent', 'eventsLat', eventsLat)
            // verify required parameter 'eventsLng' is not null or undefined
            assertParamExists('createEvent', 'eventsLng', eventsLng)
            // verify required parameter 'eventsMeetingPointLat' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLat', eventsMeetingPointLat)
            // verify required parameter 'eventsMeetingPointLng' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointLng', eventsMeetingPointLng)
            // verify required parameter 'eventsMeetingPointName' is not null or undefined
            assertParamExists('createEvent', 'eventsMeetingPointName', eventsMeetingPointName)
            // verify required parameter 'eventsName' is not null or undefined
            assertParamExists('createEvent', 'eventsName', eventsName)
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (eventsDate !== undefined) { 
                localVarFormParams.append('events_date', eventsDate as any);
            }
    
            if (eventsDateEnd !== undefined) { 
                localVarFormParams.append('events_date_end', eventsDateEnd as any);
            }
    
            if (eventsDeadline !== undefined) { 
                localVarFormParams.append('events_deadline', eventsDeadline as any);
            }
    
            if (eventsLat !== undefined) { 
                localVarFormParams.append('events_lat', eventsLat as any);
            }
    
            if (eventsLng !== undefined) { 
                localVarFormParams.append('events_lng', eventsLng as any);
            }
    
            if (eventsMeetingPointLat !== undefined) { 
                localVarFormParams.append('events_meeting_point_lat', eventsMeetingPointLat as any);
            }
    
            if (eventsMeetingPointLng !== undefined) { 
                localVarFormParams.append('events_meeting_point_lng', eventsMeetingPointLng as any);
            }
    
            if (eventsMeetingPointName !== undefined) { 
                localVarFormParams.append('events_meeting_point_name', eventsMeetingPointName as any);
            }
    
            if (eventsName !== undefined) { 
                localVarFormParams.append('events_name', eventsName as any);
            }
    
            if (eventsParticipantLimit !== undefined) { 
                localVarFormParams.append('events_participant_limit', eventsParticipantLimit as any);
            }
    
            if (eventsPaymentFee !== undefined) { 
                localVarFormParams.append('events_payment_fee', eventsPaymentFee as any);
            }
    
            if (eventsPaymentRequired !== undefined) { 
                localVarFormParams.append('events_payment_required', eventsPaymentRequired as any);
            }
    
            if (eventsPhoto !== undefined) { 
                localVarFormParams.append('events_photo', eventsPhoto as any);
            }
    
            if (eventsPlace !== undefined) { 
                localVarFormParams.append('events_place', eventsPlace as any);
            }
    
            if (eventsRequiresApproval !== undefined) { 
                localVarFormParams.append('events_requires_approval', eventsRequiresApproval as any);
            }
    
            if (eventsRewilding !== undefined) { 
                localVarFormParams.append('events_rewilding', eventsRewilding as any);
            }
    
            if (eventsType !== undefined) { 
                localVarFormParams.append('events_type', eventsType as any);
            }
                if (eventsParticipants) {
                localVarFormParams.append('events_participants', eventsParticipants.join(COLLECTION_FORMATS.csv));
            }

    
            if (eventsPhotoCover !== undefined) { 
                localVarFormParams.append('events_photo_cover', eventsPhotoCover as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid: async (eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('createPolaroid', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isCheck !== undefined) {
                localVarQueryParameter['is_check'] = isCheck;
            }


            if (eventPolaroidsFile !== undefined) { 
                localVarFormParams.append('event_polaroids_file', eventPolaroidsFile as any);
            }
    
            if (eventPolaroidsMessage !== undefined) { 
                localVarFormParams.append('event_polaroids_message', eventPolaroidsMessage as any);
            }
    
            if (eventPolaroidsTag !== undefined) { 
                localVarFormParams.append('event_polaroids_tag', eventPolaroidsTag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements: async (achievementType?: string, starType?: string, country?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }

            if (starType !== undefined) {
                localVarQueryParameter['star_type'] = starType;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1: async (achievementType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/achievement/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (achievementType !== undefined) {
                localVarQueryParameter['achievement_type'] = achievementType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getCollaborativeAlbumLinks', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/album-link`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs: async (rewildingId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (rewildingId !== undefined) {
                localVarQueryParameter['rewilding_id'] = rewildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventParticipant', 'eventId', eventId)
            const localVarPath = `/event/{eventId}/participants`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids: async (eventId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getPolaroids', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/polaroids`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink: async (eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'eventId', eventId)
            // verify required parameter 'albumLinkId' is not null or undefined
            assertParamExists('updateCollaborativeAlbumLink', 'albumLinkId', albumLinkId)
            const localVarPath = `/collaborative-log/{eventId}/album-link/{albumLinkId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"albumLinkId"}}`, encodeURIComponent(String(albumLinkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventAlbumLinks, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount: async (eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('updateRandomCount', 'eventId', eventId)
            const localVarPath = `/collaborative-log/{eventId}/random-count`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestCollaborativeLogQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * T3AchievementApi - functional programming interface
 * @export
 */
export const T3AchievementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = T3AchievementApiAxiosParamCreator(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabExp(eventId, requestCollaborativeLogExperience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.createCollabExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.createCollabQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.createCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPolaroidsSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.createPolaroid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements(achievementType, starType, country, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getAchievements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AchievementEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchievements_1(achievementType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getAchievements_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventAlbumLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeAlbumLinks(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getCollaborativeAlbumLinks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollaborativeLogs(rewildingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getCollaborativeLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventParticipant(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getEventParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolaroids(eventId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPolaroids200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolaroids(eventId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getPolaroids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAgg>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventAlbumLinkSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.updateCollaborativeAlbumLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeLogRandomCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T3AchievementApi.updateRandomCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * T3AchievementApi - factory interface
 * @export
 */
export const T3AchievementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = T3AchievementApiFp(configuration)
    return {
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Experience
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
         * @summary Create CollabLog Questionnaire
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<EventsSimple> {
            return localVarFp.createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Create Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Create Event
         * @param {string} eventsDate 活動開始時間
         * @param {string} eventsDateEnd 活動結束時間
         * @param {string} eventsDeadline 報名截止時間
         * @param {number} eventsLat 活動地點-經度
         * @param {number} eventsLng 活動地點-緯度
         * @param {number} eventsMeetingPointLat 集合地點-經度
         * @param {number} eventsMeetingPointLng 集合地點-緯度
         * @param {string} eventsMeetingPointName 
         * @param {string} eventsName 行程名稱
         * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
         * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
         * @param {number} [eventsPaymentRequired] 非商業團帶(0)
         * @param {File} [eventsPhoto] 
         * @param {string} [eventsPlace] Add from map: pass in Google Place ID
         * @param {number} [eventsRequiresApproval] 
         * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
         * @param {string} [eventsType] 
         * @param {Array<string>} [eventsParticipants] 
         * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(axios, basePath));
        },
        /**
         * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
         * @summary Create Polaroid
         * @param {string} eventId String ID of the event
         * @param {boolean} [isCheck] Do not pass in this parameter for upload
         * @param {File} [eventPolaroidsFile] 
         * @param {string} [eventPolaroidsMessage] 
         * @param {string} [eventPolaroidsTag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig): AxiosPromise<EventPolaroidsSimple> {
            return localVarFp.createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements
         * @param {string} [achievementType] 
         * @param {string} [starType] Star type
         * @param {string} [country] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements(achievementType, starType, country, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all events
         * @summary Retrieve Achievements Places
         * @param {string} [achievementType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AchievementEvent>> {
            return localVarFp.getAchievements_1(achievementType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Retrieve Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventAlbumLink>> {
            return localVarFp.getCollaborativeAlbumLinks(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve events that has ended
         * @summary Event Collaborate
         * @param {string} [rewildingId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getCollaborativeLogs(rewildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an event\'s participants
         * @summary Retrieve Event Participants
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventParticipant(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EventParticipants>> {
            return localVarFp.getEventParticipant(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve event polaroid
         * @summary Retrieve Polaroid
         * @param {string} eventId String ID of the event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolaroids(eventId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetPolaroids200ResponseInner>> {
            return localVarFp.getPolaroids(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve random count
         * @summary Retrieve Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all users
         * @summary Retrieve Users
         * @param {string} [name] 用戶名稱
         * @param {string} [username] 用戶 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserAgg>> {
            return localVarFp.getUsers(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve album link in event
         * @summary Update Collaborative Log - Album Link
         * @param {string} eventId String ID of the event
         * @param {string} albumLinkId Album ID Link
         * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig): AxiosPromise<EventAlbumLinkSimple> {
            return localVarFp.updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(axios, basePath));
        },
        /**
         * Update random count up to 3
         * @summary Update Random Count
         * @param {string} eventId String ID of the event
         * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig): AxiosPromise<CollaborativeLogRandomCount> {
            return localVarFp.updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * T3AchievementApi - object-oriented interface
 * @export
 * @class T3AchievementApi
 * @extends {BaseAPI}
 */
export class T3AchievementApi extends BaseAPI {
    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Experience
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogExperience} [requestCollaborativeLogExperience] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public createCollabExp(eventId: string, requestCollaborativeLogExperience?: RequestCollaborativeLogExperience, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).createCollabExp(eventId, requestCollaborativeLogExperience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Flickr). Read location data and save to database
     * @summary Create CollabLog Questionnaire
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public createCollabQuestionnaire(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).createCollabQuestionnaire(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Create Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public createCollaborativeAlbumLink(eventId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).createCollaborativeAlbumLink(eventId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Create Event
     * @param {string} eventsDate 活動開始時間
     * @param {string} eventsDateEnd 活動結束時間
     * @param {string} eventsDeadline 報名截止時間
     * @param {number} eventsLat 活動地點-經度
     * @param {number} eventsLng 活動地點-緯度
     * @param {number} eventsMeetingPointLat 集合地點-經度
     * @param {number} eventsMeetingPointLng 集合地點-緯度
     * @param {string} eventsMeetingPointName 
     * @param {string} eventsName 行程名稱
     * @param {number} [eventsParticipantLimit] 人數上限 (0表示不限制)
     * @param {number} [eventsPaymentFee] 報名費用 (商業團專用)
     * @param {number} [eventsPaymentRequired] 非商業團帶(0)
     * @param {File} [eventsPhoto] 
     * @param {string} [eventsPlace] Add from map: pass in Google Place ID
     * @param {number} [eventsRequiresApproval] 
     * @param {string} [eventsRewilding] Add from pocketlist: Pass in Rewilding ID
     * @param {string} [eventsType] 
     * @param {Array<string>} [eventsParticipants] 
     * @param {string} [eventsPhotoCover] DEFAULT_0 (SKY), DEFAULT_1 (REWILDMODE_DEFAULT)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public createEvent(eventsDate: string, eventsDateEnd: string, eventsDeadline: string, eventsLat: number, eventsLng: number, eventsMeetingPointLat: number, eventsMeetingPointLng: number, eventsMeetingPointName: string, eventsName: string, eventsParticipantLimit?: number, eventsPaymentFee?: number, eventsPaymentRequired?: number, eventsPhoto?: File, eventsPlace?: string, eventsRequiresApproval?: number, eventsRewilding?: string, eventsType?: string, eventsParticipants?: Array<string>, eventsPhotoCover?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).createEvent(eventsDate, eventsDateEnd, eventsDeadline, eventsLat, eventsLng, eventsMeetingPointLat, eventsMeetingPointLng, eventsMeetingPointName, eventsName, eventsParticipantLimit, eventsPaymentFee, eventsPaymentRequired, eventsPhoto, eventsPlace, eventsRequiresApproval, eventsRewilding, eventsType, eventsParticipants, eventsPhotoCover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create event polaroid (Uploaded file will be uploaded on Cloudflare). Read location data and save to database
     * @summary Create Polaroid
     * @param {string} eventId String ID of the event
     * @param {boolean} [isCheck] Do not pass in this parameter for upload
     * @param {File} [eventPolaroidsFile] 
     * @param {string} [eventPolaroidsMessage] 
     * @param {string} [eventPolaroidsTag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public createPolaroid(eventId: string, isCheck?: boolean, eventPolaroidsFile?: File, eventPolaroidsMessage?: string, eventPolaroidsTag?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).createPolaroid(eventId, isCheck, eventPolaroidsFile, eventPolaroidsMessage, eventPolaroidsTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements
     * @param {string} [achievementType] 
     * @param {string} [starType] Star type
     * @param {string} [country] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getAchievements(achievementType?: string, starType?: string, country?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getAchievements(achievementType, starType, country, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all events
     * @summary Retrieve Achievements Places
     * @param {string} [achievementType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getAchievements_1(achievementType?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getAchievements_1(achievementType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Retrieve Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getCollaborativeAlbumLinks(eventId: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getCollaborativeAlbumLinks(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve events that has ended
     * @summary Event Collaborate
     * @param {string} [rewildingId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getCollaborativeLogs(rewildingId?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getCollaborativeLogs(rewildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an event\'s participants
     * @summary Retrieve Event Participants
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getEventParticipant(eventId: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getEventParticipant(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve event polaroid
     * @summary Retrieve Polaroid
     * @param {string} eventId String ID of the event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getPolaroids(eventId: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getPolaroids(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve random count
     * @summary Retrieve Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all users
     * @summary Retrieve Users
     * @param {string} [name] 用戶名稱
     * @param {string} [username] 用戶 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public getUsers(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).getUsers(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve album link in event
     * @summary Update Collaborative Log - Album Link
     * @param {string} eventId String ID of the event
     * @param {string} albumLinkId Album ID Link
     * @param {RequestEventAlbumLinks} [requestEventAlbumLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public updateCollaborativeAlbumLink(eventId: string, albumLinkId: string, requestEventAlbumLinks?: RequestEventAlbumLinks, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).updateCollaborativeAlbumLink(eventId, albumLinkId, requestEventAlbumLinks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update random count up to 3
     * @summary Update Random Count
     * @param {string} eventId String ID of the event
     * @param {RequestCollaborativeLogQuestionnaire} [requestCollaborativeLogQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T3AchievementApi
     */
    public updateRandomCount(eventId: string, requestCollaborativeLogQuestionnaire?: RequestCollaborativeLogQuestionnaire, options?: RawAxiosRequestConfig) {
        return T3AchievementApiFp(this.configuration).updateRandomCount(eventId, requestCollaborativeLogQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * T4WorldApi - axios parameter creator
 * @export
 */
export const T4WorldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oosa-daily`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing: async (requestUserFollowing?: RequestUserFollowing, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFollowing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById: async (requestUserFriend?: RequestUserFriend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFriend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel: async (feelings?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-feelings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feelings !== undefined) {
                localVarQueryParameter['feelings'] = feelings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * T4WorldApi - functional programming interface
 * @export
 */
export const T4WorldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = T4WorldApiAxiosParamCreator(configuration)
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserDailyVideo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserDailyVideo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.checkUserDailyVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFollowing(requestUserFollowing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.createUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserFriendById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFriendById(requestUserFriend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.createUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getNews(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<News>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNews(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getNews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankFeel(feelings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getRankFeel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankRewild(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankRewild(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getRankRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFollowings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowing(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorldStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWorldStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorldStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T4WorldApi.getUserWorldStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * T4WorldApi - factory interface
 * @export
 */
export const T4WorldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = T4WorldApiFp(configuration)
    return {
        /**
         * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
         * @summary OOSA User Daily Video Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserDailyVideo(options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.checkUserDailyVideo(options).then((request) => request(axios, basePath));
        },
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createUserFollowing(requestUserFollowing, options).then((request) => request(axios, basePath));
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserFriendById200Response> {
            return localVarFp.createUserFriendById(requestUserFriend, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new event
         * @summary Retrieve News
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getNews(options?: RawAxiosRequestConfig): AxiosPromise<Array<News>> {
            return localVarFp.getNews(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankFeel(feelings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild(options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankRewild(options).then((request) => request(axios, basePath));
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserFollowings>> {
            return localVarFp.getUserFollowing(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserWorldStat200Response> {
            return localVarFp.getUserWorldStat(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * T4WorldApi - object-oriented interface
 * @export
 * @class T4WorldApi
 * @extends {BaseAPI}
 */
export class T4WorldApi extends BaseAPI {
    /**
     * 此 API 的功能是檢查使用者是否已觀看 OOSA 的每日影片，並回傳結果。   This API checks whether a user has watched OOSA\'s daily video and returns the result.
     * @summary OOSA User Daily Video Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public checkUserDailyVideo(options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).checkUserDailyVideo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create user following request testt
     * @summary Create User Following
     * @param {RequestUserFollowing} [requestUserFollowing] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).createUserFollowing(requestUserFollowing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
     * @summary Add User Friend
     * @param {RequestUserFriend} [requestUserFriend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).createUserFriendById(requestUserFriend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new event
     * @summary Retrieve News
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getNews(options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getNews(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Feelings
     * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getRankFeel(feelings?: string, options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getRankFeel(feelings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getRankRewild(options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getRankRewild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get other user following friends
     * @summary Retrieve User Following
     * @param {string} [userId] current user\&#39;s id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getUserFollowing(userId?: string, options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getUserFollowing(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve World Statistics
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T4WorldApi
     */
    public getUserWorldStat(options?: RawAxiosRequestConfig) {
        return T4WorldApiFp(this.configuration).getUserWorldStat(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * T5MyApi - axios parameter creator
 * @export
 */
export const T5MyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat: async (eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('changeEventInvitationStat', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEventInvitationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs: async (requestContactUs?: RequestContactUs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestContactUs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword: async (requestForgetPassword?: RequestForgetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forget-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated: async (token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('forgetPasswordUpdated', 'token', token)
            const localVarPath = `/forget-password/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestForgetPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations: async (applied?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge: async (single?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/badges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (single !== undefined) {
                localVarQueryParameter['single'] = single;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation: async (eventInvitationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventInvitationId' is not null or undefined
            assertParamExists('getEventInvitation', 'eventInvitationId', eventInvitationId)
            const localVarPath = `/event-invitations/{eventInvitationId}`
                .replace(`{${"eventInvitationId"}}`, encodeURIComponent(String(eventInvitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault: async (requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateAvatar, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture: async (usersAvatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (usersAvatar !== undefined) { 
                localVarFormParams.append('users_avatar', usersAvatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword: async (requestUsersUpdatePassword?: RequestUsersUpdatePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (requestUsersUpdate?: RequestUsersUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUsersUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet: async (requestAuthUpdateSetting?: RequestAuthUpdateSetting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestAuthUpdateSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_1: async (updateUserRequest?: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/take-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * T5MyApi - functional programming interface
 * @export
 */
export const T5MyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = T5MyApiAxiosParamCreator(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeEventInvitationStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.changeEventInvitationStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContactUs(requestContactUs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.createContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(requestForgetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.forgetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPasswordUpdated(token, requestForgetPasswordReset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.forgetPasswordUpdated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventsInvitations(applied, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getAllEventsInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getAuthInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadge(single?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBadges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadge(single, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getBadge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventInvitation(eventInvitationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getEventInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNotifications>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.getUserStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUseDefault(requestAuthUpdateAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updateAvatarUseDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAvatarUsePicture(usersAvatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updateAvatarUsePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(requestUsersUpdatePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(requestUsersUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSet(requestAuthUpdateSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updateUserSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser_1(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['T5MyApi.updateUser_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * T5MyApi - factory interface
 * @export
 */
export const T5MyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = T5MyApiFp(configuration)
    return {
        /**
         * Change event invitation status
         * @summary Change event invitation status
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {boolean} [applied] set true if its a join request
         * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ChangeEventInvitationStat200Response> {
            return localVarFp.changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Create contact us record
         * @summary Create Contact Us
         * @param {RequestContactUs} [requestContactUs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createContactUs(requestContactUs, options).then((request) => request(axios, basePath));
        },
        /**
         * Forget Password Request
         * @summary Forget Password
         * @param {RequestForgetPassword} [requestForgetPassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPassword(requestForgetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update password from forget password
         * @summary Forget Password - Updated
         * @param {number} token Token from password reset
         * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all event invitations
         * @summary Retrieve all event invitations
         * @param {boolean} [applied] Pass true to retrieve applied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetAllEventsInvitations200ResponseInner>> {
            return localVarFp.getAllEventsInvitations(applied, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
         * @summary Read Authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getAuthInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge(single?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UserBadges> {
            return localVarFp.getBadge(single, options).then((request) => request(axios, basePath));
        },
        /**
         * Read event invitations
         * @summary Read event invitations
         * @param {string} eventInvitationId String ID of the event invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getEventInvitation(eventInvitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserNotifications>> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserStat200Response> {
            return localVarFp.getUserStat(options).then((request) => request(axios, basePath));
        },
        /**
         * Update user avatar
         * @summary Update User Avatar
         * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile picture
         * @summary Update User Profile Picture
         * @param {File} [usersAvatar] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateAvatarUsePicture(usersAvatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user password
         * @summary Update Password
         * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.updatePassword(requestUsersUpdatePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User
         * @param {RequestUsersUpdate} [requestUsersUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser(requestUsersUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings<br/>1 - True (On)<br />0 - False (Off)
         * @summary Update User Setting
         * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUserSet(requestAuthUpdateSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authenticated user detail
         * @summary Update User Take Me
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.updateUser_1(updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * T5MyApi - object-oriented interface
 * @export
 * @class T5MyApi
 * @extends {BaseAPI}
 */
export class T5MyApi extends BaseAPI {
    /**
     * Change event invitation status
     * @summary Change event invitation status
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {boolean} [applied] set true if its a join request
     * @param {RequestEventInvitationUpdate} [requestEventInvitationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public changeEventInvitationStat(eventInvitationId: string, applied?: boolean, requestEventInvitationUpdate?: RequestEventInvitationUpdate, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).changeEventInvitationStat(eventInvitationId, applied, requestEventInvitationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create contact us record
     * @summary Create Contact Us
     * @param {RequestContactUs} [requestContactUs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public createContactUs(requestContactUs?: RequestContactUs, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).createContactUs(requestContactUs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forget Password Request
     * @summary Forget Password
     * @param {RequestForgetPassword} [requestForgetPassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public forgetPassword(requestForgetPassword?: RequestForgetPassword, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).forgetPassword(requestForgetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update password from forget password
     * @summary Forget Password - Updated
     * @param {number} token Token from password reset
     * @param {RequestForgetPasswordReset} [requestForgetPasswordReset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public forgetPasswordUpdated(token: number, requestForgetPasswordReset?: RequestForgetPasswordReset, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).forgetPasswordUpdated(token, requestForgetPasswordReset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all event invitations
     * @summary Retrieve all event invitations
     * @param {boolean} [applied] Pass true to retrieve applied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getAllEventsInvitations(applied?: boolean, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getAllEventsInvitations(applied, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the authenticated user detail. <br/>1. Google<br/>2. Line<br/>3. Email<br/>4. Facebook
     * @summary Read Authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getAuthInfo(options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getAuthInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve badges earned by user
     * @summary Retrieve Badge
     * @param {boolean} [single] Single acquire
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getBadge(single?: boolean, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getBadge(single, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read event invitations
     * @summary Read event invitations
     * @param {string} eventInvitationId String ID of the event invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getEventInvitation(eventInvitationId: string, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getEventInvitation(eventInvitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve notifications
     * @summary Retrieve User Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getUserNotifications(options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public getUserStat(options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).getUserStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user avatar
     * @summary Update User Avatar
     * @param {RequestAuthUpdateAvatar} [requestAuthUpdateAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updateAvatarUseDefault(requestAuthUpdateAvatar?: RequestAuthUpdateAvatar, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updateAvatarUseDefault(requestAuthUpdateAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile picture
     * @summary Update User Profile Picture
     * @param {File} [usersAvatar] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updateAvatarUsePicture(usersAvatar?: File, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updateAvatarUsePicture(usersAvatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user password
     * @summary Update Password
     * @param {RequestUsersUpdatePassword} [requestUsersUpdatePassword] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updatePassword(requestUsersUpdatePassword?: RequestUsersUpdatePassword, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updatePassword(requestUsersUpdatePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User
     * @param {RequestUsersUpdate} [requestUsersUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updateUser(requestUsersUpdate?: RequestUsersUpdate, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updateUser(requestUsersUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings<br/>1 - True (On)<br />0 - False (Off)
     * @summary Update User Setting
     * @param {RequestAuthUpdateSetting} [requestAuthUpdateSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updateUserSet(requestAuthUpdateSetting?: RequestAuthUpdateSetting, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updateUserSet(requestAuthUpdateSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authenticated user detail
     * @summary Update User Take Me
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof T5MyApi
     */
    public updateUser_1(updateUserRequest?: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return T5MyApiFp(this.configuration).updateUser_1(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserBadgesApi - axios parameter creator
 * @export
 */
export const UserBadgesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge: async (single?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/badges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (single !== undefined) {
                localVarQueryParameter['single'] = single;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserBadgesApi - functional programming interface
 * @export
 */
export const UserBadgesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserBadgesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBadge(single?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBadges>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBadge(single, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserBadgesApi.getBadge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserBadgesApi - factory interface
 * @export
 */
export const UserBadgesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserBadgesApiFp(configuration)
    return {
        /**
         * Retrieve badges earned by user
         * @summary Retrieve Badge
         * @param {boolean} [single] Single acquire
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBadge(single?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UserBadges> {
            return localVarFp.getBadge(single, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserBadgesApi - object-oriented interface
 * @export
 * @class UserBadgesApi
 * @extends {BaseAPI}
 */
export class UserBadgesApi extends BaseAPI {
    /**
     * Retrieve badges earned by user
     * @summary Retrieve Badge
     * @param {boolean} [single] Single acquire
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserBadgesApi
     */
    public getBadge(single?: boolean, options?: RawAxiosRequestConfig) {
        return UserBadgesApiFp(this.configuration).getBadge(single, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserEventApi - axios parameter creator
 * @export
 */
export const UserEventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends: async (userId: string, name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOtherUserFriends', 'userId', userId)
            const localVarPath = `/user/{userId}/friends`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel: async (feelings?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-feelings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (feelings !== undefined) {
                localVarQueryParameter['feelings'] = feelings;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/ranking-rewilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserBadges', 'userId', userId)
            const localVarPath = `/user/{userId}/badges`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode: async (past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (hasPolaroid !== undefined) {
                localVarQueryParameter['has_polaroid'] = hasPolaroid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId: async (userId: string, past?: boolean, countryCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserEventbyId', 'userId', userId)
            const localVarPath = `/user/{userId}/events`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (past !== undefined) {
                localVarQueryParameter['past'] = past;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/world/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserEventApi - functional programming interface
 * @export
 */
export const UserEventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserEventApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOtherUserFriends(userId, name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getOtherUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankFeel(feelings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getRankFeel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankRewild(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingRewilding>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankRewild(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getRankRewild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOther>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBadges(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBadges(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserBadges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyCode(past, countryCode, page, hasPolaroid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserEventbyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Events>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserEventbyId(userId, past, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserEventbyId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserStatistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserStatistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorldStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserWorldStat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorldStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserEventApi.getUserWorldStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserEventApi - factory interface
 * @export
 */
export const UserEventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserEventApiFp(configuration)
    return {
        /**
         * Retrieve an authenticated user events
         * @summary Retrieve Other User Friends
         * @param {string} userId 
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getOtherUserFriends(userId, name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Feelings
         * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankFeel(feelings?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankFeel(feelings, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Ranking Rewilding
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankRewild(options?: RawAxiosRequestConfig): AxiosPromise<Array<RankingRewilding>> {
            return localVarFp.getRankRewild(options).then((request) => request(axios, basePath));
        },
        /**
         * API 回傳指定會員的公開資料
         * @summary Read User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOther> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 預期會回傳指定會員的所有公開徽章
         * @summary User Badges
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBadges(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserBadges(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Self User Event
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {number} [page] 
         * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve other users events
         * @summary Other User Event
         * @param {string} userId 
         * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
         * @param {string} [countryCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Events>> {
            return localVarFp.getUserEventbyId(userId, past, countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an authenticated user events
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserStat200Response> {
            return localVarFp.getUserStat(options).then((request) => request(axios, basePath));
        },
        /**
         * get my statistics
         * @summary Auth Statistics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserStatistics(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserStatistics(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve World Statistics
         * @summary Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorldStat(options?: RawAxiosRequestConfig): AxiosPromise<GetUserWorldStat200Response> {
            return localVarFp.getUserWorldStat(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserEventApi - object-oriented interface
 * @export
 * @class UserEventApi
 * @extends {BaseAPI}
 */
export class UserEventApi extends BaseAPI {
    /**
     * Retrieve an authenticated user events
     * @summary Retrieve Other User Friends
     * @param {string} userId 
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getOtherUserFriends(userId: string, name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getOtherUserFriends(userId, name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Feelings
     * @param {string} [feelings] \&quot;EXPERIENCE_1\&quot;, \&quot;EXPERIENCE_2\&quot;, \&quot;EXPERIENCE_3\&quot;, \&quot;EXPERIENCE_4\&quot;, \&quot;EXPERIENCE_5\&quot;, \&quot;EXPERIENCE_6\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getRankFeel(feelings?: string, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getRankFeel(feelings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Ranking Rewilding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getRankRewild(options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getRankRewild(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API 回傳指定會員的公開資料
     * @summary Read User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 預期會回傳指定會員的所有公開徽章
     * @summary User Badges
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserBadges(userId: string, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserBadges(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Self User Event
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {number} [page] 
     * @param {boolean} [hasPolaroid] Pass in true for those with polaroids or false for no polaroids by this user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserEventbyCode(past?: boolean, countryCode?: string, page?: number, hasPolaroid?: boolean, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserEventbyCode(past, countryCode, page, hasPolaroid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve other users events
     * @summary Other User Event
     * @param {string} userId 
     * @param {boolean} [past] Pass true to retrieve past events by user. Otherwise omit this query parameter
     * @param {string} [countryCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserEventbyId(userId: string, past?: boolean, countryCode?: string, options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserEventbyId(userId, past, countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an authenticated user events
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserStat(options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get my statistics
     * @summary Auth Statistics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserStatistics(options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserStatistics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve World Statistics
     * @summary Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserEventApi
     */
    public getUserWorldStat(options?: RawAxiosRequestConfig) {
        return UserEventApiFp(this.configuration).getUserWorldStat(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserFollowingApi - axios parameter creator
 * @export
 */
export const UserFollowingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing: async (requestUserFollowing?: RequestUserFollowing, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFollowing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUserFollowing: async (userFollowingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFollowingId' is not null or undefined
            assertParamExists('deleteUserFollowing', 'userFollowingId', userFollowingId)
            const localVarPath = `/user-following/{userFollowingId}`
                .replace(`{${"userFollowingId"}}`, encodeURIComponent(String(userFollowingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowingId: async (userFollowingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFollowingId' is not null or undefined
            assertParamExists('getUserFollowingId', 'userFollowingId', userFollowingId)
            const localVarPath = `/user-following/{userFollowingId}`
                .replace(`{${"userFollowingId"}}`, encodeURIComponent(String(userFollowingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserFollowingApi - functional programming interface
 * @export
 */
export const UserFollowingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserFollowingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFollowing(requestUserFollowing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFollowingApi.createUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFollowing(userFollowingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFollowingApi.deleteUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFollowings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowing(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFollowingApi.getUserFollowing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFollowings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowingId(userFollowingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFollowingApi.getUserFollowingId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserFollowingApi - factory interface
 * @export
 */
export const UserFollowingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserFollowingApiFp(configuration)
    return {
        /**
         * Create user following request testt
         * @summary Create User Following
         * @param {RequestUserFollowing} [requestUserFollowing] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.createUserFollowing(requestUserFollowing, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user following 
         * @summary Delete User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFollowing(userFollowingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get other user following friends
         * @summary Retrieve User Following
         * @param {string} [userId] current user\&#39;s id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowing(userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserFollowings>> {
            return localVarFp.getUserFollowing(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user following
         * @summary Read User Following
         * @param {string} userFollowingId String ID of the user following
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserFollowings> {
            return localVarFp.getUserFollowingId(userFollowingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserFollowingApi - object-oriented interface
 * @export
 * @class UserFollowingApi
 * @extends {BaseAPI}
 */
export class UserFollowingApi extends BaseAPI {
    /**
     * Create user following request testt
     * @summary Create User Following
     * @param {RequestUserFollowing} [requestUserFollowing] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserFollowingApi
     */
    public createUserFollowing(requestUserFollowing?: RequestUserFollowing, options?: RawAxiosRequestConfig) {
        return UserFollowingApiFp(this.configuration).createUserFollowing(requestUserFollowing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user following 
     * @summary Delete User Following
     * @param {string} userFollowingId String ID of the user following
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserFollowingApi
     */
    public deleteUserFollowing(userFollowingId: string, options?: RawAxiosRequestConfig) {
        return UserFollowingApiFp(this.configuration).deleteUserFollowing(userFollowingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get other user following friends
     * @summary Retrieve User Following
     * @param {string} [userId] current user\&#39;s id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserFollowingApi
     */
    public getUserFollowing(userId?: string, options?: RawAxiosRequestConfig) {
        return UserFollowingApiFp(this.configuration).getUserFollowing(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user following
     * @summary Read User Following
     * @param {string} userFollowingId String ID of the user following
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserFollowingApi
     */
    public getUserFollowingId(userFollowingId: string, options?: RawAxiosRequestConfig) {
        return UserFollowingApiFp(this.configuration).getUserFollowingId(userFollowingId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserFriendsApi - axios parameter creator
 * @export
 */
export const UserFriendsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById: async (requestUserFriend?: RequestUserFriend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestUserFriend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('deleteUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFriends_1: async (name?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserFriendsApi - functional programming interface
 * @export
 */
export const UserFriendsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserFriendsApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agreeUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.agreeUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserFriendById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFriendById(requestUserFriend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.createUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.deleteUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecommendedFriendsForUser(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.getRecommendedFriendsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOtherUserFriends200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.getUserFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFriends_1(name, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserFriendsApi.getUserFriends_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserFriendsApi - factory interface
 * @export
 */
export const UserFriendsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserFriendsApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
         * @summary Add User Friend
         * @param {RequestUserFriend} [requestUserFriend] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig): AxiosPromise<CreateUserFriendById200Response> {
            return localVarFp.createUserFriendById(requestUserFriend, options).then((request) => request(axios, basePath));
        },
        /**
         * user_friend_status should be set to 2 upon successful API completion.
         * @summary Cancel User Friend
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
         * @summary Retrieve Recommended Friends For User
         * @param {string} [name] 
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetRecommendedFriendsForUser200ResponseInner>> {
            return localVarFp.getRecommendedFriendsForUser(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
         * @summary Retrieve User Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetOtherUserFriends200ResponseInner>> {
            return localVarFp.getUserFriends(name, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user\'s friends Sort by breathing status first, then by name.
         * @summary My Friends
         * @param {string} [name] name
         * @param {string} [username] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.getUserFriends_1(name, username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserFriendsApi - object-oriented interface
 * @export
 * @class UserFriendsApi
 * @extends {BaseAPI}
 */
export class UserFriendsApi extends BaseAPI {
    /**
     * user_friend_status should be set to 1 upon successful API completion.
     * @summary Agree User Friend 
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * user_friend_status should be set to 0 upon successful API completion. friendship limit is 5000.
     * @summary Add User Friend
     * @param {RequestUserFriend} [requestUserFriend] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public createUserFriendById(requestUserFriend?: RequestUserFriend, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).createUserFriendById(requestUserFriend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * user_friend_status should be set to 2 upon successful API completion.
     * @summary Cancel User Friend
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public deleteUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).deleteUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * sort: 1 > 2 1. Users who have previously attended an event together but have not yet become friends ( user_friends_status = 0 ) 2. Partners who have been invited but have not yet responded  ( user_friends_status = 1 ) If no users meet the above conditions, do not display
     * @summary Retrieve Recommended Friends For User
     * @param {string} [name] 
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public getRecommendedFriendsForUser(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).getRecommendedFriendsForUser(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get someone\'s friends Use feild_username and feild_name to select specific friends; if no parameters are provided, all friends will be returned. Sort by breathing status first, then by name. 找到某個會員用戶的所有好友，並且可以用 name 和 username 篩選其好友列表
     * @summary Retrieve User Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public getUserFriends(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).getUserFriends(name, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user\'s friends Sort by breathing status first, then by name.
     * @summary My Friends
     * @param {string} [name] name
     * @param {string} [username] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserFriendsApi
     */
    public getUserFriends_1(name?: string, username?: string, options?: RawAxiosRequestConfig) {
        return UserFriendsApiFp(this.configuration).getUserFriends_1(name, username, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserNotificationsApi - axios parameter creator
 * @export
 */
export const UserNotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById: async (userFriendsId: string, notificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFriendsId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'userFriendsId', userFriendsId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('agreeUserFriendById', 'notificationId', notificationId)
            const localVarPath = `/user/friends/{userFriendsId}`
                .replace(`{${"userFriendsId"}}`, encodeURIComponent(String(userFriendsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (notificationId !== undefined) {
                localVarQueryParameter['Notification_Id'] = notificationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserNotificationsApi - functional programming interface
 * @export
 */
export const UserNotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserNotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeneralSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agreeUserFriendById(userFriendsId, notificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserNotificationsApi.agreeUserFriendById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNotifications>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserNotificationsApi.getUserNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserNotificationsApi - factory interface
 * @export
 */
export const UserNotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserNotificationsApiFp(configuration)
    return {
        /**
         * user_friend_status should be set to 1 upon successful API completion.
         * @summary Agree User Friend 
         * @param {string} userFriendsId 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGeneralSuccess> {
            return localVarFp.agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notifications
         * @summary Retrieve User Notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserNotifications>> {
            return localVarFp.getUserNotifications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserNotificationsApi - object-oriented interface
 * @export
 * @class UserNotificationsApi
 * @extends {BaseAPI}
 */
export class UserNotificationsApi extends BaseAPI {
    /**
     * user_friend_status should be set to 1 upon successful API completion.
     * @summary Agree User Friend 
     * @param {string} userFriendsId 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserNotificationsApi
     */
    public agreeUserFriendById(userFriendsId: string, notificationId: string, options?: RawAxiosRequestConfig) {
        return UserNotificationsApiFp(this.configuration).agreeUserFriendById(userFriendsId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve notifications
     * @summary Retrieve User Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserNotificationsApi
     */
    public getUserNotifications(options?: RawAxiosRequestConfig) {
        return UserNotificationsApiFp(this.configuration).getUserNotifications(options).then((request) => request(this.axios, this.basePath));
    }
}



